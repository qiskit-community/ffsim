{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Introduction to ffsim\n",
    "\n",
    "ffsim is a software library for simulating fermionic quantum circuits that conserve particle number and the Z component of spin. By taking advantage of these symmetries, it can simulate these circuits much more efficiently than a generic quantum circuit simulator.\n",
    "\n",
    "ffsim is a rather \"low-level\" software library. It does not have a class for representing quantum circuits. The primary way of using ffsim is by calling functions that transform statevectors represented directly as NumPy arrays. As an example, the following code shows how to create a Slater determinant and apply an orbital rotation to it."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import ffsim\n",
    "\n",
    "# Set the number of orbitals and their occupancies\n",
    "norb = 6\n",
    "nelec = (3, 2)\n",
    "n_alpha, n_beta = nelec\n",
    "occupied_orbitals = (range(n_alpha), range(n_beta))\n",
    "\n",
    "# Create a Slater determinant\n",
    "vec = ffsim.slater_determinant(norb, occupied_orbitals=occupied_orbitals)\n",
    "\n",
    "# Generate a random orbital rotation\n",
    "orbital_rotation = ffsim.random.random_unitary(norb, seed=1234)\n",
    "\n",
    "# Apply the orbital rotation to the statevector\n",
    "rotated_vec = ffsim.apply_orbital_rotation(\n",
    "    vec, orbital_rotation, norb=norb, nelec=nelec\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here, `vec` is a plain one-dimensional NumPy array (a vector). Its length is determined by the number of orbitals and their occupancies. Because ffsim only implements transformations which conserve particle number and the Z component of spin, the number of $\\alpha$-electrons and the number of $\\beta$-electrons are each fixed. For a system with $N$ spatial orbitals, $N_\\alpha$ electrons with spin $\\alpha$, and $N_\\beta$ electrons with spin $\\beta$, the statevector has length\n",
    "\n",
    "$$\n",
    "{N \\choose N_\\alpha} \\times {N \\choose N_\\beta}.\n",
    "$$\n",
    "\n",
    "For convenience, ffsim includes functions to calculate these dimensions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "from scipy.special import comb\n",
    "\n",
    "dim_a = comb(norb, n_alpha, exact=True)\n",
    "dim_b = comb(norb, n_beta, exact=True)\n",
    "dim = dim_a * dim_b\n",
    "assert vec.shape == (dim,)\n",
    "assert ffsim.dims(norb, nelec) == (dim_a, dim_b)\n",
    "assert ffsim.dim(norb, nelec) == dim"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This representation of the statevector is the same as that used in standard full configuration interaction (FCI) routines. It is often convenient to represent the statevector as a matrix whose rows are indexed by \"$\\alpha$-strings\" describing the occupancies of the $\\alpha$ orbitals, and columns indexed by \"$\\beta$-strings\" describing the occupancies of the $\\beta$ orbitals. To convert the vector into this representation, simply reshape it:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "reshaped_vec = vec.reshape((dim_a, dim_b))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The statevector representation depends on a choice of ordering for the $\\alpha$- and $\\beta$-strings. ffsim uses the same ordering as pySCF's FCI module, `pyscf.fci`."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "ffsim-1cfkSnAR",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.11"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
