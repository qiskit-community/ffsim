<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>The local unitary cluster Jastrow (LUCJ) ansatz &#8212; ffsim 0.0.18.dev0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=039e1c02" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css" />
    <script src="../_static/documentation_options.js?v=e7a0160f"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Entanglement forging" href="05-entanglement-forging.html" />
    <link rel="prev" title="Diagonal Coulomb operators and double-factorized Trotter simulation" href="03-double-factorized.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="The-local-unitary-cluster-Jastrow-(LUCJ)-ansatz">
<h1>The local unitary cluster Jastrow (LUCJ) ansatz<a class="headerlink" href="#The-local-unitary-cluster-Jastrow-(LUCJ)-ansatz" title="Link to this heading">¶</a></h1>
<p>In this tutorial, we show how to use ffsim to simulate the local unitary cluster Jastrow (LUCJ) ansatz. We’ll use it to calculate the ground state energy of an ethene molecule at a stretched bond length.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyscf</span>
<span class="kn">import</span> <span class="nn">pyscf.mcscf</span>
<span class="kn">import</span> <span class="nn">ffsim</span>

<span class="c1"># Build a stretched ethene molecule</span>
<span class="n">bond_distance</span> <span class="o">=</span> <span class="mf">2.678</span>
<span class="n">a</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">bond_distance</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mf">0.5626</span>
<span class="n">c</span> <span class="o">=</span> <span class="mf">0.9289</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">pyscf</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span>
    <span class="n">atom</span><span class="o">=</span><span class="p">[</span>
        <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)],</span>
        <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="p">)],</span>
        <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)],</span>
        <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)],</span>
        <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="p">)],</span>
        <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="p">)],</span>
    <span class="p">],</span>
    <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;sto-6g&quot;</span><span class="p">,</span>
    <span class="n">symmetry</span><span class="o">=</span><span class="s2">&quot;d2h&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">hartree_fock</span> <span class="o">=</span> <span class="n">pyscf</span><span class="o">.</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">hartree_fock</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1"># Define active space</span>
<span class="n">active_space</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># Get molecular data and molecular Hamiltonian (one- and two-body tensors)</span>
<span class="n">mol_data</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">MolecularData</span><span class="o">.</span><span class="n">from_scf</span><span class="p">(</span>
    <span class="n">hartree_fock</span><span class="p">,</span> <span class="n">active_space</span><span class="o">=</span><span class="n">active_space</span><span class="p">,</span> <span class="n">fci</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="n">norb</span> <span class="o">=</span> <span class="n">mol_data</span><span class="o">.</span><span class="n">norb</span>
<span class="n">nelec</span> <span class="o">=</span> <span class="n">mol_data</span><span class="o">.</span><span class="n">nelec</span>
<span class="n">mol_hamiltonian</span> <span class="o">=</span> <span class="n">mol_data</span><span class="o">.</span><span class="n">hamiltonian</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
converged SCF energy = -77.4456267643963
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
CASCI E = -77.6290254326717  E(CI) = -3.57322412553862  S^2 = 0.0000000
</pre></div></div>
</div>
<section id="The-unitary-cluster-Jastrow-(UCJ)-ansatz">
<h2>The unitary cluster Jastrow (UCJ) ansatz<a class="headerlink" href="#The-unitary-cluster-Jastrow-(UCJ)-ansatz" title="Link to this heading">¶</a></h2>
<p>Before describing the LUCJ, we first introduce the general unitary cluster ansatz (UCJ), which has the form</p>
<div class="math notranslate nohighlight">
\[\lvert \Psi \rangle = \prod_{k = 1}^L \mathcal{W_k} e^{i \mathcal{J}_k} \mathcal{W_k^\dagger} \lvert \Phi_0 \rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(\lvert \Phi_0 \rangle\)</span> is a reference state, often taken as the Hartree-Fock state, each <span class="math notranslate nohighlight">\(\mathcal{W_k}\)</span> is an <a class="reference internal" href="02-orbital-rotation.html"><span class="doc">orbital rotation</span></a>, and each <span class="math notranslate nohighlight">\(\mathcal{J}_k\)</span> is a diagonal Coulomb operator of the form</p>
<div class="math notranslate nohighlight">
\[\mathcal{J} = \frac12\sum_{ij,\sigma \tau} \mathbf{J}^{\sigma \tau}_{ij} n_{i,\sigma} n_{j,\tau}.\]</div>
<p>Note that this expression for the diagonal Coulomb operator is more general than the one introduced in <a class="reference internal" href="03-double-factorized.html"><span class="doc">the previous tutorial</span></a> because the matrices <span class="math notranslate nohighlight">\(\mathbf{J}^{\sigma \tau}\)</span> are indexed by the spins <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span>. In order that the operator commutes with the total spin Z operator, we enforce that <span class="math notranslate nohighlight">\(\mathbf{J}^{\alpha\alpha} = \mathbf{J}^{\beta\beta}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{J}^{\alpha\beta} = \mathbf{J}^{\beta\alpha}\)</span>. As a result, we
have two sets of matrices for describing the diagonal Coulomb operators: “alpha-alpha” matrices containing coefficients for terms involving the same spin, and “alpha-beta” matrices containing coefficients for terms involving different spins.</p>
<p>In ffsim, the UCJ ansatz operator <span class="math notranslate nohighlight">\(\prod_{k = 1}^L \mathcal{W_k} e^{i \mathcal{J}_k} \mathcal{W_k^\dagger}\)</span> is represented by the <code class="docutils literal notranslate"><span class="pre">UCJOperator</span></code> class, which is just a dataclass that stores the diagonal Coulomb matrices and orbital rotations. A constructor method is provided to initialize the operator from a truncated double factorization of t2 amplitudes (e.g. from CCSD or MP2).</p>
<p>In the code cell below, we run CCSD to get the t2 amplitudes for initializing the ansatz. We’ll create an ansatz operator with 2 repetitions (<span class="math notranslate nohighlight">\(L = 2\)</span>). For our reference state, we’ll use the Hartree-Fock state. Since <code class="docutils literal notranslate"><span class="pre">UCJOperator</span></code> defines a unitary effect, we can use the function <code class="docutils literal notranslate"><span class="pre">apply_unitary</span></code> to apply the ansatz operator to the reference state to obtain the ansatz state. Finally, we compute the energy of the ansatz state.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">cc</span>

<span class="c1"># Get CCSD t2 amplitudes for initializing the ansatz</span>
<span class="n">ccsd</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span>
    <span class="n">hartree_fock</span><span class="p">,</span>
    <span class="n">frozen</span><span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hartree_fock</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">active_space</span><span class="p">],</span>
<span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">ccsd</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1"># Construct UCJ operator</span>
<span class="n">n_reps</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">operator</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">UCJOperator</span><span class="o">.</span><span class="n">from_t_amplitudes</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">n_reps</span><span class="o">=</span><span class="n">n_reps</span><span class="p">)</span>

<span class="c1"># Construct the Hartree-Fock state to use as the reference state</span>
<span class="n">reference_state</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">hartree_fock_state</span><span class="p">(</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">)</span>

<span class="c1"># Apply the operator to the reference state</span>
<span class="n">ansatz_state</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">apply_unitary</span><span class="p">(</span><span class="n">reference_state</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">)</span>

<span class="c1"># Compute the energy ⟨ψ|H|ψ⟩ of the ansatz state</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">linear_operator</span><span class="p">(</span><span class="n">mol_hamiltonian</span><span class="p">,</span> <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">)</span>
<span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">ansatz_state</span><span class="p">,</span> <span class="n">hamiltonian</span> <span class="o">@</span> <span class="n">ansatz_state</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Energy at initialization: </span><span class="si">{</span><span class="n">energy</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
E(CCSD) = -77.49387212754473  E_corr = -0.04824536314851401
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Energy at initialization: -77.46975600021692
</pre></div></div>
</div>
<p>To facilitate variational optimization of the ansatz, <code class="docutils literal notranslate"><span class="pre">UCJOperator</span></code> implements methods for conversion to and from a vector of real-valued parameters. The precise relation between a parameter vector and the matrices of the UCJ operator is somewhat complicated. In short, the parameter vector stores the entries of the UCJ matrices in a non-redundant way (for the orbital rotations, the parameter vector actually stores the entries of their generators.)</p>
<p>The following code cell shows how one can define an objective function that takes as input a parameter vector and outputs the energy of the associated ansatz state, and then optimize this objective function using <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code>. Here, we set a small limit on the number of iterations; increase the value if you would like to run it to convergence.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.optimize</span>


<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># Initialize the ansatz operator from the parameter vector</span>
    <span class="n">operator</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">UCJOperator</span><span class="o">.</span><span class="n">from_parameters</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span> <span class="n">n_reps</span><span class="o">=</span><span class="n">n_reps</span><span class="p">)</span>
    <span class="c1"># Apply the ansatz operator to the reference state</span>
    <span class="n">final_state</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">apply_unitary</span><span class="p">(</span><span class="n">reference_state</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">)</span>
    <span class="c1"># Return the energy ⟨ψ|H|ψ⟩ of the ansatz state</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">final_state</span><span class="p">,</span> <span class="n">hamiltonian</span> <span class="o">@</span> <span class="n">final_state</span><span class="p">))</span>


<span class="n">result</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
    <span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">to_parameters</span><span class="p">(),</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of parameters: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Number of parameters: 72
  message: STOP: TOTAL NO. of ITERATIONS REACHED LIMIT
  success: False
   status: 1
      fun: -77.50963633422053
        x: [-1.479e-01  1.876e-01 ...  3.857e-03  6.460e-01]
      nit: 5
      jac: [ 1.356e-03 -2.153e-03 ... -5.357e-04 -3.396e-04]
     nfev: 584
     njev: 8
 hess_inv: &lt;72x72 LbfgsInvHessProduct with dtype=float64&gt;
</pre></div></div>
</div>
</section>
<section id="id1">
<h2>The local unitary cluster Jastrow (LUCJ) ansatz<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h2>
<p>Implementing the <span class="math notranslate nohighlight">\(e^{i \mathcal{J}_k}\)</span> term of the UCJ ansatz requires either all-to-all connectivity or the use of a fermionic swap network, making it challenging for noisy pre-fault-tolerant quantum processors that have limited connectivity. The idea of the <em>local</em> UCJ ansatz is to impose sparsity constraints on the <span class="math notranslate nohighlight">\(\mathbf{J}^{\alpha\alpha}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{J}^{\alpha\beta}\)</span> matrices which allow them to be implemented in constant depth on qubit topologies with limited
connectivity. The constraints are specified by a list of indices indicating which matrix entries in the upper triangle are allowed to be nonzero (since the matrices are symmetric, only the upper triangle needs to be specified).</p>
<p>As an example, consider a square lattice qubit topology. We can place the <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> orbitals in parallel lines on the lattice, with connections between these lines forming “rungs” of a ladder shape. With this setup, orbitals with the same spin are connected with a line topology, while orbitals with different spins are connected when they share the same spatial orbital. This yields the following index constraints on the <span class="math notranslate nohighlight">\(\mathbf{J}\)</span> matrices:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\mathbf{J}^{\alpha\alpha} &amp;: \set{(p, p+1) \; , \; p = 0, \ldots, N-2} \\
\mathbf{J}^{\alpha\beta} &amp;: \set{(p, p) \;, \; p = 0, \ldots, N-1}
\end{align*}\end{split}\]</div>
<p>In other words, if the <span class="math notranslate nohighlight">\(\mathbf{J}\)</span> matrices are nonzero only at the specified indices in the upper triangle, then the <span class="math notranslate nohighlight">\(e^{i \mathcal{J}_k}\)</span> term can be implemented on a square topology without using any swap gates, in constant depth. Of course, imposing such constraints on the ansatz makes it less expressive, so more ansatz repetitions may be required.</p>
<p>In the following code cell, we demonstrate the optimization of the ansatz with these constraints imposed. We still choose to use 2 repetitions, so notice that the number of parameters in the optimization has decreased from 72 to 46.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_alpha_indices</span> <span class="o">=</span> <span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">norb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
<span class="n">alpha_beta_indices</span> <span class="o">=</span> <span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">norb</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">operator</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">UCJOperator</span><span class="o">.</span><span class="n">from_parameters</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
        <span class="n">n_reps</span><span class="o">=</span><span class="n">n_reps</span><span class="p">,</span>
        <span class="n">alpha_alpha_indices</span><span class="o">=</span><span class="n">alpha_alpha_indices</span><span class="p">,</span>
        <span class="n">alpha_beta_indices</span><span class="o">=</span><span class="n">alpha_beta_indices</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">final_state</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">apply_unitary</span><span class="p">(</span><span class="n">reference_state</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">final_state</span><span class="p">,</span> <span class="n">hamiltonian</span> <span class="o">@</span> <span class="n">final_state</span><span class="p">))</span>


<span class="n">result</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
    <span class="n">fun</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">to_parameters</span><span class="p">(</span>
        <span class="n">alpha_alpha_indices</span><span class="o">=</span><span class="n">alpha_alpha_indices</span><span class="p">,</span> <span class="n">alpha_beta_indices</span><span class="o">=</span><span class="n">alpha_beta_indices</span>
    <span class="p">),</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">,</span>
    <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of parameters: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Number of parameters: 46
  message: STOP: TOTAL NO. of ITERATIONS REACHED LIMIT
  success: False
   status: 1
      fun: -77.45739585599905
        x: [-4.075e-01  8.222e-02 ... -1.800e-02  7.031e-01]
      nit: 5
      jac: [ 1.931e-03 -9.948e-06 ...  7.674e-05 -6.253e-05]
     nfev: 423
     njev: 9
 hess_inv: &lt;46x46 LbfgsInvHessProduct with dtype=float64&gt;
</pre></div></div>
</div>
</section>
<section id="Optimize-with-the-linear-method">
<h2>Optimize with the linear method<a class="headerlink" href="#Optimize-with-the-linear-method" title="Link to this heading">¶</a></h2>
<p>ffsim includes an implementation of the <a class="reference external" href="https://arxiv.org/abs/1412.0490v2">“linear method”</a> for optimization of a variational wavefunction. The linear method often converges faster than a standard optimization algorithm like L-BFGS-B. The interface is similar to that of <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code>, the main difference being that instead of passing a callable that directly returns the function value to be optimized, you pass two objects: a callable that returns the wavefunction, and the
Hamiltonian representing the energy to be optimized as a <code class="docutils literal notranslate"><span class="pre">LinearOperator</span></code>. The code cell below shows how to use the linear method to optimize the LUCJ ansatz from the previous example. It also shows how you can use an optional callback function to save intermediate results of the optimization.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">ffsim.optimize</span> <span class="kn">import</span> <span class="n">minimize_linear_method</span>


<span class="c1"># Define function that converts a list of parameters to the corresponding state vector</span>
<span class="k">def</span> <span class="nf">params_to_vec</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">operator</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">UCJOperator</span><span class="o">.</span><span class="n">from_parameters</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
        <span class="n">n_reps</span><span class="o">=</span><span class="n">n_reps</span><span class="p">,</span>
        <span class="n">alpha_alpha_indices</span><span class="o">=</span><span class="n">alpha_alpha_indices</span><span class="p">,</span>
        <span class="n">alpha_beta_indices</span><span class="o">=</span><span class="n">alpha_beta_indices</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">apply_unitary</span><span class="p">(</span><span class="n">reference_state</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">)</span>


<span class="c1"># Define a callback function used to save optimization information (this is optional)</span>
<span class="n">info</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">intermediate_result</span><span class="p">:</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">OptimizeResult</span><span class="p">):</span>
    <span class="c1"># The callback function is called after each iteration. It accepts</span>
    <span class="c1"># an OptimizeResult object storing the parameters and function value at</span>
    <span class="c1"># the current iteration, and possibly other information</span>
    <span class="n">info</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intermediate_result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="n">info</span><span class="p">[</span><span class="s2">&quot;fun&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intermediate_result</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">intermediate_result</span><span class="p">,</span> <span class="s2">&quot;jac&quot;</span><span class="p">):</span>
        <span class="n">info</span><span class="p">[</span><span class="s2">&quot;jac&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intermediate_result</span><span class="o">.</span><span class="n">jac</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">intermediate_result</span><span class="p">,</span> <span class="s2">&quot;regularization&quot;</span><span class="p">):</span>
        <span class="n">info</span><span class="p">[</span><span class="s2">&quot;regularization&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intermediate_result</span><span class="o">.</span><span class="n">regularization</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">intermediate_result</span><span class="p">,</span> <span class="s2">&quot;variation&quot;</span><span class="p">):</span>
        <span class="n">info</span><span class="p">[</span><span class="s2">&quot;variation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intermediate_result</span><span class="o">.</span><span class="n">variation</span><span class="p">)</span>


<span class="c1"># Optimize with the linear method</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">minimize_linear_method</span><span class="p">(</span>
    <span class="n">params_to_vec</span><span class="p">,</span>
    <span class="n">hamiltonian</span><span class="p">,</span>
    <span class="n">x0</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">to_parameters</span><span class="p">(</span>
        <span class="n">alpha_alpha_indices</span><span class="o">=</span><span class="n">alpha_alpha_indices</span><span class="p">,</span> <span class="n">alpha_beta_indices</span><span class="o">=</span><span class="n">alpha_beta_indices</span>
    <span class="p">),</span>
    <span class="n">maxiter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Print some information</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of parameters: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">variation</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
    <span class="nb">zip</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;fun&quot;</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;jac&quot;</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;regularization&quot;</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;variation&quot;</span><span class="p">])</span>
<span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Energy: </span><span class="si">{</span><span class="n">fun</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Norm of gradient: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">jac</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Regularization hyperparameter: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">regularization</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Variation hyperparameter: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">variation</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Number of parameters: 46
 message: Stop: Total number of iterations reached limit.
 success: False
     fun: -77.47667783541388
       x: [-7.491e-01  1.453e-01 ...  2.107e-01  5.169e-01]
     nit: 5
     jac: [ 4.427e-03 -9.903e-04 ... -1.487e-03 -1.489e-03]
    nfev: 661
    njev: 5
  nlinop: 431

Iteration 1
    Energy: -77.4561701441159
    Norm of gradient: 0.0201776291541262
    Regularization hyperparameter: 0.001719528573630754
    Variation hyperparameter: 0.23868386750748632
Iteration 2
    Energy: -77.45818363320642
    Norm of gradient: 0.01619548822635587
    Regularization hyperparameter: 0.00227453243674183
    Variation hyperparameter: 0.23883654754610817
Iteration 3
    Energy: -77.45824908219925
    Norm of gradient: 0.015677844118672755
    Regularization hyperparameter: 1.097114349737493
    Variation hyperparameter: 0.23457282850030187
Iteration 4
    Energy: -77.46309832209784
    Norm of gradient: 0.02884935925397444
    Regularization hyperparameter: 0.004763428680783942
    Variation hyperparameter: 0.25449126091856855
</pre></div></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">ffsim</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="01-introduction.html">Introduction to ffsim</a></li>
<li class="toctree-l1"><a class="reference internal" href="02-orbital-rotation.html">Orbital rotations and quadratic Hamiltonians</a></li>
<li class="toctree-l1"><a class="reference internal" href="03-double-factorized.html">Diagonal Coulomb operators and double-factorized Trotter simulation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The local unitary cluster Jastrow (LUCJ) ansatz</a></li>
<li class="toctree-l1"><a class="reference internal" href="05-entanglement-forging.html">Entanglement forging</a></li>
<li class="toctree-l1"><a class="reference internal" href="06-fermion-operator.html">The FermionOperator class</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/ffsim.html">ffsim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/ffsim.contract.html">ffsim.contract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/ffsim.linalg.html">ffsim.linalg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/ffsim.optimize.html">ffsim.optimize</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/ffsim.random.html">ffsim.random</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/ffsim.testing.html">ffsim.testing</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="03-double-factorized.html" title="previous chapter">Diagonal Coulomb operators and double-factorized Trotter simulation</a></li>
      <li>Next: <a href="05-entanglement-forging.html" title="next chapter">Entanglement forging</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, IBM.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../_sources/tutorials/04-lucj.ipynb.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>