<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Diagonal Coulomb operators and double-factorized Trotter simulation &#8212; ffsim 0.0.4 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=039e1c02" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css" />
    <script src="../_static/documentation_options.js?v=8c5712d9"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The local unitary cluster Jastrow (LUCJ) ansatz" href="04-LUCJ.html" />
    <link rel="prev" title="Orbital rotations and quadratic Hamiltonians" href="02-orbital-rotation.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="Diagonal-Coulomb-operators-and-double-factorized-Trotter-simulation">
<h1>Diagonal Coulomb operators and double-factorized Trotter simulation<a class="headerlink" href="#Diagonal-Coulomb-operators-and-double-factorized-Trotter-simulation" title="Link to this heading">¶</a></h1>
<p>In this tutorial, we show how to use ffsim to simulate diagonal Coulomb operators and approximate time evolution by a molecular Hamiltonian in the double-factorized representation.</p>
<section id="Double-factorized-representation-of-the-molecular-Hamiltonian">
<h2>Double-factorized representation of the molecular Hamiltonian<a class="headerlink" href="#Double-factorized-representation-of-the-molecular-Hamiltonian" title="Link to this heading">¶</a></h2>
<p>The molecular Hamiltonian is</p>
<div class="math notranslate nohighlight">
\[H = \sum_{pq, \sigma} h_{pq} a^\dagger_{p, \sigma} a_{q, \sigma}
    + \frac12 \sum_{pqrs, \sigma \tau} h_{pqrs}
    a^\dagger_{p, \sigma} a^\dagger_{r, \tau} a_{s, \tau} a_{q, \sigma}
    + \text{constant}.\]</div>
<p>This representation of the Hamiltonian is daunting for quantum simulations because the number of terms scales as <span class="math notranslate nohighlight">\(N^4\)</span> where <span class="math notranslate nohighlight">\(N\)</span> is the number of spatial orbitals. An alternative representation can be obtained by performing a “double-factorization” of the two-body tensor <span class="math notranslate nohighlight">\(h_{pqrs}\)</span>:</p>
<div class="math notranslate nohighlight">
\[H = \sum_{pq, \sigma} h'_{pq} a^\dagger_{p, \sigma} a_{q, \sigma}
+ \sum_{k=1}^L \mathcal{W}_k \mathcal{J}_k \mathcal{W}_k^\dagger
+ \text{constant}'.\]</div>
<p>Here each <span class="math notranslate nohighlight">\(\mathcal{W}_k\)</span> is an <a class="reference internal" href="02-orbital-rotation.html"><span class="doc">orbital rotation</span></a> and each <span class="math notranslate nohighlight">\(\mathcal{J}_k\)</span> is a so-called diagonal Coulomb operator, which is an operator of the form</p>
<div class="math notranslate nohighlight">
\[\mathcal{J} = \frac12\sum_{ij,\sigma \tau} \mathbf{J}_{ij} n_{i,\sigma} n_{j,\tau},\]</div>
<p>where <span class="math notranslate nohighlight">\(n_{i, \sigma} = a^\dagger_{i,\sigma} a_{i,\sigma}\)</span> is the occupation number operator and <span class="math notranslate nohighlight">\(\mathbf{J}_{ij}\)</span> is a real symmetric matrix.</p>
<p>In the cell below, we construct the Hamiltonian for a hydrogen molecule at a stretched bond length and then get the double-factorized representation of the Hamiltonian.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyscf</span>
<span class="kn">import</span> <span class="nn">ffsim</span>

<span class="c1"># Build an H2 molecule</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">pyscf</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span>
    <span class="n">atom</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">)]],</span>
    <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;sto-6g&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">hartree_fock</span> <span class="o">=</span> <span class="n">pyscf</span><span class="o">.</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">hartree_fock</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1"># Get molecular data and molecular Hamiltonian (one- and two-body tensors)</span>
<span class="n">mol_data</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">MolecularData</span><span class="o">.</span><span class="n">from_hartree_fock</span><span class="p">(</span><span class="n">hartree_fock</span><span class="p">)</span>
<span class="n">norb</span> <span class="o">=</span> <span class="n">mol_data</span><span class="o">.</span><span class="n">norb</span>
<span class="n">nelec</span> <span class="o">=</span> <span class="n">mol_data</span><span class="o">.</span><span class="n">nelec</span>
<span class="n">mol_hamiltonian</span> <span class="o">=</span> <span class="n">mol_data</span><span class="o">.</span><span class="n">hamiltonian</span>

<span class="c1"># Get the Hamiltonian in the double-factorized representation</span>
<span class="n">df_hamiltonian</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">double_factorized_hamiltonian</span><span class="p">(</span><span class="n">mol_hamiltonian</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
converged SCF energy = -0.837796382593709
</pre></div></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">double_factorized_hamiltonian</span></code> returns an object of type <code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code> which is just a dataclass that stores the updated one-body-tensor, diagonal Coulomb matrices, and orbital rotations. In the cell below, we print out the tensors describing the original and double-factorized representations.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Print some information</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Original representation&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-----------------------&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;One-body tensor:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mol_hamiltonian</span><span class="o">.</span><span class="n">one_body_tensor</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Two-body tensor:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mol_hamiltonian</span><span class="o">.</span><span class="n">two_body_tensor</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Double-factorized representation&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--------------------------------&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;One-body tensor:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df_hamiltonian</span><span class="o">.</span><span class="n">one_body_tensor</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Diagonal Coulomb matrices:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df_hamiltonian</span><span class="o">.</span><span class="n">diag_coulomb_mats</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Orbital rotations:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df_hamiltonian</span><span class="o">.</span><span class="n">orbital_rotations</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Original representation
-----------------------
One-body tensor:
[[-8.27478830e-01 -2.66405155e-16]
 [-3.07220771e-16 -6.77238770e-01]]

Two-body tensor:
[[[[5.23173938e-01 1.57437591e-16]
   [1.57437591e-16 5.33545754e-01]]

  [[2.12704463e-16 2.48240570e-01]
   [2.48240570e-01 1.61492903e-16]]]


 [[[2.12704463e-16 2.48240570e-01]
   [2.48240570e-01 1.61492903e-16]]

  [[5.33545754e-01 1.24884750e-16]
   [1.24884750e-16 5.53132024e-01]]]]

Double-factorized representation
--------------------------------
One-body tensor:
[[-1.21318608e+00 -4.25870402e-16]
 [-4.76015378e-16 -1.07792507e+00]]

Diagonal Coulomb matrices:
[[[ 5.14653029e-01  5.33545754e-01]
  [ 5.33545754e-01  5.53132024e-01]]

 [[ 2.48240570e-01 -2.48240570e-01]
  [-2.48240570e-01  2.48240570e-01]]

 [[ 1.50800163e-59 -3.58462611e-31]
  [-3.58462611e-31  8.52090881e-03]]]

Orbital rotations:
[[[-1.00000000e+00  8.24520980e-15]
  [ 8.24520980e-15  1.00000000e+00]]

 [[-7.07106781e-01 -7.07106781e-01]
  [ 7.07106781e-01 -7.07106781e-01]]

 [[ 6.48603030e-15 -1.00000000e+00]
  [-1.00000000e+00 -6.48603030e-15]]]
</pre></div></div>
</div>
</section>
<section id="Trotter-simulation-of-the-double-factorized-Hamiltonian">
<h2>Trotter simulation of the double-factorized Hamiltonian<a class="headerlink" href="#Trotter-simulation-of-the-double-factorized-Hamiltonian" title="Link to this heading">¶</a></h2>
<p>In the rest of this tutorial, we’ll show how to use ffsim to implement time evolution of the double-factorized Hamiltonian via Trotter-Suzuki formulas. Although ffsim already has this functionality built-in, we will first manually implement a first-order asymmetric product formula to demonstrate the use of ffsim’s basic operations.</p>
<section id="Brief-background-on-Trotter-Suzuki-formulas">
<h3>Brief background on Trotter-Suzuki formulas<a class="headerlink" href="#Brief-background-on-Trotter-Suzuki-formulas" title="Link to this heading">¶</a></h3>
<p>Trotter-Suzuki formulas are used to approximate time evolution by a Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> which is decomposed as a sum of terms:</p>
<div class="math notranslate nohighlight">
\[H = \sum_k H_k.\]</div>
<p>Time evolution by time <span class="math notranslate nohighlight">\(t\)</span> is given by the unitary operator</p>
<div class="math notranslate nohighlight">
\[e^{i H t}.\]</div>
<p>To approximate this operator, the total evolution time is first divided into a number of smaller time steps, called “Trotter steps”:</p>
<div class="math notranslate nohighlight">
\[e^{i H t} = (e^{i H t / r})^r.\]</div>
<p>The time evolution for a single Trotter step is then approximated using a product formula, which approximates the exponential of a sum of terms by a product of exponentials of the individual terms. The formulas are approximate because the terms do not in general commute. A first-order asymmetric product formula has the form</p>
<div class="math notranslate nohighlight">
\[e^{i H \tau} \approx \prod_k e^{i H_k \tau}.\]</div>
<p>Higher-order formulas can be derived which yield better approximations.</p>
</section>
<section id="Implementing-Trotter-simulation-of-the-double-factorized-Hamiltonian">
<h3>Implementing Trotter simulation of the double-factorized Hamiltonian<a class="headerlink" href="#Implementing-Trotter-simulation-of-the-double-factorized-Hamiltonian" title="Link to this heading">¶</a></h3>
<p>First, we’ll write a function to simulate a single Trotter step of the Hamiltonian. Recall the form of the Hamiltonian (ignoring the additive constant):</p>
<div class="math notranslate nohighlight">
\[H = \sum_{pq, \sigma} h'_{pq} a^\dagger_{p, \sigma} a_{q, \sigma}
+ \sum_{k=1}^L \mathcal{W}_k \mathcal{J}_k \mathcal{W}_k^\dagger\]</div>
<p>We think of this Hamiltonian as composed of <span class="math notranslate nohighlight">\(L + 1\)</span> terms: the one-body term, which is a quadratic Hamiltonian, and the <span class="math notranslate nohighlight">\(L\)</span> “rotated diagonal Coulomb operators.” As described in <a class="reference internal" href="02-orbital-rotation.html"><span class="doc">this tutorial</span></a>, time evolution by the quadratic Hamiltonian can be implemented using the <code class="docutils literal notranslate"><span class="pre">apply_num_op_sum_evolution</span></code> function. Similarly, time evolution by a rotated diagonal coulomb operator can be implemented using the <code class="docutils literal notranslate"><span class="pre">apply_diag_coulomb_evolution</span></code> function.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="k">def</span> <span class="nf">simulate_trotter_step_double_factorized</span><span class="p">(</span>
    <span class="n">vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">hamiltonian</span><span class="p">:</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">DoubleFactorizedHamiltonian</span><span class="p">,</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">norb</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">nelec</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="c1"># Diagonalize the one-body term</span>
    <span class="n">one_body_energies</span><span class="p">,</span> <span class="n">one_body_basis_change</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span>
        <span class="n">hamiltonian</span><span class="o">.</span><span class="n">one_body_tensor</span>
    <span class="p">)</span>
    <span class="c1"># Simulate the one-body term</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">apply_num_op_sum_evolution</span><span class="p">(</span>
        <span class="n">vec</span><span class="p">,</span>
        <span class="n">one_body_energies</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
        <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">,</span>
        <span class="n">orbital_rotation</span><span class="o">=</span><span class="n">one_body_basis_change</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Simulate the two-body terms</span>
    <span class="k">for</span> <span class="n">diag_coulomb_mat</span><span class="p">,</span> <span class="n">orbital_rotation</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">hamiltonian</span><span class="o">.</span><span class="n">diag_coulomb_mats</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="o">.</span><span class="n">orbital_rotations</span>
    <span class="p">):</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">apply_diag_coulomb_evolution</span><span class="p">(</span>
            <span class="n">vec</span><span class="p">,</span>
            <span class="n">diag_coulomb_mat</span><span class="p">,</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
            <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">,</span>
            <span class="n">orbital_rotation</span><span class="o">=</span><span class="n">orbital_rotation</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">vec</span>
</pre></div>
</div>
</div>
<p>We finish by writing a higher-level function that handles splitting the total time evolution into multiple Trotter steps, simulating each Trotter step using the function we just wrote.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">simulate_trotter_double_factorized</span><span class="p">(</span>
    <span class="n">vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">hamiltonian</span><span class="p">:</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">DoubleFactorizedHamiltonian</span><span class="p">,</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">norb</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">nelec</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">n_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">step_time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">/</span> <span class="n">n_steps</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">):</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">simulate_trotter_step_double_factorized</span><span class="p">(</span>
            <span class="n">vec</span><span class="p">,</span>
            <span class="n">hamiltonian</span><span class="p">,</span>
            <span class="n">step_time</span><span class="p">,</span>
            <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
            <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">vec</span>
</pre></div>
</div>
</div>
<p>To test our implementation, we’ll apply the time evolution to the Hartree-Fock state, which is a Slater determinant with electrons occupying the lowest-energy molecular orbitals. In the following code cell, we’ll create this state and calculate its energy. It should match the value output by pySCF when we first created the molecule. To calculate the energy, we convert the Hamiltonian to a SciPy <code class="docutils literal notranslate"><span class="pre">LinearOperator</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Construct the Hartree-Fock state</span>
<span class="n">n_alpha</span><span class="p">,</span> <span class="n">n_beta</span> <span class="o">=</span> <span class="n">nelec</span>
<span class="n">initial_state</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">slater_determinant</span><span class="p">(</span>
    <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span> <span class="n">occupied_orbitals</span><span class="o">=</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_alpha</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_beta</span><span class="p">))</span>
<span class="p">)</span>

<span class="c1"># Get the Hamiltonian as a LinearOperator</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">linear_operator</span><span class="p">(</span><span class="n">mol_hamiltonian</span><span class="p">,</span> <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">)</span>

<span class="c1"># Check the energy ⟨ψ|H|ψ⟩ of the Hartree-Fock state</span>
<span class="n">hf_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">hamiltonian</span> <span class="o">@</span> <span class="n">initial_state</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hartree Fock energy: </span><span class="si">{</span><span class="n">hf_energy</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Hartree Fock energy: -0.8377963825937088
</pre></div></div>
</div>
<p>Now, we set the evolution time and calculate the exact result of time evolution by directly exponentiating the Hamiltonian using SciPy. Later, we will compare the result of our approximate time evolution with this exact result.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span>

<span class="n">time</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">exact_state</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm_multiply</span><span class="p">(</span>
    <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">time</span> <span class="o">*</span> <span class="n">hamiltonian</span><span class="p">,</span>
    <span class="n">initial_state</span><span class="p">,</span>
    <span class="n">traceA</span><span class="o">=</span><span class="n">ffsim</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">mol_hamiltonian</span><span class="p">,</span> <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">),</span>
<span class="p">)</span>

<span class="n">fidelity</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">exact_state</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fidelity of evolved state w.r.t. initial state: </span><span class="si">{</span><span class="n">fidelity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Fidelity of evolved state w.r.t. initial state: 0.9696296369955066
</pre></div></div>
</div>
<p>Now, let’s test our implementation.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">final_state</span> <span class="o">=</span> <span class="n">simulate_trotter_double_factorized</span><span class="p">(</span>
    <span class="n">initial_state</span><span class="p">,</span>
    <span class="n">df_hamiltonian</span><span class="p">,</span>
    <span class="n">time</span><span class="p">,</span>
    <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
    <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">,</span>
    <span class="n">n_steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">fidelity</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">final_state</span><span class="p">,</span> <span class="n">exact_state</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fidelity of Trotter-evolved state with exact state: </span><span class="si">{</span><span class="n">fidelity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Fidelity of Trotter-evolved state with exact state: 0.999027574408349
</pre></div></div>
</div>
<p>The fidelity of the final result can be improved by increasing the number of Trotter steps.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">final_state</span> <span class="o">=</span> <span class="n">simulate_trotter_double_factorized</span><span class="p">(</span>
    <span class="n">initial_state</span><span class="p">,</span>
    <span class="n">df_hamiltonian</span><span class="p">,</span>
    <span class="n">time</span><span class="p">,</span>
    <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
    <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">,</span>
    <span class="n">n_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">fidelity</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">final_state</span><span class="p">,</span> <span class="n">exact_state</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fidelity of Trotter-evolved state with exact state: </span><span class="si">{</span><span class="n">fidelity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Fidelity of Trotter-evolved state with exact state: 0.9999906233109657
</pre></div></div>
</div>
<p>As mentioned above, ffsim already includes functionality for Trotter simulation of double-factorized Hamiltonians. The implementation in ffsim includes higher-order Trotter-Suzuki formulas. The first-order asymmetric formula that we just implemented corresponds to <code class="docutils literal notranslate"><span class="pre">order=0</span></code> in ffsim’s implementation. <code class="docutils literal notranslate"><span class="pre">order=1</span></code> corresponds to the first-order symmetric (commonly known as the second-order) formula, <code class="docutils literal notranslate"><span class="pre">order=2</span></code> corresponds to the second-order symmetric (fourth-order) formula, and so on.</p>
<p>In the code cell below, we reproduce the results of our manually implemented function using ffsim’s built-in implementation.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">final_state</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">simulate_trotter_double_factorized</span><span class="p">(</span>
    <span class="n">initial_state</span><span class="p">,</span>
    <span class="n">df_hamiltonian</span><span class="p">,</span>
    <span class="n">time</span><span class="p">,</span>
    <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
    <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">,</span>
    <span class="n">n_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">fidelity</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">final_state</span><span class="p">,</span> <span class="n">exact_state</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fidelity of Trotter-evolved state with exact state: </span><span class="si">{</span><span class="n">fidelity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Fidelity of Trotter-evolved state with exact state: 0.9999906233109657
</pre></div></div>
</div>
<p>A higher order formula achieves a higher fidelity with fewer Trotter steps:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">final_state</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">simulate_trotter_double_factorized</span><span class="p">(</span>
    <span class="n">initial_state</span><span class="p">,</span>
    <span class="n">df_hamiltonian</span><span class="p">,</span>
    <span class="n">time</span><span class="p">,</span>
    <span class="n">norb</span><span class="o">=</span><span class="n">norb</span><span class="p">,</span>
    <span class="n">nelec</span><span class="o">=</span><span class="n">nelec</span><span class="p">,</span>
    <span class="n">n_steps</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">fidelity</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">final_state</span><span class="p">,</span> <span class="n">exact_state</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fidelity of Trotter-evolved state with exact state: </span><span class="si">{</span><span class="n">fidelity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Fidelity of Trotter-evolved state with exact state: 0.9999999336740057
</pre></div></div>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">ffsim</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Tutorials</a><ul>
      <li>Previous: <a href="02-orbital-rotation.html" title="previous chapter">Orbital rotations and quadratic Hamiltonians</a></li>
      <li>Next: <a href="04-LUCJ.html" title="next chapter">The local unitary cluster Jastrow (LUCJ) ansatz</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, IBM.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../_sources/notebooks/03-double-factorized.ipynb.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>