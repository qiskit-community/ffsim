<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>ffsim.linalg package &#8212; ffsim 0.0.4 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />
    <script src="../../_static/documentation_options.js?v=8c5712d9"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="ffsim.protocols package" href="ffsim.protocols.html" />
    <link rel="prev" title="ffsim.hamiltonians package" href="ffsim.hamiltonians.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="ffsim-linalg-package">
<h1>ffsim.linalg package<a class="headerlink" href="#ffsim-linalg-package" title="Link to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">¶</a></h2>
</section>
<section id="module-ffsim.linalg.double_factorized">
<span id="ffsim-linalg-double-factorized-module"></span><h2>ffsim.linalg.double_factorized module<a class="headerlink" href="#module-ffsim.linalg.double_factorized" title="Link to this heading">¶</a></h2>
<p>Utilities for performing the double-factorized decomposition.</p>
<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.double_factorized.double_factorized">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.double_factorized.</span></span><span class="sig-name descname"><span class="pre">double_factorized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_body_tensor</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_vecs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag_coulomb_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cholesky</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/double_factorized.html#double_factorized"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.double_factorized.double_factorized" title="Link to this definition">¶</a></dt>
<dd><p>Double-factorized decomposition of a two-body tensor.</p>
<p>The double-factorized decomposition is a representation of a two-body tensor
<span class="math notranslate nohighlight">\(h_{pqrs}\)</span> as</p>
<div class="math notranslate nohighlight">
\[h_{pqrs} = \sum_{t=1}^L \sum_{k\ell} Z^{t}_{k\ell} U^{t}_{pk} U^{t}_{qk}
    U^{t}_{r\ell} U^{t}_{s\ell}\]</div>
<p>Here each <span class="math notranslate nohighlight">\(Z^{(t)}\)</span> is a real symmetric matrix, referred to as a
“diagonal Coulomb matrix,” and each <span class="math notranslate nohighlight">\(U^{t}\)</span> is a unitary matrix, referred to
as an “orbital rotation.”</p>
<p>The number of terms <span class="math notranslate nohighlight">\(L\)</span> in the decomposition depends on the allowed
error threshold. A larger error threshold may yield a smaller number of terms.
Furthermore, the <code class="docutils literal notranslate"><span class="pre">max_vecs</span></code> parameter specifies an optional upper bound
on <span class="math notranslate nohighlight">\(L\)</span>. The <code class="docutils literal notranslate"><span class="pre">max_vecs</span></code> parameter is always respected, so if it is
too small, then the error of the decomposition may exceed the specified
error threshold.</p>
<p>The default behavior of this routine is to perform a straightforward
“exact” factorization of the two-body tensor based on a nested
eigenvalue decomposition. Additionally, one can choose to optimize the
coefficients stored in the tensor to achieve a “compressed” factorization.
This option is enabled by setting the <cite>optimize</cite> parameter to <cite>True</cite>.
The optimization attempts to minimize a least-squares objective function
quantifying the error in the low rank decomposition.
It uses <cite>scipy.optimize.minimize</cite>, passing both the objective function
and its gradient. The core tensors returned by the optimization can be optionally
constrained to have only certain elements allowed to be nonzero. This is achieved by
passing the <cite>diag_coulomb_mask</cite> parameter, which is an <span class="math notranslate nohighlight">\(N \times N\)</span> matrix of
boolean values where <span class="math notranslate nohighlight">\(N\)</span> is the number of orbitals. The nonzero elements of
this matrix indicate where the core tensors are allowed to be nonzero. Only the
upper triangular part of the matrix is used because the core tensors are symmetric.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://arxiv.org/abs/1808.02625">arXiv:1808.02625</a></p></li>
<li><p><a class="reference external" href="https://arxiv.org/abs/2104.08957">arXiv:2104.08957</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>two_body_tensor</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The two-body tensor to decompose.</p></li>
<li><p><strong>tol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Tolerance for error in the decomposition.
The error is defined as the maximum absolute difference between
an element of the original tensor and the corresponding element of
the reconstructed tensor.</p></li>
<li><p><strong>max_vecs</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – An optional limit on the number of terms to keep in the decomposition
of the two-body tensor. This argument overrides <code class="docutils literal notranslate"><span class="pre">tol</span></code>.</p></li>
<li><p><strong>optimize</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether to optimize the tensors returned by the decomposition.</p></li>
<li><p><strong>method</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The optimization method. See the documentation of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a> for possible values.</p></li>
<li><p><strong>callback</strong> – Callback function for the optimization. See the documentation of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a> for usage.</p></li>
<li><p><strong>options</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>]) – Options for the optimization. See the documentation of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a> for usage.</p></li>
<li><p><strong>diag_coulomb_mask</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]) – Diagonal Coulomb matrix mask to use in the optimization.
This is a matrix of boolean values where the nonzero elements indicate where
the diagonal coulomb matrices returned by optimization are allowed to be
nonzero. This parameter is only used if <cite>optimize</cite> is set to <cite>True</cite>, and
only the upper triangular part of the matrix is used.</p></li>
<li><p><strong>cholesky</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether to perform the factorization using a modified Cholesky
decomposition. If False, a full eigenvalue decomposition is used instead,
which can be much more expensive. This argument is ignored if <code class="docutils literal notranslate"><span class="pre">optimize</span></code>
is set to True.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The diagonal Coulomb matrices and the orbital rotations. Each list of matrices
is collected into a Numpy array, so this method returns a tuple of two Numpy
arrays, the first containing the diagonal Coulomb matrices and the second
containing the orbital rotations. Each Numpy array will have shape (L, n, n)
where L is the rank of the decomposition and n is the number of orbitals.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.double_factorized.double_factorized_t2">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.double_factorized.</span></span><span class="sig-name descname"><span class="pre">double_factorized_t2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t2_amplitudes</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_vecs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/double_factorized.html#double_factorized_t2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.double_factorized.double_factorized_t2" title="Link to this definition">¶</a></dt>
<dd><p>Double-factorized decomposition of t2 amplitudes.</p>
<p>The double-factorized decomposition of a t2 amplitudes tensor <span class="math notranslate nohighlight">\(t_{ijab}\)</span> is</p>
<div class="math notranslate nohighlight">
\[t_{ijab} = i \sum_{k=1}^L \sum_{pq} (
    Z^{k}_{pq} U^{k}_{ap} {U^{k}}^*_{ip} U^{k}_{bq} {U^{k}}^*_{jq}
    - Z^{k}_{pq} {U^{k}}^*_{ap} U^{k}_{ip} {U^{k}}^*_{bq} U^{k}_{jq})\]</div>
<p>Here each <span class="math notranslate nohighlight">\(Z^{(k)}\)</span> is a real symmetric matrix, referred to as a
“diagonal Coulomb matrix,” and each <span class="math notranslate nohighlight">\(U^{k}\)</span> is a unitary matrix, referred to
as an “orbital rotation.”</p>
<p>The number of terms <span class="math notranslate nohighlight">\(L\)</span> in the decomposition depends on the allowed
error threshold. A larger error threshold may yield a smaller number of terms.
Furthermore, the <code class="docutils literal notranslate"><span class="pre">max_vecs</span></code> parameter specifies an optional upper bound
on <span class="math notranslate nohighlight">\(L\)</span>. The <code class="docutils literal notranslate"><span class="pre">max_vecs</span></code> parameter is always respected, so if it is
too small, then the error of the decomposition may exceed the specified
error threshold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t2_amplitudes</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The t2 amplitudes tensor.</p></li>
<li><p><strong>tol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Tolerance for error in the decomposition.
The error is defined as the maximum absolute difference between
an element of the original tensor and the corresponding element of
the reconstructed tensor.</p></li>
<li><p><strong>max_vecs</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – An optional limit on the number of terms to keep in the decomposition
of the t2 amplitudes tensor. This argument overrides <code class="docutils literal notranslate"><span class="pre">tol</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The diagonal Coulomb matrices and the orbital rotations. Each list of matrices
is collected into a Numpy array, so this method returns a tuple of two Numpy
arrays, the first containing the diagonal Coulomb matrices and the second
containing the orbital rotations. Each Numpy array will have shape (L, n, n)
where L is the rank of the decomposition and n is the number of orbitals.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.double_factorized.modified_cholesky">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.double_factorized.</span></span><span class="sig-name descname"><span class="pre">modified_cholesky</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_vecs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/double_factorized.html#modified_cholesky"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.double_factorized.modified_cholesky" title="Link to this definition">¶</a></dt>
<dd><p>Modified Cholesky decomposition.</p>
<p>The modified Cholesky decomposition of a square matrix <span class="math notranslate nohighlight">\(M\)</span> has the form</p>
<div class="math notranslate nohighlight">
\[M = \sum_{i=1}^N v_i v_i^\dagger\]</div>
<p>where each <span class="math notranslate nohighlight">\(v_i\)</span> is a vector. <cite>M</cite> must be positive definite.
No checking is performed to verify whether <cite>M</cite> is positive definite.
The number of terms <span class="math notranslate nohighlight">\(N\)</span> in the decomposition depends on the allowed
error threshold. A larger error threshold may yield a smaller number of terms.
Furthermore, the <cite>max_vecs</cite> parameter specifies an optional upper bound
on <span class="math notranslate nohighlight">\(N\)</span>. The <cite>max_vecs</cite> parameter is always respected, so if it is
too small, then the error of the decomposition may exceed the specified
error threshold.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://arxiv.org/abs/1711.02242">arXiv:1711.02242</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The matrix to decompose.</p></li>
<li><p><strong>tol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Tolerance for error in the decomposition.
The error is defined as the maximum absolute difference between
an element of the original tensor and the corresponding element of
the reconstructed tensor.</p></li>
<li><p><strong>max_vecs</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – The maximum number of vectors to include in the decomposition.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The Cholesky vectors v_i assembled into a 2-dimensional Numpy array
whose columns are the vectors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.double_factorized.optimal_diag_coulomb_mats">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.double_factorized.</span></span><span class="sig-name descname"><span class="pre">optimal_diag_coulomb_mats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/double_factorized.html#optimal_diag_coulomb_mats"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.double_factorized.optimal_diag_coulomb_mats" title="Link to this definition">¶</a></dt>
<dd><p>Compute optimal diagonal Coulomb matrices given fixed orbital rotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-ffsim.linalg.givens">
<span id="ffsim-linalg-givens-module"></span><h2>ffsim.linalg.givens module<a class="headerlink" href="#module-ffsim.linalg.givens" title="Link to this heading">¶</a></h2>
<p>Utilities for performing the Givens decomposition.</p>
<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.givens.apply_matrix_to_slices">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.givens.</span></span><span class="sig-name descname"><span class="pre">apply_matrix_to_slices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slices</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/givens.html#apply_matrix_to_slices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.givens.apply_matrix_to_slices" title="Link to this definition">¶</a></dt>
<dd><p>Apply a matrix to slices of a target tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The tensor containing the slices on which to apply the matrix.</p></li>
<li><p><strong>mat</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The matrix to apply to slices of the target tensor.</p></li>
<li><p><strong>slices</strong> – The slices of the target tensor on which to apply the matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The resulting tensor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.givens.givens_decomposition">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.givens.</span></span><span class="sig-name descname"><span class="pre">givens_decomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/givens.html#givens_decomposition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.givens.givens_decomposition" title="Link to this definition">¶</a></dt>
<dd><p>Givens rotation decomposition of a unitary matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]], <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.givens.givens_matrix">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.givens.</span></span><span class="sig-name descname"><span class="pre">givens_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/givens.html#givens_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.givens.givens_matrix" title="Link to this definition">¶</a></dt>
<dd><p>Compute the Givens rotation to zero out a row entry.</p>
<p>Returns a <span class="math notranslate nohighlight">\(2 \times 2\)</span> unitary matrix G that satisfies</p>
<div class="math notranslate nohighlight">
\[\begin{split}G
\begin{pmatrix}
    a \\
    b
\end{pmatrix}
=
\begin{pmatrix}
    r \\
    0
\end{pmatrix}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(r\)</span> is a complex number.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Givens_rotation#Stable_calculation">https://en.wikipedia.org/wiki/Givens_rotation#Stable_calculation</a></p></li>
<li><p><a class="reference external" href="https://www.netlib.org/lapack/lawnspdf/lawn148.pdf">https://www.netlib.org/lapack/lawnspdf/lawn148.pdf</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code>) – A complex number representing the first row entry</p></li>
<li><p><strong>b</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code>) – A complex number representing the second row entry</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The Givens rotation matrix.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-ffsim.linalg.linalg">
<span id="ffsim-linalg-linalg-module"></span><h2>ffsim.linalg.linalg module<a class="headerlink" href="#module-ffsim.linalg.linalg" title="Link to this heading">¶</a></h2>
<p>Linear algebra utilities.</p>
<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.linalg.expm_multiply_taylor">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.linalg.</span></span><span class="sig-name descname"><span class="pre">expm_multiply_taylor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/linalg.html#expm_multiply_taylor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.linalg.expm_multiply_taylor" title="Link to this definition">¶</a></dt>
<dd><p>Compute expm(mat) &#64; vec using a Taylor series expansion.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.linalg.lup">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.linalg.</span></span><span class="sig-name descname"><span class="pre">lup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/linalg.html#lup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.linalg.lup" title="Link to this definition">¶</a></dt>
<dd><p>Column-pivoted LU decomposition of a matrix.</p>
<p>The decomposition is:
:rtype: <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</p>
<div class="math notranslate nohighlight">
\[A = L U P\]</div>
<p>where L is a lower triangular matrix with unit diagonal elements,
U is upper triangular, and P is a permutation matrix.</p>
</dd></dl>

</section>
<section id="module-ffsim.linalg.predicates">
<span id="ffsim-linalg-predicates-module"></span><h2>ffsim.linalg.predicates module<a class="headerlink" href="#module-ffsim.linalg.predicates" title="Link to this heading">¶</a></h2>
<p>Linear algebra predicates.</p>
<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.predicates.is_antihermitian">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.predicates.</span></span><span class="sig-name descname"><span class="pre">is_antihermitian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/predicates.html#is_antihermitian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.predicates.is_antihermitian" title="Link to this definition">¶</a></dt>
<dd><p>Determine if a matrix is approximately anti-Hermitian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The matrix.</p></li>
<li><p><strong>rtol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Relative numerical tolerance.</p></li>
<li><p><strong>atol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Absolute numerical tolerance.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether the matrix is anti-Hermitian within the given tolerance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.predicates.is_hermitian">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.predicates.</span></span><span class="sig-name descname"><span class="pre">is_hermitian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/predicates.html#is_hermitian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.predicates.is_hermitian" title="Link to this definition">¶</a></dt>
<dd><p>Determine if a matrix is approximately Hermitian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The matrix.</p></li>
<li><p><strong>rtol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Relative numerical tolerance.</p></li>
<li><p><strong>atol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Absolute numerical tolerance.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether the matrix is Hermitian within the given tolerance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.predicates.is_orthogonal">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.predicates.</span></span><span class="sig-name descname"><span class="pre">is_orthogonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/predicates.html#is_orthogonal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.predicates.is_orthogonal" title="Link to this definition">¶</a></dt>
<dd><p>Determine if a matrix is approximately orthogonal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The matrix.</p></li>
<li><p><strong>rtol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Relative numerical tolerance.</p></li>
<li><p><strong>atol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Absolute numerical tolerance.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bool_</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether the matrix is orthogonal within the given tolerance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.predicates.is_real_symmetric">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.predicates.</span></span><span class="sig-name descname"><span class="pre">is_real_symmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/predicates.html#is_real_symmetric"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.predicates.is_real_symmetric" title="Link to this definition">¶</a></dt>
<dd><p>Determine if a matrix is real and approximately symmetric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The matrix.</p></li>
<li><p><strong>rtol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Relative numerical tolerance.</p></li>
<li><p><strong>atol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Absolute numerical tolerance.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bool_</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether the matrix is real and symmetric within the given tolerance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.predicates.is_special_orthogonal">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.predicates.</span></span><span class="sig-name descname"><span class="pre">is_special_orthogonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/predicates.html#is_special_orthogonal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.predicates.is_special_orthogonal" title="Link to this definition">¶</a></dt>
<dd><p>Determine if a matrix is approximately special orthogonal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The matrix.</p></li>
<li><p><strong>rtol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Relative numerical tolerance.</p></li>
<li><p><strong>atol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Absolute numerical tolerance.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bool_</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether the matrix is special orthogonal within the given tolerance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linalg.predicates.is_unitary">
<span class="sig-prename descclassname"><span class="pre">ffsim.linalg.predicates.</span></span><span class="sig-name descname"><span class="pre">is_unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/linalg/predicates.html#is_unitary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linalg.predicates.is_unitary" title="Link to this definition">¶</a></dt>
<dd><p>Determine if a matrix is approximately unitary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The matrix.</p></li>
<li><p><strong>rtol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Relative numerical tolerance.</p></li>
<li><p><strong>atol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Absolute numerical tolerance.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bool_</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether the matrix is unitary within the given tolerance.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-ffsim.linalg">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-ffsim.linalg" title="Link to this heading">¶</a></h2>
<p>Linear algebra utilities.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">ffsim</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">API reference</a><ul>
  <li><a href="modules.html">ffsim</a><ul>
  <li><a href="ffsim.html">ffsim package</a><ul>
      <li>Previous: <a href="ffsim.hamiltonians.html" title="previous chapter">ffsim.hamiltonians package</a></li>
      <li>Next: <a href="ffsim.protocols.html" title="next chapter">ffsim.protocols package</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, IBM.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/api/generated/ffsim.linalg.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>