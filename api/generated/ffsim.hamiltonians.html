<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>ffsim.hamiltonians package &#8212; ffsim 0.0.9.dev0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />
    <script src="../../_static/documentation_options.js?v=54e32373"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="ffsim.linalg package" href="ffsim.linalg.html" />
    <link rel="prev" title="ffsim.gates package" href="ffsim.gates.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="ffsim-hamiltonians-package">
<h1>ffsim.hamiltonians package<a class="headerlink" href="#ffsim-hamiltonians-package" title="Link to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">¶</a></h2>
</section>
<section id="module-ffsim.hamiltonians.double_factorized_hamiltonian">
<span id="ffsim-hamiltonians-double-factorized-hamiltonian-module"></span><h2>ffsim.hamiltonians.double_factorized_hamiltonian module<a class="headerlink" href="#module-ffsim.hamiltonians.double_factorized_hamiltonian" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.hamiltonians.double_factorized_hamiltonian.</span></span><span class="sig-name descname"><span class="pre">DoubleFactorizedHamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag_coulomb_mats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_representation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/hamiltonians/double_factorized_hamiltonian.html#DoubleFactorizedHamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A Hamiltonian in the double-factorized form of the low rank decomposition.</p>
<p>The double-factorized form of the molecular Hamiltonian is</p>
<div class="math notranslate nohighlight">
\[H = \sum_{pq, \sigma} \kappa_{pq} a^\dagger_{p, \sigma} a_{q, \sigma}
+ \frac12 \sum_t \sum_{ij, \sigma\tau}
Z^{(t)}_{ij} n^{(t)}_{i, \sigma} n^{(t)}_{j, \tau}
+ \text{constant}'.\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[n^{(t)}_{i, \sigma} = \sum_{pq} U^{(t)}_{pi}
a^\dagger_{p, \sigma} a^\dagger_{q, \sigma} U^{(t)}_{qi}.\]</div>
<p>Here each <span class="math notranslate nohighlight">\(U^{(t)}\)</span> is a unitary matrix and each <span class="math notranslate nohighlight">\(Z^{(t)}\)</span>
is a real symmetric matrix.</p>
<p><strong>“Z” representation</strong></p>
<p>The “Z” representation of the double factorization is an alternative
representation that sometimes yields simpler quantum circuits.</p>
<p>Under the Jordan-Wigner transformation, the number operators take the form</p>
<div class="math notranslate nohighlight">
\[n^{(t)}_{i, \sigma} = \frac{(1 - z^{(t)}_{i, \sigma})}{2}\]</div>
<p>where <span class="math notranslate nohighlight">\(z^{(t)}_{i, \sigma}\)</span> is the Pauli Z operator in the rotated basis.
The “Z” representation is obtained by rewriting the two-body part in terms
of these Pauli Z operators and updating the one-body term as appropriate:</p>
<div class="math notranslate nohighlight">
\[H = \sum_{pq, \sigma} \kappa'_{pq} a^\dagger_{p, \sigma} a_{q, \sigma}
+ \frac18 \sum_t \sum_{ij, \sigma\tau}^*
Z^{(t)}_{ij} z^{(t)}_{i, \sigma} z^{(t)}_{j, \tau}
+ \text{constant}''\]</div>
<p>where the asterisk denotes summation over indices <span class="math notranslate nohighlight">\(ij, \sigma\tau\)</span>
where <span class="math notranslate nohighlight">\(i \neq j\)</span> or <span class="math notranslate nohighlight">\(\sigma \neq \tau\)</span>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.one_body_tensor">
<span class="sig-name descname"><span class="pre">one_body_tensor</span></span><a class="headerlink" href="#ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.one_body_tensor" title="Link to this definition">¶</a></dt>
<dd><p>The one-body tensor <span class="math notranslate nohighlight">\(\kappa\)</span>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.diag_coulomb_mats">
<span class="sig-name descname"><span class="pre">diag_coulomb_mats</span></span><a class="headerlink" href="#ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.diag_coulomb_mats" title="Link to this definition">¶</a></dt>
<dd><p>The diagonal Coulomb matrices.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.orbital_rotations">
<span class="sig-name descname"><span class="pre">orbital_rotations</span></span><a class="headerlink" href="#ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.orbital_rotations" title="Link to this definition">¶</a></dt>
<dd><p>The orbital rotations.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.constant">
<span class="sig-name descname"><span class="pre">constant</span></span><a class="headerlink" href="#ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.constant" title="Link to this definition">¶</a></dt>
<dd><p>The constant.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.z_representation">
<span class="sig-name descname"><span class="pre">z_representation</span></span><a class="headerlink" href="#ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.z_representation" title="Link to this definition">¶</a></dt>
<dd><p>Whether the Hamiltonian is in the “Z” representation rather
than the “number” representation.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.to_number_representation">
<span class="sig-name descname"><span class="pre">to_number_representation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/hamiltonians/double_factorized_hamiltonian.html#DoubleFactorizedHamiltonian.to_number_representation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.to_number_representation" title="Link to this definition">¶</a></dt>
<dd><p>Return the Hamiltonian in the “number” representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian" title="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.to_z_representation">
<span class="sig-name descname"><span class="pre">to_z_representation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/hamiltonians/double_factorized_hamiltonian.html#DoubleFactorizedHamiltonian.to_z_representation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian.to_z_representation" title="Link to this definition">¶</a></dt>
<dd><p>Return the Hamiltonian in the “Z” representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian" title="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.hamiltonians.double_factorized_hamiltonian.double_factorized_hamiltonian">
<span class="sig-prename descclassname"><span class="pre">ffsim.hamiltonians.double_factorized_hamiltonian.</span></span><span class="sig-name descname"><span class="pre">double_factorized_hamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_representation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_vecs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag_coulomb_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cholesky</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/hamiltonians/double_factorized_hamiltonian.html#double_factorized_hamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.hamiltonians.double_factorized_hamiltonian.double_factorized_hamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Double-factorized decomposition of a molecular Hamiltonian.</p>
<p>The double-factorized decomposition acts on a Hamiltonian of the form</p>
<div class="math notranslate nohighlight">
\[H = \sum_{pq, \sigma} h_{pq} a^\dagger_{p, \sigma} a_{q, \sigma}
    + \frac12 \sum_{pqrs, \sigma \tau} h_{pqrs}
    a^\dagger_{p, \sigma} a^\dagger_{r, \tau} a_{s, \tau} a_{q, \sigma}
    + \text{constant}.\]</div>
<p>The Hamiltonian is decomposed into the double-factorized form</p>
<div class="math notranslate nohighlight">
\[H = \sum_{pq, \sigma} \kappa_{pq} a^\dagger_{p, \sigma} a_{q, \sigma}
+ \frac12 \sum_t \sum_{ij, \sigma\tau}
Z^{(t)}_{ij} n^{(t)}_{i, \sigma} n^{(t)}_{j, \tau}
+ \text{constant}'.\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[n^{(t)}_{i, \sigma} = \sum_{pq} U^{(t)}_{pi}
a^\dagger_{p, \sigma} a^\dagger_{q, \sigma} U^{(t)}_{qi}.\]</div>
<p>Here <span class="math notranslate nohighlight">\(U^{(t)}_{ij}\)</span> and <span class="math notranslate nohighlight">\(Z^{(t)}_{ij}\)</span> are tensors that are output by
the decomposition, and <span class="math notranslate nohighlight">\(\kappa_{pq}\)</span> is an updated one-body tensor.
Each matrix <span class="math notranslate nohighlight">\(U^{(t)}\)</span> is guaranteed to be unitary so that the
<span class="math notranslate nohighlight">\(n^{(t)}_{i, \sigma}\)</span> are number operators in a rotated basis, and
each <span class="math notranslate nohighlight">\(Z^{(t)}\)</span> is a real symmetric matrix.
The number of terms <span class="math notranslate nohighlight">\(t\)</span> in the decomposition depends on the allowed
error threshold. A larger error threshold leads to a smaller number of terms.
Furthermore, the <cite>max_rank</cite> parameter specifies an optional upper bound
on <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>The default behavior of this routine is to perform a straightforward
“exact” factorization of the two-body tensor based on a nested
eigenvalue decomposition. Additionally, one can choose to optimize the
coefficients stored in the tensor to achieve a “compressed” factorization.
This option is enabled by setting the <cite>optimize</cite> parameter to <cite>True</cite>.
The optimization attempts to minimize a least-squares objective function
quantifying the error in the low rank decomposition.
It uses <cite>scipy.optimize.minimize</cite>, passing both the objective function
and its gradient. The core tensors returned by the optimization can be optionally
constrained to have only certain elements allowed to be nonzero. This is achieved by
passing the <cite>diag_coulomb_mask</cite> parameter, which is an <span class="math notranslate nohighlight">\(N \times N\)</span> matrix of
boolean values where <span class="math notranslate nohighlight">\(N\)</span> is the number of orbitals. The nonzero elements of
this matrix indicate where the core tensors are allowed to be nonzero. Only the
upper triangular part of the matrix is used because the core tensors are symmetric.</p>
<p><strong>“Z” representation</strong></p>
<p>The “Z” representation of the double factorization is an alternative
representation that sometimes yields simpler quantum circuits.</p>
<p>Under the Jordan-Wigner transformation, the number operators take the form</p>
<div class="math notranslate nohighlight">
\[n^{(t)}_{i, \sigma} = \frac{(1 - z^{(t)}_{i, \sigma})}{2}\]</div>
<p>where <span class="math notranslate nohighlight">\(z^{(t)}_{i, \sigma}\)</span> is the Pauli Z operator in the rotated basis.
The “Z” representation is obtained by rewriting the two-body part in terms
of these Pauli Z operators and updating the one-body term as appropriate:</p>
<div class="math notranslate nohighlight">
\[H = \sum_{pq, \sigma} \kappa'_{pq} a^\dagger_{p, \sigma} a_{q, \sigma}
+ \frac18 \sum_t \sum_{ij, \sigma\tau}^*
Z^{(t)}_{ij} z^{(t)}_{i, \sigma} z^{(t)}_{j, \tau}
+ \text{constant}''\]</div>
<p>where the asterisk denotes summation over indices <span class="math notranslate nohighlight">\(ij, \sigma\tau\)</span>
where <span class="math notranslate nohighlight">\(i \neq j\)</span> or <span class="math notranslate nohighlight">\(\sigma \neq \tau\)</span>.</p>
<p>Note: Currently, only real-valued two-body tensors are supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>one_body_tensor</strong> – The one-body tensor of the Hamiltonian.</p></li>
<li><p><strong>two_body_tensor</strong> – The two-body tensor of the Hamiltonian.</p></li>
<li><p><strong>z_representation</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether to use the “Z” representation of the
low rank decomposition.</p></li>
<li><p><strong>tol</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Tolerance for error in the decomposition.
The error is defined as the maximum absolute difference between
an element of the original tensor and the corresponding element of
the reconstructed tensor.</p></li>
<li><p><strong>max_vecs</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – An optional limit on the number of terms to keep in the decomposition
of the two-body tensor. This argument overrides <code class="docutils literal notranslate"><span class="pre">tol</span></code>.</p></li>
<li><p><strong>optimize</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether to optimize the tensors returned by the decomposition.</p></li>
<li><p><strong>method</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The optimization method. See the documentation of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a> for possible values.</p></li>
<li><p><strong>callback</strong> – Callback function for the optimization. See the documentation of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a> for usage.</p></li>
<li><p><strong>options</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>]) – Options for the optimization. See the documentation of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a> for usage.</p></li>
<li><p><strong>diag_coulomb_mask</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]) – Diagonal Coulomb matrix mask to use in the optimization.
This is a matrix of boolean values where the nonzero elements indicate where
the diagonal coulomb matrices returned by optimization are allowed to be
nonzero. This parameter is only used if <cite>optimize</cite> is set to <cite>True</cite>, and
only the upper triangular part of the matrix is used.</p></li>
<li><p><strong>cholesky</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether to perform the factorization using a modified Cholesky
decomposition. If False, a full eigenvalue decomposition is used instead,
which can be much more expensive. This argument is ignored if <code class="docutils literal notranslate"><span class="pre">optimize</span></code>
is set to True.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian" title="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The double-factorized Hamiltonian.</p>
</dd>
</dl>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://arxiv.org/abs/1808.02625">arXiv:1808.02625</a></p></li>
<li><p><a class="reference external" href="https://arxiv.org/abs/2104.08957">arXiv:2104.08957</a></p></li>
</ul>
</dd></dl>

</section>
<section id="module-ffsim.hamiltonians.molecular_hamiltonian">
<span id="ffsim-hamiltonians-molecular-hamiltonian-module"></span><h2>ffsim.hamiltonians.molecular_hamiltonian module<a class="headerlink" href="#module-ffsim.hamiltonians.molecular_hamiltonian" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.hamiltonians.molecular_hamiltonian.</span></span><span class="sig-name descname"><span class="pre">MolecularHamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/ffsim/hamiltonians/molecular_hamiltonian.html#MolecularHamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A molecular Hamiltonian.</p>
<p>A Hamiltonian of the form</p>
<div class="math notranslate nohighlight">
\[H = \sum_{pq, \sigma} h_{pq} a^\dagger_{p, \sigma} a_{q, \sigma}
    + \frac12 \sum_{pqrs, \sigma \tau} h_{pqrs}
    a^\dagger_{p, \sigma} a^\dagger_{r, \tau} a_{s, \tau} a_{q, \sigma}
    + \text{constant}.\]</div>
<p>Here <span class="math notranslate nohighlight">\(h_{pq}\)</span> is called the one-body tensor and <span class="math notranslate nohighlight">\(h_{pqrs}\)</span> is called
the two-body tensor.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian.one_body_tensor">
<span class="sig-name descname"><span class="pre">one_body_tensor</span></span><a class="headerlink" href="#ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian.one_body_tensor" title="Link to this definition">¶</a></dt>
<dd><p>The one-body tensor.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian.two_body_tensor">
<span class="sig-name descname"><span class="pre">two_body_tensor</span></span><a class="headerlink" href="#ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian.two_body_tensor" title="Link to this definition">¶</a></dt>
<dd><p>The two-body tensor.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian.constant">
<span class="sig-name descname"><span class="pre">constant</span></span><a class="headerlink" href="#ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian.constant" title="Link to this definition">¶</a></dt>
<dd><p>The constant.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-ffsim.hamiltonians">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-ffsim.hamiltonians" title="Link to this heading">¶</a></h2>
<p>Classes for representing Hamiltonians.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">ffsim</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">API reference</a><ul>
  <li><a href="modules.html">ffsim</a><ul>
  <li><a href="ffsim.html">ffsim package</a><ul>
      <li>Previous: <a href="ffsim.gates.html" title="previous chapter">ffsim.gates package</a></li>
      <li>Next: <a href="ffsim.linalg.html" title="next chapter">ffsim.linalg package</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, IBM.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/api/generated/ffsim.hamiltonians.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>