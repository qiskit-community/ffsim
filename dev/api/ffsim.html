<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="ffsim.contract" href="ffsim.contract.html" /><link rel="prev" title="API Reference" href="index.html" />

    <!-- Generated with Sphinx 7.3.7 and Furo 2024.05.06 -->
        <title>ffsim - ffsim 0.0.35.dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=387cc868" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" /
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">ffsim 0.0.35.dev0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">ffsim 0.0.35.dev0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../tutorials/index.html">Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Tutorials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/double-factorized-trotter.html">Implementing Trotter simulation of the double-factorized Hamiltonian</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../explanations/index.html">Explanations</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Explanations</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../explanations/state-vectors-and-gates.html">State vectors and gates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../explanations/hamiltonians.html">Hamiltonians</a></li>
<li class="toctree-l2"><a class="reference internal" href="../explanations/orbital-rotation.html">Orbital rotations and quadratic Hamiltonians</a></li>
<li class="toctree-l2"><a class="reference internal" href="../explanations/double-factorized.html">Double-factorized representation of the molecular Hamiltonian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../explanations/qiskit-gate-decompositions.html">Qubit gate decompositions of fermionic gates</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../how-to-guides/index.html">How-to guides</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of How-to guides</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../how-to-guides/lucj.html">How to simulate the local unitary cluster Jastrow (LUCJ) ansatz</a></li>
<li class="toctree-l2"><a class="reference internal" href="../how-to-guides/entanglement-forging.html">How to simulate entanglement forging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../how-to-guides/fermion-operator.html">How to use the FermionOperator class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../how-to-guides/qiskit-circuits.html">How to build and transpile Qiskit quantum circuits</a></li>
<li class="toctree-l2"><a class="reference internal" href="../how-to-guides/qiskit-sampler.html">How to use ffsim’s Qiskit Sampler primitive</a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">API Reference</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of API Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">ffsim</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffsim.contract.html">ffsim.contract</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffsim.linalg.html">ffsim.linalg</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffsim.optimize.html">ffsim.optimize</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffsim.qiskit.html">ffsim.qiskit</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffsim.random.html">ffsim.random</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffsim.testing.html">ffsim.testing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/qiskit-community/ffsim/blob/main/CONTRIBUTING.md">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/qiskit-community/ffsim">GitHub</a></li>
<li class="toctree-l1"><a class="reference external" href="https://qiskit-community.github.io/ffsim/dev/">Development Branch Docs</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../_sources/api/ffsim.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="module-ffsim">
<span id="ffsim"></span><h1>ffsim<a class="headerlink" href="#module-ffsim" title="Link to this heading">¶</a></h1>
<p>ffsim is a software library for fast simulation of fermionic quantum circuits.</p>
<dl class="py class">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">DoubleFactorizedHamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag_coulomb_mats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_representation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/double_factorized_hamiltonian.html#DoubleFactorizedHamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A Hamiltonian in the double-factorized representation.</p>
<p>The double-factorized form of the molecular Hamiltonian is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = \sum_{\sigma, pq} \kappa_{pq} a^\dagger_{\sigma, p} a_{\sigma, q}
+ \frac12 \sum_t \sum_{\sigma\tau, ij}
Z^{(t)}_{ij} n^{(t)}_{\sigma, i} n^{(t)}_{\tau, j}
+ \text{constant}'.\]</div>
</div>
<p>where</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[n^{(t)}_{\sigma, i} = \sum_{pq} U^{(t)}_{pi}
a^\dagger_{\sigma, p} a_{\sigma, q} U^{(t)}_{qi}.\]</div>
</div>
<p>Here each <span class="math notranslate nohighlight">\(U^{(t)}\)</span> is a unitary matrix and each <span class="math notranslate nohighlight">\(Z^{(t)}\)</span>
is a real symmetric matrix.</p>
<p><strong>“Z” representation</strong></p>
<p>The “Z” representation of the double factorization is an alternative
representation that sometimes yields simpler quantum circuits.</p>
<p>Under the Jordan-Wigner transformation, the number operators take the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[n^{(t)}_{\sigma, i} = \frac{(1 - z^{(t)}_{\sigma, i})}{2}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(z^{(t)}_{\sigma, i}\)</span> is the Pauli Z operator in the rotated basis.
The “Z” representation is obtained by rewriting the two-body part in terms
of these Pauli Z operators and updating the one-body term as appropriate:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = \sum_{\sigma, pq} \kappa'_{pq} a^\dagger_{\sigma, p} a_{\sigma, q}
+ \frac18 \sum_t \sum_{\sigma\tau, ij}^*
Z^{(t)}_{ij} z^{(t)}_{\sigma, i} z^{(t)}_{\tau, j}
+ \text{constant}''\]</div>
</div>
<p>where the asterisk denotes summation over indices <span class="math notranslate nohighlight">\(\sigma\tau, ij\)</span>
where <span class="math notranslate nohighlight">\(\sigma \neq \tau\)</span> or <span class="math notranslate nohighlight">\(i \neq j\)</span>.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://arxiv.org/abs/1808.02625">Low rank representations for quantum simulation of electronic structure</a></p></li>
<li><p><a class="reference external" href="https://arxiv.org/abs/2104.08957">Quantum Filter Diagonalization with Double-Factorized Hamiltonians</a></p></li>
</ul>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.one_body_tensor">
<span class="sig-name descname"><span class="pre">one_body_tensor</span></span><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.one_body_tensor" title="Link to this definition">¶</a></dt>
<dd><p>The one-body tensor <span class="math notranslate nohighlight">\(\kappa\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.diag_coulomb_mats">
<span class="sig-name descname"><span class="pre">diag_coulomb_mats</span></span><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.diag_coulomb_mats" title="Link to this definition">¶</a></dt>
<dd><p>The diagonal Coulomb matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.orbital_rotations">
<span class="sig-name descname"><span class="pre">orbital_rotations</span></span><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.orbital_rotations" title="Link to this definition">¶</a></dt>
<dd><p>The orbital rotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.constant">
<span class="sig-name descname"><span class="pre">constant</span></span><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.constant" title="Link to this definition">¶</a></dt>
<dd><p>The constant.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.z_representation">
<span class="sig-name descname"><span class="pre">z_representation</span></span><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.z_representation" title="Link to this definition">¶</a></dt>
<dd><p>Whether the Hamiltonian is in the “Z” representation
rather than the “number” representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_molecular_hamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_representation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_vecs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag_coulomb_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cholesky</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/double_factorized_hamiltonian.html#DoubleFactorizedHamiltonian.from_molecular_hamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Initialize a DoubleFactorizedHamiltonian from a MolecularHamiltonian.</p>
<p>This function takes as input a <a class="reference internal" href="#ffsim.MolecularHamiltonian" title="ffsim.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a>, which stores a
one-body tensor, two-body tensor, and constant. It performs a double-factorized
decomposition of the two-body tensor and computes a new one-body tensor
and constant, and returns a <a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian" title="ffsim.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a> storing the
results.</p>
<p>See <a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian" title="ffsim.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a> for a description of the
<cite>z_representation</cite> argument. See <a class="reference internal" href="ffsim.linalg.html#ffsim.linalg.double_factorized" title="ffsim.linalg.double_factorized"><code class="xref py py-func docutils literal notranslate"><span class="pre">ffsim.linalg.double_factorized()</span></code></a> for a
description of the rest of the arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hamiltonian</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.MolecularHamiltonian" title="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a></span>) – The Hamiltonian whose double-factorized representation to
compute.</p></li>
<li><p><strong>z_representation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to use the “Z” representation of the
decomposition.</p></li>
<li><p><strong>tol</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – Tolerance for error in the decomposition.
The error is defined as the maximum absolute difference between
an element of the original tensor and the corresponding element of
the reconstructed tensor.</p></li>
<li><p><strong>max_vecs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – An optional limit on the number of terms to keep in the
decomposition of the two-body tensor. This argument overrides <code class="docutils literal notranslate"><span class="pre">tol</span></code>.</p></li>
<li><p><strong>optimize</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to optimize the tensors returned by the decomposition.</p></li>
<li><p><strong>method</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></span>) – The optimization method. See the documentation of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a> for possible values.</p></li>
<li><p><strong>callback</strong> – Callback function for the optimization. See the documentation of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a> for usage.</p></li>
<li><p><strong>options</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Options for the optimization. See the documentation of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a> for usage.</p></li>
<li><p><strong>diag_coulomb_indices</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Allowed indices for nonzero values of the diagonal
Coulomb matrices. Matrix entries corresponding to indices not in this
list will be set to zero. This list should contain only upper
trianglular indices, i.e., pairs <span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>.
Passing a list with lower triangular indices will raise an error.
This parameter is only used if <cite>optimize</cite> is set to True.</p></li>
<li><p><strong>cholesky</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to perform the factorization using a modified Cholesky
decomposition. If False, a full eigenvalue decomposition is used
instead, which can be much more expensive. This argument is ignored if
<cite>optimize</cite> is set to True.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian" title="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The double-factorized Hamiltonian.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.to_number_representation">
<span class="sig-name descname"><span class="pre">to_number_representation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/double_factorized_hamiltonian.html#DoubleFactorizedHamiltonian.to_number_representation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.to_number_representation" title="Link to this definition">¶</a></dt>
<dd><p>Return the Hamiltonian in the “number” representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian" title="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.to_z_representation">
<span class="sig-name descname"><span class="pre">to_z_representation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/double_factorized_hamiltonian.html#DoubleFactorizedHamiltonian.to_z_representation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.to_z_representation" title="Link to this definition">¶</a></dt>
<dd><p>Return the Hamiltonian in the “Z” representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian" title="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.FermionAction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">FermionAction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermion_action.html#FermionAction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.FermionAction" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">NamedTuple</span></code></p>
<p>A fermionic action.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.FermionAction.action">
<span class="sig-name descname"><span class="pre">action</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></em><a class="headerlink" href="#ffsim.FermionAction.action" title="Link to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.FermionAction.orb">
<span class="sig-name descname"><span class="pre">orb</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></em><a class="headerlink" href="#ffsim.FermionAction.orb" title="Link to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.FermionAction.spin">
<span class="sig-name descname"><span class="pre">spin</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></em><a class="headerlink" href="#ffsim.FermionAction.spin" title="Link to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.FermionOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">FermionOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeffs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ffsim.FermionOperator" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A fermionic operator.</p>
<p>A FermionOperator represents a linear combination of products of fermionic creation
and annihilation operators. Initialize a FermionOperator by passing a dictionary mapping
the terms in the linear combination to their associated coefficients. FermionOperators
Can be added, subtracted, and multiplied, and they support multiplication and division
by scalars. When multiplying by a scalar, the scalar should go on the left side of the
multiplication operator, e.g. <code class="docutils literal notranslate"><span class="pre">scalar</span> <span class="pre">*</span> <span class="pre">op</span></code>, not <code class="docutils literal notranslate"><span class="pre">op</span> <span class="pre">*</span> <span class="pre">scalar</span></code>.</p>
<p>See <a class="reference internal" href="../how-to-guides/fermion-operator.html"><span class="doc">How to use the FermionOperator class</span></a> for an explanation of how to use this class.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Note: Since FermionOperator is an unordered mapping, the order of</span>
<span class="c1"># the terms in the print outputs below may vary between runs.</span>

<span class="kn">import</span> <span class="nn">ffsim</span>

<span class="n">op1</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="p">(</span><span class="n">ffsim</span><span class="o">.</span><span class="n">cre_a</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">des_a</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="p">(</span><span class="n">ffsim</span><span class="o">.</span><span class="n">cre_a</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">des_a</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">,</span>
        <span class="p">(</span><span class="n">ffsim</span><span class="o">.</span><span class="n">cre_b</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">des_b</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">cre_a</span><span class="p">(</span><span class="mi">4</span><span class="p">)):</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">op1</span><span class="p">)</span>
<span class="c1"># prints</span>
<span class="c1"># FermionOperator({</span>
<span class="c1">#     (cre_b(1), des_b(5), cre_a(4)): 2+2j,</span>
<span class="c1">#     (cre_a(3), des_a(0)): -0.5,</span>
<span class="c1">#     (cre_a(0), des_a(3)): 1</span>
<span class="c1"># })</span>

<span class="n">op2</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="p">(</span><span class="n">ffsim</span><span class="o">.</span><span class="n">cre_b</span><span class="p">(</span><span class="mi">2</span><span class="p">),):</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span>
        <span class="p">(</span><span class="n">ffsim</span><span class="o">.</span><span class="n">des_a</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">des_b</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span><span class="p">)</span>
<span class="c1"># prints</span>
<span class="c1"># FermionOperator({</span>
<span class="c1">#     (cre_a(3), des_a(0)): -0.25,</span>
<span class="c1">#     (cre_b(2)): 0+1j,</span>
<span class="c1">#     (des_a(3), des_b(3)): -0.25,</span>
<span class="c1">#     (cre_b(1), des_b(5), cre_a(4)): 1+1j,</span>
<span class="c1">#     (cre_a(0), des_a(3)): 0.5</span>
<span class="c1"># })</span>

<span class="nb">print</span><span class="p">(</span><span class="n">op1</span> <span class="o">*</span> <span class="n">op2</span><span class="p">)</span>
<span class="c1"># prints</span>
<span class="c1"># FermionOperator({</span>
<span class="c1">#     (cre_b(1), des_b(5), cre_a(4), cre_b(2)): -1+1j,</span>
<span class="c1">#     (cre_a(0), des_a(3), des_a(3), des_b(3)): -0.125,</span>
<span class="c1">#     (cre_a(3), des_a(0), des_a(3), des_b(3)): 0.0625,</span>
<span class="c1">#     (cre_b(1), des_b(5), cre_a(4), des_a(3), des_b(3)): -0.25-0.25j,</span>
<span class="c1">#     (cre_a(0), des_a(3), cre_b(2)): 0+0.5j,</span>
<span class="c1">#     (cre_a(3), des_a(0), cre_b(2)): 0-0.25j</span>
<span class="c1"># })</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeffs</strong> (<em>dict</em><em>[</em><em>tuple</em><em>[</em><em>tuple</em><em>[</em><em>bool</em><em>, </em><em>bool</em><em>, </em><em>int</em><em>]</em><em>, </em><em>...</em><em>]</em><em>, </em><em>complex</em><em>]</em>) – The coefficients of the
operator.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="ffsim.FermionOperator.conserves_particle_number">
<span class="sig-name descname"><span class="pre">conserves_particle_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ffsim.FermionOperator.conserves_particle_number" title="Link to this definition">¶</a></dt>
<dd><p>Return whether the operator conserves particle number.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the operator conserves particle number, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.FermionOperator.conserves_spin_z">
<span class="sig-name descname"><span class="pre">conserves_spin_z</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ffsim.FermionOperator.conserves_spin_z" title="Link to this definition">¶</a></dt>
<dd><p>Return whether the operator conserves the Z component of spin.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the operator conserves the Z component of spin, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.FermionOperator.many_body_order">
<span class="sig-name descname"><span class="pre">many_body_order</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ffsim.FermionOperator.many_body_order" title="Link to this definition">¶</a></dt>
<dd><p>Return the many-body order of the operator.</p>
<p>The many-body order is defined as the length of the longest term contained
in the operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The many-body order of the operator.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.FermionOperator.normal_ordered">
<span class="sig-name descname"><span class="pre">normal_ordered</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ffsim.FermionOperator.normal_ordered" title="Link to this definition">¶</a></dt>
<dd><p>Return the normal ordered form of the operator.</p>
<p>The normal ordered form of an operator is an equivalent operator in which
each term has been reordered into a canonical ordering.
In each term of a normal-ordered fermion operator, the operators comprising
the term appear from left to right in descending lexicographic order by
(action, spin, orb). That is, all creation operators appear before all
annihilation operators; within creation/annihilation operators, spin beta
operators appear before spin alpha operators, and larger orbital indices
appear before smaller orbital indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The normal-ordered fermion operator.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#ffsim.FermionOperator" title="ffsim.FermionOperator">FermionOperator</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">GivensAnsatzOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thetas</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/givens.html#GivensAnsatzOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.GivensAnsatzOperator" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A Givens rotation ansatz operator.</p>
<p>The Givens rotation ansatz consists of a sequence of <a class="reference external" href="ffsim.html#ffsim.apply_givens_rotation">Givens rotations</a>.</p>
<p>Note that this ansatz does not implement any interactions between spin alpha and
spin beta orbitals.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOperator.norb">
<span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.GivensAnsatzOperator.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOperator.interaction_pairs">
<span class="sig-name descname"><span class="pre">interaction_pairs</span></span><a class="headerlink" href="#ffsim.GivensAnsatzOperator.interaction_pairs" title="Link to this definition">¶</a></dt>
<dd><p>The orbital pairs to apply the Givens
rotations to.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[tuple[int, int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOperator.thetas">
<span class="sig-name descname"><span class="pre">thetas</span></span><a class="headerlink" href="#ffsim.GivensAnsatzOperator.thetas" title="Link to this definition">¶</a></dt>
<dd><p>The angles for the Givens rotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOperator.from_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/givens.html#GivensAnsatzOperator.from_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.GivensAnsatzOperator.from_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the operator from a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The real-valued parameter vector.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – The orbital pairs to apply the hop gates to.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.GivensAnsatzOperator" title="ffsim.variational.givens.GivensAnsatzOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">GivensAnsatzOperator</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOperator.to_parameters">
<span class="sig-name descname"><span class="pre">to_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/givens.html#GivensAnsatzOperator.to_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.GivensAnsatzOperator.to_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Convert the operator to a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.HopGateAnsatzOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">HopGateAnsatzOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thetas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/hopgate.html#HopGateAnsatzOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.HopGateAnsatzOperator" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A hop gate ansatz operator.</p>
<p>The hop gate ansatz consists of a sequence of <a class="reference external" href="ffsim.html#ffsim.apply_hop_gate">hop gates</a>.</p>
<p>Note that this ansatz does not implement any interactions between spin alpha and
spin beta orbitals. It was designed to be used with <a class="reference external" href="https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.3.010309">entanglement forging</a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.HopGateAnsatzOperator.norb">
<span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.HopGateAnsatzOperator.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.HopGateAnsatzOperator.interaction_pairs">
<span class="sig-name descname"><span class="pre">interaction_pairs</span></span><a class="headerlink" href="#ffsim.HopGateAnsatzOperator.interaction_pairs" title="Link to this definition">¶</a></dt>
<dd><p>The orbital pairs to apply the hop
gates to.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[tuple[int, int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.HopGateAnsatzOperator.thetas">
<span class="sig-name descname"><span class="pre">thetas</span></span><a class="headerlink" href="#ffsim.HopGateAnsatzOperator.thetas" title="Link to this definition">¶</a></dt>
<dd><p>The rotation angles for the hop gates.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.HopGateAnsatzOperator.final_orbital_rotation">
<span class="sig-name descname"><span class="pre">final_orbital_rotation</span></span><a class="headerlink" href="#ffsim.HopGateAnsatzOperator.final_orbital_rotation" title="Link to this definition">¶</a></dt>
<dd><p>An optional final orbital rotation to
append to the ansatz, used to optimize the orbital basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.HopGateAnsatzOperator.from_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/hopgate.html#HopGateAnsatzOperator.from_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.HopGateAnsatzOperator.from_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the operator from a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The real-valued parameter vector.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – The orbital pairs to apply the hop gates to.</p></li>
<li><p><strong>with_final_orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include a final orbital rotation
in the ansatz operator.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.HopGateAnsatzOperator" title="ffsim.variational.hopgate.HopGateAnsatzOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">HopGateAnsatzOperator</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.HopGateAnsatzOperator.to_parameters">
<span class="sig-name descname"><span class="pre">to_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/hopgate.html#HopGateAnsatzOperator.to_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.HopGateAnsatzOperator.to_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Convert the operator to a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.MolecularData">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">MolecularData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_space</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">core_energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">one_body_integrals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_body_integrals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hf_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hf_mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hf_mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mp2_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mp2_t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ccsd_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ccsd_t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ccsd_t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fci_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fci_vec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_integrals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_symmetries</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class for storing molecular data.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.atom">
<span class="sig-name descname"><span class="pre">atom</span></span><a class="headerlink" href="#ffsim.MolecularData.atom" title="Link to this definition">¶</a></dt>
<dd><p>The coordinates of the atoms in the molecule.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.basis">
<span class="sig-name descname"><span class="pre">basis</span></span><a class="headerlink" href="#ffsim.MolecularData.basis" title="Link to this definition">¶</a></dt>
<dd><p>The basis set, e.g. “sto-6g”.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.spin">
<span class="sig-name descname"><span class="pre">spin</span></span><a class="headerlink" href="#ffsim.MolecularData.spin" title="Link to this definition">¶</a></dt>
<dd><p>The spin of the molecule.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.symmetry">
<span class="sig-name descname"><span class="pre">symmetry</span></span><a class="headerlink" href="#ffsim.MolecularData.symmetry" title="Link to this definition">¶</a></dt>
<dd><p>The symmetry of the molecule.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.norb">
<span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.MolecularData.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.nelec">
<span class="sig-name descname"><span class="pre">nelec</span></span><a class="headerlink" href="#ffsim.MolecularData.nelec" title="Link to this definition">¶</a></dt>
<dd><p>The number of alpha and beta electrons.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.mo_coeff">
<span class="sig-name descname"><span class="pre">mo_coeff</span></span><a class="headerlink" href="#ffsim.MolecularData.mo_coeff" title="Link to this definition">¶</a></dt>
<dd><p>Molecular orbital coefficients in the AO basis.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.mo_occ">
<span class="sig-name descname"><span class="pre">mo_occ</span></span><a class="headerlink" href="#ffsim.MolecularData.mo_occ" title="Link to this definition">¶</a></dt>
<dd><p>Molecular orbital occupancies.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.active_space">
<span class="sig-name descname"><span class="pre">active_space</span></span><a class="headerlink" href="#ffsim.MolecularData.active_space" title="Link to this definition">¶</a></dt>
<dd><p>The molecular orbitals included in the active space.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.core_energy">
<span class="sig-name descname"><span class="pre">core_energy</span></span><a class="headerlink" href="#ffsim.MolecularData.core_energy" title="Link to this definition">¶</a></dt>
<dd><p>The core energy.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.one_body_tensor">
<span class="sig-name descname"><span class="pre">one_body_tensor</span></span><a class="headerlink" href="#ffsim.MolecularData.one_body_tensor" title="Link to this definition">¶</a></dt>
<dd><p>The one-body tensor.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.two_body_integrals">
<span class="sig-name descname"><span class="pre">two_body_integrals</span></span><a class="headerlink" href="#ffsim.MolecularData.two_body_integrals" title="Link to this definition">¶</a></dt>
<dd><p>The two-body integrals in compressed format.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.hf_energy">
<span class="sig-name descname"><span class="pre">hf_energy</span></span><a class="headerlink" href="#ffsim.MolecularData.hf_energy" title="Link to this definition">¶</a></dt>
<dd><p>The Hartree-Fock energy.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.hf_mo_coeff">
<span class="sig-name descname"><span class="pre">hf_mo_coeff</span></span><a class="headerlink" href="#ffsim.MolecularData.hf_mo_coeff" title="Link to this definition">¶</a></dt>
<dd><p>Hartree-Fock canonical orbital coefficients in the AO basis.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.hf_mo_occ">
<span class="sig-name descname"><span class="pre">hf_mo_occ</span></span><a class="headerlink" href="#ffsim.MolecularData.hf_mo_occ" title="Link to this definition">¶</a></dt>
<dd><p>Hartree-Fock canonical orbital occupancies.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.mp2_energy">
<span class="sig-name descname"><span class="pre">mp2_energy</span></span><a class="headerlink" href="#ffsim.MolecularData.mp2_energy" title="Link to this definition">¶</a></dt>
<dd><p>The MP2 energy.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.mp2_t2">
<span class="sig-name descname"><span class="pre">mp2_t2</span></span><a class="headerlink" href="#ffsim.MolecularData.mp2_t2" title="Link to this definition">¶</a></dt>
<dd><p>The MP2 t2 amplitudes.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.ccsd_energy">
<span class="sig-name descname"><span class="pre">ccsd_energy</span></span><a class="headerlink" href="#ffsim.MolecularData.ccsd_energy" title="Link to this definition">¶</a></dt>
<dd><p>The CCSD energy.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.ccsd_t1">
<span class="sig-name descname"><span class="pre">ccsd_t1</span></span><a class="headerlink" href="#ffsim.MolecularData.ccsd_t1" title="Link to this definition">¶</a></dt>
<dd><p>The CCSD t1 amplitudes.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.ccsd_t2">
<span class="sig-name descname"><span class="pre">ccsd_t2</span></span><a class="headerlink" href="#ffsim.MolecularData.ccsd_t2" title="Link to this definition">¶</a></dt>
<dd><p>The CCSD t2 amplitudes.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.fci_energy">
<span class="sig-name descname"><span class="pre">fci_energy</span></span><a class="headerlink" href="#ffsim.MolecularData.fci_energy" title="Link to this definition">¶</a></dt>
<dd><p>The FCI energy.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.fci_vec">
<span class="sig-name descname"><span class="pre">fci_vec</span></span><a class="headerlink" href="#ffsim.MolecularData.fci_vec" title="Link to this definition">¶</a></dt>
<dd><p>The FCI state vector.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.dipole_integrals">
<span class="sig-name descname"><span class="pre">dipole_integrals</span></span><a class="headerlink" href="#ffsim.MolecularData.dipole_integrals" title="Link to this definition">¶</a></dt>
<dd><p>The dipole integrals.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.orbital_symmetries">
<span class="sig-name descname"><span class="pre">orbital_symmetries</span></span><a class="headerlink" href="#ffsim.MolecularData.orbital_symmetries" title="Link to this definition">¶</a></dt>
<dd><p>The orbital symmetries.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.from_mole">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_mole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_space=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scf_func=&lt;function</span> <span class="pre">RHF&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.from_mole"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.from_mole" title="Link to this definition">¶</a></dt>
<dd><p>Initialize a MolecularData object from a PySCF molecule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></span>) – The molecule.</p></li>
<li><p><strong>active_space</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – An optional list of orbitals to use for the active space.</p></li>
<li><p><strong>scf_func</strong> – The PySCF SCF function to use for the Hartree-Fock calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.MolecularData" title="ffsim.molecular_data.MolecularData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularData</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.from_scf">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hartree_fock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_space</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.from_scf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.from_scf" title="Link to this definition">¶</a></dt>
<dd><p>Initialize a MolecularData object from a Hartree-Fock calculation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hartree_fock</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">SCF</span></code></span>) – The Hartree-Fock object.</p></li>
<li><p><strong>active_space</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – An optional list of orbitals to use for the active space.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.MolecularData" title="ffsim.molecular_data.MolecularData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularData</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.MolecularData.hamiltonian">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hamiltonian</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="#ffsim.MolecularHamiltonian" title="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian"><span class="pre">MolecularHamiltonian</span></a></em><a class="headerlink" href="#ffsim.MolecularData.hamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>The Hamiltonian defined by the molecular data.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.MolecularData.mole">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mole</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Mole</span></em><a class="headerlink" href="#ffsim.MolecularData.mole" title="Link to this definition">¶</a></dt>
<dd><p>The PySCF Mole class for this molecular data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.run_ccsd">
<span class="sig-name descname"><span class="pre">run_ccsd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.run_ccsd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.run_ccsd" title="Link to this definition">¶</a></dt>
<dd><p>Run CCSD and store results.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.run_fci">
<span class="sig-name descname"><span class="pre">run_fci</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_fci_vec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.run_fci"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.run_fci" title="Link to this definition">¶</a></dt>
<dd><p>Run FCI and store results.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.run_mp2">
<span class="sig-name descname"><span class="pre">run_mp2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.run_mp2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.run_mp2" title="Link to this definition">¶</a></dt>
<dd><p>Run MP2 and store results.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.MolecularHamiltonian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">MolecularHamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/molecular_hamiltonian.html#MolecularHamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularHamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A molecular Hamiltonian.</p>
<p>A Hamiltonian of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = \sum_{\sigma, pq} h_{pq} a^\dagger_{\sigma, p} a_{\sigma, q}
    + \frac12 \sum_{\sigma \tau, pqrs} h_{pqrs}
    a^\dagger_{\sigma, p} a^\dagger_{\tau, r} a_{\tau, s} a_{\sigma, q}
    + \text{constant}.\]</div>
</div>
<p>Here <span class="math notranslate nohighlight">\(h_{pq}\)</span> is called the one-body tensor and <span class="math notranslate nohighlight">\(h_{pqrs}\)</span> is called
the two-body tensor.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularHamiltonian.one_body_tensor">
<span class="sig-name descname"><span class="pre">one_body_tensor</span></span><a class="headerlink" href="#ffsim.MolecularHamiltonian.one_body_tensor" title="Link to this definition">¶</a></dt>
<dd><p>The one-body tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularHamiltonian.two_body_tensor">
<span class="sig-name descname"><span class="pre">two_body_tensor</span></span><a class="headerlink" href="#ffsim.MolecularHamiltonian.two_body_tensor" title="Link to this definition">¶</a></dt>
<dd><p>The two-body tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularHamiltonian.constant">
<span class="sig-name descname"><span class="pre">constant</span></span><a class="headerlink" href="#ffsim.MolecularHamiltonian.constant" title="Link to this definition">¶</a></dt>
<dd><p>The constant.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.MolecularHamiltonian.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#ffsim.MolecularHamiltonian.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularHamiltonian.rotated">
<span class="sig-name descname"><span class="pre">rotated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orbital_rotation</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/molecular_hamiltonian.html#MolecularHamiltonian.rotated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularHamiltonian.rotated" title="Link to this definition">¶</a></dt>
<dd><p>Return the Hamiltonian in a rotated orbital basis.</p>
<p>Given an orbital rotation <span class="math notranslate nohighlight">\(\mathcal{U}\)</span>, returns the operator</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{U} H \mathcal{U}^\dagger\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(H\)</span> is the original Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The orbital rotation.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.MolecularHamiltonian" title="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The rotated Hamiltonian.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.ProductStateSum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">ProductStateSum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeffs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">np.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/product_state_sum.html#ProductStateSum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.ProductStateSum" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">NamedTuple</span></code></p>
<p>A linear combination of product states.</p>
<p>Given a ProductStateSum <code class="docutils literal notranslate"><span class="pre">prod_state_sum</span></code>, the full state vector can be
reconstructed as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">(</span>
    <span class="n">coeff</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">vec_a</span><span class="p">,</span> <span class="n">vec_b</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">coeff</span><span class="p">,</span> <span class="p">(</span><span class="n">vec_a</span><span class="p">,</span> <span class="n">vec_b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">prod_state_sum</span><span class="o">.</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">prod_state_sum</span><span class="o">.</span><span class="n">states</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.ProductStateSum.coeffs">
<span class="sig-name descname"><span class="pre">coeffs</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></em><a class="headerlink" href="#ffsim.ProductStateSum.coeffs" title="Link to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.ProductStateSum.states">
<span class="sig-name descname"><span class="pre">states</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code><span class="pre">[</span><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code><span class="pre">[</span><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code><span class="pre">,</span> <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code><span class="pre">]]</span></em><a class="headerlink" href="#ffsim.ProductStateSum.states" title="Link to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.RealUCJOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">RealUCJOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag_coulomb_mats_alpha_alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag_coulomb_mats_alpha_beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj.html#RealUCJOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.RealUCJOperator" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Real-valued unitary cluster Jastrow operator.</p>
<p>A real-valued unitary cluster Jastrow (UCJ) operator has the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\prod_{k = 1}^L
\mathcal{W_k^*} e^{i \mathcal{-J}_k} \mathcal{W_k}^T
\mathcal{W_k} e^{i \mathcal{J}_k} \mathcal{W_k^\dagger}\]</div>
</div>
<p>where each <span class="math notranslate nohighlight">\(\mathcal{W_k}\)</span> is an orbital rotation and each <span class="math notranslate nohighlight">\(\mathcal{J}\)</span>
is a diagonal Coulomb operator of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{J} = \frac12\sum_{ij,\sigma \tau}
\mathbf{J}^{\sigma \tau}_{ij} n_{i,\sigma} n_{j,\tau}.\]</div>
</div>
<p>In order that the operator commutes with the total spin Z operator, we enforce that
<span class="math notranslate nohighlight">\(\mathbf{J}^{\alpha\alpha} = \mathbf{J}^{\beta\beta}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{J}^{\alpha\beta} = \mathbf{J}^{\beta\alpha}\)</span>. As a result, we have
two sets of matrices for describing the diagonal Coulomb operators:
“alpha-alpha” matrices containing coefficients for terms involving the same spin,
and “alpha-beta” matrices containing coefficients for terms involving different
spins.</p>
<p>To support variational optimization of the orbital basis, an optional final
orbital rotation can be included in the operator, to be performed at the end.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.RealUCJOperator.diag_coulomb_mats_alpha_alpha">
<span class="sig-name descname"><span class="pre">diag_coulomb_mats_alpha_alpha</span></span><a class="headerlink" href="#ffsim.RealUCJOperator.diag_coulomb_mats_alpha_alpha" title="Link to this definition">¶</a></dt>
<dd><p>The “alpha-alpha” diagonal Coulomb matrices.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.RealUCJOperator.diag_coulomb_mats_alpha_beta">
<span class="sig-name descname"><span class="pre">diag_coulomb_mats_alpha_beta</span></span><a class="headerlink" href="#ffsim.RealUCJOperator.diag_coulomb_mats_alpha_beta" title="Link to this definition">¶</a></dt>
<dd><p>The “alpha-beta” diagonal Coulomb matrices.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.RealUCJOperator.orbital_rotations">
<span class="sig-name descname"><span class="pre">orbital_rotations</span></span><a class="headerlink" href="#ffsim.RealUCJOperator.orbital_rotations" title="Link to this definition">¶</a></dt>
<dd><p>The orbital rotations.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.RealUCJOperator.final_orbital_rotation">
<span class="sig-name descname"><span class="pre">final_orbital_rotation</span></span><a class="headerlink" href="#ffsim.RealUCJOperator.final_orbital_rotation" title="Link to this definition">¶</a></dt>
<dd><p>The optional final orbital rotation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.RealUCJOperator.from_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_alpha_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_beta_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj.html#RealUCJOperator.from_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.RealUCJOperator.from_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the real UCJ operator from a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The real-valued parameter vector.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>n_reps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of ansatz repetitions (<span class="math notranslate nohighlight">\(L\)</span> from the docstring of
this class).</p></li>
<li><p><strong>alpha_alpha_indices</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Allowed indices for nonzero values of the “alpha-alpha”
diagonal Coulomb matrices (see the docstring of this class).
If not specified, all matrix entries are allowed to be nonzero.
This list should contain only upper trianglular indices, i.e.,
pairs <span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>. Passing a list with
lower triangular indices will raise an error.</p></li>
<li><p><strong>alpha_beta_indices</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Allowed indices for nonzero values of the “alpha-beta”
diagonal Coulomb matrices (see the docstring of this class).
If not specified, all matrix entries are allowed to be nonzero.
This list should contain only upper trianglular indices, i.e.,
pairs <span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>. Passing a list with
lower triangular indices will raise an error.</p></li>
<li><p><strong>with_final_orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include a final orbital rotation
in the operator.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.RealUCJOperator" title="ffsim.variational.ucj.RealUCJOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">RealUCJOperator</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The real UCJ operator constructed from the given parameters.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – alpha_alpha_indices contains lower triangular indices.</p></li>
<li><p><strong>ValueError</strong> – alpha_beta_indices contains lower triangular indices.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.RealUCJOperator.from_t_amplitudes">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_t_amplitudes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj.html#RealUCJOperator.from_t_amplitudes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.RealUCJOperator.from_t_amplitudes" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the real UCJ operator from t2 (and optionally t1) amplitudes.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.RealUCJOperator" title="ffsim.variational.ucj.RealUCJOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">RealUCJOperator</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.RealUCJOperator.n_params">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_alpha_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_beta_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj.html#RealUCJOperator.n_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.RealUCJOperator.n_params" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of parameters of an ansatz with given settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.RealUCJOperator.n_reps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_reps</span></span><a class="headerlink" href="#ffsim.RealUCJOperator.n_reps" title="Link to this definition">¶</a></dt>
<dd><p>The number of ansatz repetitions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.RealUCJOperator.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.RealUCJOperator.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.RealUCJOperator.to_parameters">
<span class="sig-name descname"><span class="pre">to_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_alpha_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_beta_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj.html#RealUCJOperator.to_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.RealUCJOperator.to_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Convert the real UCJ operator to a real-valued parameter vector.</p>
<p>If <cite>alpha_alpha_indices</cite> or <cite>alpha_beta_indices</cite> is specified, the returned
parameter vector will incorporate only the diagonal Coulomb matrix entries
corresponding to the given indices, so the original operator will not be
recoverable from the parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha_alpha_indices</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Allowed indices for nonzero values of the “alpha-alpha”
diagonal Coulomb matrices (see the docstring of this class).
If not specified, all matrix entries are allowed to be nonzero.
This list should contain only upper trianglular indices, i.e.,
pairs <span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>. Passing a list with
lower triangular indices will raise an error.</p></li>
<li><p><strong>alpha_beta_indices</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Allowed indices for nonzero values of the “alpha-beta”
diagonal Coulomb matrices (see the docstring of this class).
If not specified, all matrix entries are allowed to be nonzero.
This list should contain only upper trianglular indices, i.e.,
pairs <span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>. Passing a list with
lower triangular indices will raise an error.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The real-valued parameter vector.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – alpha_alpha_indices contains lower triangular indices.</p></li>
<li><p><strong>ValueError</strong> – alpha_beta_indices contains lower triangular indices.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.RealUCJOperator.to_t_amplitudes">
<span class="sig-name descname"><span class="pre">to_t_amplitudes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nocc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj.html#RealUCJOperator.to_t_amplitudes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.RealUCJOperator.to_t_amplitudes" title="Link to this definition">¶</a></dt>
<dd><p>Convert the UCJ operator to t2 (and possibly t1) amplitudes.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">SingleFactorizedHamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">one_body_squares</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/single_factorized_hamiltonian.html#SingleFactorizedHamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A Hamiltonian in the single-factorized representation.</p>
<p>The single-factorized form of the molecular Hamiltonian is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = \sum_{\sigma, pq} \kappa_{pq} a^\dagger_{\sigma, p} a_{\sigma, q}
+ \frac12 \sum_{t=1}^L \left(\mathcal{M}^{(t)}\right)^2
+ \text{constant}'.\]</div>
</div>
<p>Here each <span class="math notranslate nohighlight">\(\mathcal{M}^{(t)}\)</span> is a one-body operator:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{M}^{(t)} =
\sum_{\sigma, pq} M^{(t)}_{pq} a^\dagger_{\sigma, p} a_{\sigma, q}\]</div>
</div>
<p>where each <span class="math notranslate nohighlight">\(M^{(t)}\)</span> is a Hermitian matrix.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian.one_body_tensor">
<span class="sig-name descname"><span class="pre">one_body_tensor</span></span><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian.one_body_tensor" title="Link to this definition">¶</a></dt>
<dd><p>The one-body tensor <span class="math notranslate nohighlight">\(\kappa\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian.one_body_squares">
<span class="sig-name descname"><span class="pre">one_body_squares</span></span><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian.one_body_squares" title="Link to this definition">¶</a></dt>
<dd><p>The one-body tensors <span class="math notranslate nohighlight">\(M^{(t)}\)</span> whose
squares are summed in the Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian.constant">
<span class="sig-name descname"><span class="pre">constant</span></span><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian.constant" title="Link to this definition">¶</a></dt>
<dd><p>The constant.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian.expectation_product_state">
<span class="sig-name descname"><span class="pre">expectation_product_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/single_factorized_hamiltonian.html#SingleFactorizedHamiltonian.expectation_product_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian.expectation_product_state" title="Link to this definition">¶</a></dt>
<dd><p>Return expectation value with respect to a product state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</span>) – The product state, as a pair <cite>(vec_a, vec_b)</cite> containing the alpha and
beta components of the state.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian.from_molecular_hamiltonian">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_molecular_hamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_vecs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cholesky</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/single_factorized_hamiltonian.html#SingleFactorizedHamiltonian.from_molecular_hamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian.from_molecular_hamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Initialize a SingleFactorizedHamiltonian from a MolecularHamiltonian.</p>
<p>The number of terms in the decomposition depends on the allowed
error threshold. A larger error threshold leads to a smaller number of terms.
Furthermore, the <cite>max_vecs</cite> parameter specifies an optional upper bound
on the number of terms.</p>
<p>Note: Currently, only real-valued two-body tensors are supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hamiltonian</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.MolecularHamiltonian" title="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a></span>) – The Hamiltonian whose single-factorized representation to
compute.</p></li>
<li><p><strong>tol</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – Tolerance for error in the decomposition.
The error is defined as the maximum absolute difference between
an element of the original tensor and the corresponding element of
the reconstructed tensor.</p></li>
<li><p><strong>max_vecs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – An optional limit on the number of terms to keep in the
decomposition of the two-body tensor. This argument overrides <code class="docutils literal notranslate"><span class="pre">tol</span></code>.</p></li>
<li><p><strong>cholesky</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to perform the factorization using a modified Cholesky
decomposition. If False, a full eigenvalue decomposition is used
instead, which can be much more expensive.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian" title="ffsim.hamiltonians.single_factorized_hamiltonian.SingleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The single-factorized Hamiltonian.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian.reduced_matrix_product_states">
<span class="sig-name descname"><span class="pre">reduced_matrix_product_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vecs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/single_factorized_hamiltonian.html#SingleFactorizedHamiltonian.reduced_matrix_product_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian.reduced_matrix_product_states" title="Link to this definition">¶</a></dt>
<dd><p>Return reduced matrix within a subspace spanned by some product states.</p>
<p>Given a list of product states <span class="math notranslate nohighlight">\(\{\lvert \alpha_i, \beta_i \rangle\}\)</span>,
returns the matrix M where
<span class="math notranslate nohighlight">\(M_{ij} = \langle \alpha_i, \beta_i \rvert
H \lvert \alpha_j, \beta_j \rangle\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vecs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]]</span>) – The product states, as a list of pairs <cite>(vec_a, vec_b)</cite> containing
the alpha and beta components of each state.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The reduced matrix.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.Spin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">Spin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names=&lt;not</span> <span class="pre">given&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">module=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qualname=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary=None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/spin.html#Spin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.Spin" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Flag</span></code></p>
<p>Enumeration for indicating alpha, beta, or both spins.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.Spin.ALPHA">
<span class="sig-name descname"><span class="pre">ALPHA</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#ffsim.Spin.ALPHA" title="Link to this definition">¶</a></dt>
<dd><p>Use this to indicate spin alpha.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.Spin.ALPHA_AND_BETA">
<span class="sig-name descname"><span class="pre">ALPHA_AND_BETA</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#ffsim.Spin.ALPHA_AND_BETA" title="Link to this definition">¶</a></dt>
<dd><p>Use this to indicate both spin alpha and spin beta.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.Spin.BETA">
<span class="sig-name descname"><span class="pre">BETA</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#ffsim.Spin.BETA" title="Link to this definition">¶</a></dt>
<dd><p>Use this to indicate spin beta.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.SupportsApplyUnitary">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">SupportsApplyUnitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/apply_unitary_protocol.html#SupportsApplyUnitary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SupportsApplyUnitary" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></p>
<p>An object that can apply a unitary transformation to a vector.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.SupportsApproximateEquality">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">SupportsApproximateEquality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/approximate_equality_protocol.html#SupportsApproximateEquality"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SupportsApproximateEquality" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></p>
<p>An object that can be compared approximately.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.SupportsDiagonal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">SupportsDiagonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/diagonal_protocol.html#SupportsDiagonal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SupportsDiagonal" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></p>
<p>A linear operator whose diagonal entries can be returned.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.SupportsFermionOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">SupportsFermionOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/fermion_operator_protocol.html#SupportsFermionOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SupportsFermionOperator" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></p>
<p>An object that can be converted to a FermionOperator.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.SupportsLinearOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">SupportsLinearOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/linear_operator_protocol.html#SupportsLinearOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SupportsLinearOperator" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></p>
<p>An object that can be converted to a SciPy LinearOperator.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.SupportsTrace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">SupportsTrace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/trace_protocol.html#SupportsTrace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SupportsTrace" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></p>
<p>A linear operator whose trace can be computed.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.UCJOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">UCJOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag_coulomb_mats_alpha_alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag_coulomb_mats_alpha_beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj.html#UCJOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOperator" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A unitary cluster Jastrow operator.</p>
<p>A unitary cluster Jastrow (UCJ) operator has the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\prod_{k = 1}^L \mathcal{W}_k e^{i \mathcal{J}_k} \mathcal{W}_k^\dagger\]</div>
</div>
<p>where each <span class="math notranslate nohighlight">\(\mathcal{W_k}\)</span> is an orbital rotation and each <span class="math notranslate nohighlight">\(\mathcal{J}\)</span>
is a diagonal Coulomb operator of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{J} = \frac12\sum_{\sigma \tau, ij}
\mathbf{J}^{\sigma \tau}_{ij} n_{\sigma, i} n_{\tau, j}.\]</div>
</div>
<p>In order that the operator commutes with the total spin Z operator, we enforce that
<span class="math notranslate nohighlight">\(\mathbf{J}^{\alpha\alpha} = \mathbf{J}^{\beta\beta}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{J}^{\alpha\beta} = \mathbf{J}^{\beta\alpha}\)</span>. As a result, we have
two sets of matrices for describing the diagonal Coulomb operators:
“alpha-alpha” matrices containing coefficients for terms involving the same spin,
and “alpha-beta” matrices containing coefficients for terms involving different
spins.</p>
<p>To support variational optimization of the orbital basis, an optional final
orbital rotation can be included in the operator, to be performed at the end.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.UCJOperator.diag_coulomb_mats_alpha_alpha">
<span class="sig-name descname"><span class="pre">diag_coulomb_mats_alpha_alpha</span></span><a class="headerlink" href="#ffsim.UCJOperator.diag_coulomb_mats_alpha_alpha" title="Link to this definition">¶</a></dt>
<dd><p>The “alpha-alpha” diagonal Coulomb
matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.UCJOperator.diag_coulomb_mats_alpha_beta">
<span class="sig-name descname"><span class="pre">diag_coulomb_mats_alpha_beta</span></span><a class="headerlink" href="#ffsim.UCJOperator.diag_coulomb_mats_alpha_beta" title="Link to this definition">¶</a></dt>
<dd><p>The “alpha-beta” diagonal Coulomb
matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.UCJOperator.orbital_rotations">
<span class="sig-name descname"><span class="pre">orbital_rotations</span></span><a class="headerlink" href="#ffsim.UCJOperator.orbital_rotations" title="Link to this definition">¶</a></dt>
<dd><p>The orbital rotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.UCJOperator.final_orbital_rotation">
<span class="sig-name descname"><span class="pre">final_orbital_rotation</span></span><a class="headerlink" href="#ffsim.UCJOperator.final_orbital_rotation" title="Link to this definition">¶</a></dt>
<dd><p>The optional final orbital rotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOperator.from_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_alpha_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_beta_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj.html#UCJOperator.from_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOperator.from_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the UCJ operator from a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The real-valued parameter vector.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>n_reps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of ansatz repetitions (<span class="math notranslate nohighlight">\(L\)</span> from the docstring of
this class).</p></li>
<li><p><strong>alpha_alpha_indices</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Allowed indices for nonzero values of the “alpha-alpha”
diagonal Coulomb matrices (see the docstring of this class).
If not specified, all matrix entries are allowed to be nonzero.
This list should contain only upper trianglular indices, i.e.,
pairs <span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>. Passing a list with
lower triangular indices will raise an error.</p></li>
<li><p><strong>alpha_beta_indices</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Allowed indices for nonzero values of the “alpha-beta”
diagonal Coulomb matrices (see the docstring of this class).
If not specified, all matrix entries are allowed to be nonzero.
This list should contain only upper trianglular indices, i.e.,
pairs <span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>. Passing a list with
lower triangular indices will raise an error.</p></li>
<li><p><strong>with_final_orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include a final orbital rotation
in the operator.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.UCJOperator" title="ffsim.variational.ucj.UCJOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">UCJOperator</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The UCJ operator constructed from the given parameters.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – alpha_alpha_indices contains lower triangular indices.</p></li>
<li><p><strong>ValueError</strong> – alpha_beta_indices contains lower triangular indices.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOperator.from_t_amplitudes">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_t_amplitudes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj.html#UCJOperator.from_t_amplitudes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOperator.from_t_amplitudes" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the UCJ operator from t2 (and optionally t1) amplitudes.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.UCJOperator" title="ffsim.variational.ucj.UCJOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">UCJOperator</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOperator.n_params">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_alpha_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_beta_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj.html#UCJOperator.n_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOperator.n_params" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of parameters of an ansatz with given settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.UCJOperator.n_reps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_reps</span></span><a class="headerlink" href="#ffsim.UCJOperator.n_reps" title="Link to this definition">¶</a></dt>
<dd><p>The number of ansatz repetitions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.UCJOperator.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.UCJOperator.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOperator.to_parameters">
<span class="sig-name descname"><span class="pre">to_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_alpha_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_beta_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj.html#UCJOperator.to_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOperator.to_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Convert the UCJ operator to a real-valued parameter vector.</p>
<p>If <cite>alpha_alpha_indices</cite> or <cite>alpha_beta_indices</cite> is specified, the returned
parameter vector will incorporate only the diagonal Coulomb matrix entries
corresponding to the given indices, so the original operator will not be
recoverable from the parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha_alpha_indices</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Allowed indices for nonzero values of the “alpha-alpha”
diagonal Coulomb matrices (see the docstring of this class).
If not specified, all matrix entries are allowed to be nonzero.
This list should contain only upper trianglular indices, i.e.,
pairs <span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>. Passing a list with
lower triangular indices will raise an error.</p></li>
<li><p><strong>alpha_beta_indices</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Allowed indices for nonzero values of the “alpha-beta”
diagonal Coulomb matrices (see the docstring of this class).
If not specified, all matrix entries are allowed to be nonzero.
This list should contain only upper trianglular indices, i.e.,
pairs <span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>. Passing a list with
lower triangular indices will raise an error.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The real-valued parameter vector.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – alpha_alpha_indices contains lower triangular indices.</p></li>
<li><p><strong>ValueError</strong> – alpha_beta_indices contains lower triangular indices.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOperator.to_t_amplitudes">
<span class="sig-name descname"><span class="pre">to_t_amplitudes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nocc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj.html#UCJOperator.to_t_amplitudes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOperator.to_t_amplitudes" title="Link to this definition">¶</a></dt>
<dd><p>Convert the UCJ operator to t2 (and possibly t1) amplitudes.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_diag_coulomb_evolution">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_diag_coulomb_evolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_representation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/diag_coulomb.html#apply_diag_coulomb_evolution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_diag_coulomb_evolution" title="Link to this definition">¶</a></dt>
<dd><p>Apply time evolution by a (rotated) diagonal Coulomb operator.</p>
<p>Applies</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{U}
\exp\left(-i t \sum_{\sigma, \tau, i, j}
Z^{(\sigma \tau)}_{ij} n_{\sigma, i} n_{\tau, j} / 2\right)
\mathcal{U}^\dagger\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(n_{\sigma, i}\)</span> denotes the number operator on orbital <span class="math notranslate nohighlight">\(i\)</span>
with spin <span class="math notranslate nohighlight">\(\sigma\)</span>, <span class="math notranslate nohighlight">\(Z^{(\sigma \tau)}\)</span> is a real symmetric matrix,
and <span class="math notranslate nohighlight">\(\mathcal{U}\)</span> is an optional orbital rotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>mat</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]</span>) – The real symmetric matrix <span class="math notranslate nohighlight">\(Z\)</span>.
You can pass either a single Numpy array specifying the coefficients
to use for all spin interactions, or you can pass a tuple of three Numpy
arrays specifying independent coefficients for alpha-alpha, alpha-beta,
and beta-beta interactions (in that order). If passing a tuple, you can
set a tuple element to <code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate the absence of interactions
of that type.</p></li>
<li><p><strong>time</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The evolution time.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The optional orbital rotation.
You can pass either a single Numpy array specifying the orbital rotation
to apply to both spin sectors, or you can pass a pair of Numpy arrays
specifying independent orbital rotations for spin alpha and spin beta.
If passing a pair, you can use <code class="docutils literal notranslate"><span class="pre">None</span></code> for one of the
values in the pair to indicate that no operation should be applied to that
spin sector.</p></li>
<li><p><strong>z_representation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether the input matrices are in the “Z” representation.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The evolved state vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_fsim_gate">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_fsim_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orbs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_fsim_gate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_fsim_gate" title="Link to this definition">¶</a></dt>
<dd><p>Apply an fSim gate.</p>
<p>An fSim gate consists of a tunneling interaction followed by a number-number
interaction (note the negative sign convention for the angles):</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    \text{fSim}&amp;(\theta, \phi, (p, q))
    = \text{NN}(-\phi, (p, q)) \text{T}(-\theta, (p, q)) \\
    &amp;= \prod_\sigma
    \exp\left(-i \phi a^\dagger_{\sigma, p} a_{\sigma, p}
    a^\dagger_{\sigma, q} a_{\sigma, q}\right)
    \exp\left(-i \theta (a^\dagger_{\sigma, p} a_{\sigma, q}
    + a^\dagger_{\sigma, q} a_{\sigma, p})\right)
\end{align}\end{split}\]</div>
</div>
<p>Under the Jordan-Wigner transform, this gate has the following matrix when applied
to neighboring qubits:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \cos(\theta) &amp; -i \sin(\theta) &amp; 0\\
    0 &amp; -i \sin(\theta) &amp; \cos(\theta) &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; e^{-i \phi} \\
\end{pmatrix}\end{split}\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle for the tunneling interaction.</p></li>
<li><p><strong>phi</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The phase angle for the number-number interaction.</p></li>
<li><p><strong>target_orbs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The orbitals (p, q) to interact.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – <p>Choice of spin sector(s) to act on.</p>
<ul>
<li><p>To act on only spin alpha, pass <a class="reference internal" href="#ffsim.Spin.ALPHA" title="ffsim.Spin.ALPHA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA</span></code></a>.</p></li>
<li><p>To act on only spin beta, pass <a class="reference internal" href="#ffsim.Spin.BETA" title="ffsim.Spin.BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.BETA</span></code></a>.</p></li>
<li><p>To act on both spin alpha and spin beta, pass
<a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA" title="ffsim.Spin.ALPHA_AND_BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA_AND_BETA</span></code></a> (this is the default value).</p></li>
</ul>
</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_givens_rotation">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_givens_rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orbs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_givens_rotation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_givens_rotation" title="Link to this definition">¶</a></dt>
<dd><p>Apply a Givens rotation gate.</p>
<p>The Givens rotation gate is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{G}(\theta, (p, q)) = \prod_{\sigma}
\exp\left(\theta (a^\dagger_{\sigma, p} a_{\sigma, q}
- a^\dagger_{\sigma, q} a_{\sigma, p})\right)\]</div>
</div>
<p>Under the Jordan-Wigner transform, this gate has the following matrix when applied
to neighboring qubits:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \cos(\theta) &amp; -\sin(\theta) &amp; 0\\
    0 &amp; \sin(\theta) &amp; \cos(\theta) &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1 \\
\end{pmatrix}\end{split}\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle.</p></li>
<li><p><strong>target_orbs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The orbitals (p, q) to rotate.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – <p>Choice of spin sector(s) to act on.</p>
<ul>
<li><p>To act on only spin alpha, pass <a class="reference internal" href="#ffsim.Spin.ALPHA" title="ffsim.Spin.ALPHA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA</span></code></a>.</p></li>
<li><p>To act on only spin beta, pass <a class="reference internal" href="#ffsim.Spin.BETA" title="ffsim.Spin.BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.BETA</span></code></a>.</p></li>
<li><p>To act on both spin alpha and spin beta, pass
<a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA" title="ffsim.Spin.ALPHA_AND_BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA_AND_BETA</span></code></a> (this is the default value).</p></li>
</ul>
</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_hop_gate">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_hop_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orbs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_hop_gate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_hop_gate" title="Link to this definition">¶</a></dt>
<dd><p>Apply a hop gate.</p>
<p>A “hop gate” is a Givens rotation gate followed by a number-number interaction with
angle pi:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    \text{Hop}&amp;(\theta, (p, q))
    = \text{NN}(\pi, (p, q)) \text{G}(\theta, (p, q)) \\
    &amp;= \prod_{\sigma}
    \exp\left(i \theta a^\dagger_{\sigma, p} a_{\sigma, p}
    a^\dagger_{\sigma, q} a_{\sigma, q}\right)
    \exp\left(\theta (a^\dagger_{\sigma, p} a_{\sigma, q}
    - a^\dagger_{\sigma, q} a_{\sigma, p})\right)
\end{align}\end{split}\]</div>
</div>
<p>Under the Jordan-Wigner transform, this gate has the following matrix when applied
to neighboring qubits:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \cos(\theta) &amp; -\sin(\theta) &amp; 0\\
    0 &amp; \sin(\theta) &amp; \cos(\theta) &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; -1 \\
\end{pmatrix}\end{split}\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle.</p></li>
<li><p><strong>target_orbs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The orbitals (p, q) to interact.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – <p>Choice of spin sector(s) to act on.</p>
<ul>
<li><p>To act on only spin alpha, pass <a class="reference internal" href="#ffsim.Spin.ALPHA" title="ffsim.Spin.ALPHA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA</span></code></a>.</p></li>
<li><p>To act on only spin beta, pass <a class="reference internal" href="#ffsim.Spin.BETA" title="ffsim.Spin.BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.BETA</span></code></a>.</p></li>
<li><p>To act on both spin alpha and spin beta, pass
<a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA" title="ffsim.Spin.ALPHA_AND_BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA_AND_BETA</span></code></a> (this is the default value).</p></li>
</ul>
</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_num_interaction">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_num_interaction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_num_interaction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_num_interaction" title="Link to this definition">¶</a></dt>
<dd><p>Apply a number interaction gate.</p>
<p>The number interaction gate is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{N}(\theta, p) = \prod_{\sigma}
\exp\left(i \theta a^\dagger_{\sigma, p} a_{\sigma, p}\right)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle.</p></li>
<li><p><strong>target_orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The orbital on which to apply the interaction.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – <p>Choice of spin sector(s) to act on.</p>
<ul>
<li><p>To act on only spin alpha, pass <a class="reference internal" href="#ffsim.Spin.ALPHA" title="ffsim.Spin.ALPHA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA</span></code></a>.</p></li>
<li><p>To act on only spin beta, pass <a class="reference internal" href="#ffsim.Spin.BETA" title="ffsim.Spin.BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.BETA</span></code></a>.</p></li>
<li><p>To act on both spin alpha and spin beta, pass
<a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA" title="ffsim.Spin.ALPHA_AND_BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA_AND_BETA</span></code></a> (this is the default value).</p></li>
</ul>
</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_num_num_interaction">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_num_num_interaction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orbs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_num_num_interaction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_num_num_interaction" title="Link to this definition">¶</a></dt>
<dd><p>Apply a number-number interaction gate.</p>
<p>The number-number interaction gate is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{NN}(\theta, (p, q)) = \prod_{\sigma}
\exp\left(i \theta a^\dagger_{\sigma, p} a_{\sigma, p}
a^\dagger_{\sigma, q} a_{\sigma, q}\right)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle.</p></li>
<li><p><strong>target_orbs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The orbitals (p, q) to interact.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – <p>Choice of spin sector(s) to act on.</p>
<ul>
<li><p>To act on only spin alpha, pass <a class="reference internal" href="#ffsim.Spin.ALPHA" title="ffsim.Spin.ALPHA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA</span></code></a>.</p></li>
<li><p>To act on only spin beta, pass <a class="reference internal" href="#ffsim.Spin.BETA" title="ffsim.Spin.BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.BETA</span></code></a>.</p></li>
<li><p>To act on both spin alpha and spin beta, pass
<a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA" title="ffsim.Spin.ALPHA_AND_BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA_AND_BETA</span></code></a> (this is the default value).</p></li>
</ul>
</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_num_op_prod_interaction">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_num_op_prod_interaction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orbs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_num_op_prod_interaction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_num_op_prod_interaction" title="Link to this definition">¶</a></dt>
<dd><p>Apply interaction gate for product of number operators.</p>
<p>The gate is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{NP}(\theta, (S_\alpha, S_\beta)) =
\exp\left(i \theta
\prod_{p \in S_\alpha} a^\dagger_{\alpha, p} a_{\alpha, p}
\prod_{p \in S_\beta} a^\dagger_{\beta, p} a_{\beta, p}
\right)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle.</p></li>
<li><p><strong>target_orbs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – A pair of lists of integers giving the orbitals on which to apply
the interaction. The first list specifies the alpha orbitals and the second
list specifies the beta orbitals.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_num_op_sum_evolution">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_num_op_sum_evolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/num_op_sum.html#apply_num_op_sum_evolution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_num_op_sum_evolution" title="Link to this definition">¶</a></dt>
<dd><p>Apply time evolution by a (rotated) linear combination of number operators.</p>
<p>Applies</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{U}
\exp\left(-i t \sum_{\sigma, i} \lambda^{(\sigma)}_i n_{\sigma, i}\right)
\mathcal{U}^\dagger\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(n_{\sigma, i}\)</span> denotes the number operator on orbital <span class="math notranslate nohighlight">\(i\)</span>
with spin <span class="math notranslate nohighlight">\(\sigma\)</span>, the <span class="math notranslate nohighlight">\(\lambda_i\)</span> are real numbers, and
<span class="math notranslate nohighlight">\(\mathcal{U}\)</span> is an optional orbital rotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>coeffs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]</span>) – The coefficients of the linear combination.
You can pass either a single Numpy array specifying the coefficients
to apply to both spin sectors, or you can pass a pair of Numpy arrays
specifying independent coefficients for spin alpha and spin beta.
If passing a pair, you can use <code class="docutils literal notranslate"><span class="pre">None</span></code> for one of the
values in the pair to indicate that no operation should be applied to that
spin sector.</p></li>
<li><p><strong>time</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The evolution time.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The optional orbital rotation.
You can pass either a single Numpy array specifying the orbital rotation
to apply to both spin sectors, or you can pass a pair of Numpy arrays
specifying independent orbital rotations for spin alpha and spin beta.
If passing a pair, you can use <code class="docutils literal notranslate"><span class="pre">None</span></code> for one of the
values in the pair to indicate that no operation should be applied to that
spin sector.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The evolved state vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_on_site_interaction">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_on_site_interaction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_on_site_interaction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_on_site_interaction" title="Link to this definition">¶</a></dt>
<dd><p>Apply an on-site interaction gate.</p>
<p>The on-site interaction gate is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{OS}(\theta, p) =
\exp\left(i \theta a^\dagger_{\alpha, p} a_{\alpha, p}
a^\dagger_{\beta, p} a_{\beta, p}\right)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle.</p></li>
<li><p><strong>target_orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The orbital on which to apply the interaction.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_orbital_rotation">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_orbital_rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/orbital_rotation.html#apply_orbital_rotation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_orbital_rotation" title="Link to this definition">¶</a></dt>
<dd><p>Apply an orbital rotation to a vector.</p>
<p>An orbital rotation maps creation operators as</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[a^\dagger_{\sigma, i} \mapsto \sum_{j} U^{(\sigma)}_{ji} a^\dagger_{\sigma, j}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(U^{(\sigma)}\)</span> is a unitary matrix representing the action of the
orbital rotation on spin sector <span class="math notranslate nohighlight">\(\sigma\)</span>.
This is equivalent to applying the transformation given by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\prod_{\sigma}
\exp\left(\sum_{ij}
\log(U^{(\sigma)})_{ij} a^\dagger_{\sigma, i} a_{\sigma, j}\right)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>mat</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]</span>) – The unitary matrix <span class="math notranslate nohighlight">\(U\)</span> describing the orbital rotation.
You can pass either a single Numpy array specifying the orbital rotation
to apply to both spin sectors, or you can pass a pair of Numpy arrays
specifying independent orbital rotations for spin alpha and spin beta.
If passing a pair, you can use <code class="docutils literal notranslate"><span class="pre">None</span></code> for one of the
values in the pair to indicate that no operation should be applied to
that spin sector.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The transformed vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_tunneling_interaction">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_tunneling_interaction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orbs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_tunneling_interaction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_tunneling_interaction" title="Link to this definition">¶</a></dt>
<dd><p>Apply a tunneling interaction gate.</p>
<p>The tunneling interaction gate is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{T}(\theta, (p, q)) = \prod_\sigma
\exp\left(i \theta (a^\dagger_{\sigma, p} a_{\sigma, q}
+ a^\dagger_{\sigma, q} a_{\sigma, p})\right)\]</div>
</div>
<p>Under the Jordan-Wigner transform, this gate has the following matrix when applied
to neighboring qubits:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \cos(\theta) &amp; i \sin(\theta) &amp; 0\\
    0 &amp; i \sin(\theta) &amp; \cos(\theta) &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1 \\
\end{pmatrix}\end{split}\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle.</p></li>
<li><p><strong>target_orbs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The orbitals (p, q) on which to apply the interaction.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – <p>Choice of spin sector(s) to act on.</p>
<ul>
<li><p>To act on only spin alpha, pass <a class="reference internal" href="#ffsim.Spin.ALPHA" title="ffsim.Spin.ALPHA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA</span></code></a>.</p></li>
<li><p>To act on only spin beta, pass <a class="reference internal" href="#ffsim.Spin.BETA" title="ffsim.Spin.BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.BETA</span></code></a>.</p></li>
<li><p>To act on both spin alpha and spin beta, pass
<a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA" title="ffsim.Spin.ALPHA_AND_BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA_AND_BETA</span></code></a> (this is the default value).</p></li>
</ul>
</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_unitary">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/apply_unitary_protocol.html#apply_unitary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_unitary" title="Link to this definition">¶</a></dt>
<dd><p>Apply a unitary transformation to a vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The vector to apply the unitary transformation to.</p></li>
<li><p><strong>obj</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></span>) – The object with a unitary effect.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The transformed vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.approx_eq">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">approx_eq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/approximate_equality_protocol.html#approx_eq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.approx_eq" title="Link to this definition">¶</a></dt>
<dd><p>Return whether two objects are approximately equal.</p>
<p>See the documentation of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.isclose.html">np.isclose</a> for the interpretation of the tolerance
parameters <code class="docutils literal notranslate"><span class="pre">rtol</span></code> and <code class="docutils literal notranslate"><span class="pre">atol</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></span>) – The first object.</p></li>
<li><p><strong>other</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></span>) – The object to compare to.</p></li>
<li><p><strong>rtol</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – Relative numerical tolerance.</p></li>
<li><p><strong>atol</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – Absolute numerical tolerance.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the objects are approximately equal up to the specified tolerance,
and False otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.cre">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">cre</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermion_action.html#cre"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.cre" title="Link to this definition">¶</a></dt>
<dd><p>Create a fermion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – The spin of the orbital. False = alpha, True = beta.</p></li>
<li><p><strong>orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the orbital to act on.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionAction" title="ffsim.operators.fermion_action.FermionAction"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionAction</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.cre_a">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">cre_a</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermion_action.html#cre_a"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.cre_a" title="Link to this definition">¶</a></dt>
<dd><p>Create a fermion with spin alpha.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the orbital to act on.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionAction" title="ffsim.operators.fermion_action.FermionAction"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionAction</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.cre_b">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">cre_b</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermion_action.html#cre_b"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.cre_b" title="Link to this definition">¶</a></dt>
<dd><p>Create a fermion with spin beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the orbital to act on.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionAction" title="ffsim.operators.fermion_action.FermionAction"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionAction</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.des">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">des</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermion_action.html#des"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.des" title="Link to this definition">¶</a></dt>
<dd><p>Destroy a fermion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – The spin of the orbital. False = alpha, True = beta.</p></li>
<li><p><strong>orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the orbital to act on.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionAction" title="ffsim.operators.fermion_action.FermionAction"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionAction</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.des_a">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">des_a</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermion_action.html#des_a"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.des_a" title="Link to this definition">¶</a></dt>
<dd><p>Destroy a fermion with spin alpha.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the orbital to act on.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionAction" title="ffsim.operators.fermion_action.FermionAction"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionAction</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.des_b">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">des_b</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermion_action.html#des_b"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.des_b" title="Link to this definition">¶</a></dt>
<dd><p>Destroy a fermion with spin beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the orbital to act on.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionAction" title="ffsim.operators.fermion_action.FermionAction"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionAction</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.diag">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">diag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/diagonal_protocol.html#diag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.diag" title="Link to this definition">¶</a></dt>
<dd><p>Return the diagonal entries of the linear operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.dim">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">dim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/states.html#dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.dim" title="Link to this definition">¶</a></dt>
<dd><p>Get the dimension of the FCI space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The dimension of the FCI space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.dims">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">dims</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/states.html#dims"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.dims" title="Link to this definition">¶</a></dt>
<dd><p>Get the dimensions of the FCI space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A pair of integers (dim_a, dim_b) representing the dimensions of the
alpha- and beta- FCI space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.expectation_one_body_power">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">expectation_one_body_power</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_rdm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">one_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/wick.html#expectation_one_body_power"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.expectation_one_body_power" title="Link to this definition">¶</a></dt>
<dd><p>Expectation of power of one-body operator w.r.t. a Slater determinant.</p>
<p>A one-body operator <span class="math notranslate nohighlight">\(O\)</span> has the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[O = \sum_{pq} M_{pq} a_p^\dagger a_q.\]</div>
</div>
<p>This function takes the matrix <span class="math notranslate nohighlight">\(M\)</span> as its first argument.
Let <span class="math notranslate nohighlight">\(\lvert \psi \rangle\)</span> be the Slater determinant.
Then this function returns the quantity</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\langle \psi \rvert O^k \lvert \psi \rangle.\]</div>
</div>
<dl class="simple">
<dt>Note: Unlike most functions in ffsim, the inputs to this function are specified</dt><dd><p>in terms of spin-orbitals, not spatial orbitals. In other words, the one-rdm
and the one-body tensors should have the same shape, and all orbitals are
treated on an equal footing. The 1-RDM passed here should not be spin-summed,
and the one-body tensors should be expanded when compared to the usual
one-body tensors elsewhere in ffsim, i.e.,
<cite>scipy.linalg.block_diag(one_body_tensor, one_body_tensor)</cite>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>one_rdm</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The one-body reduced density matrix of the Slater determinant.</p></li>
<li><p><strong>one_body_tensor</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The one-body operator.</p></li>
<li><p><strong>power</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The power.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The expectation value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.expectation_one_body_product">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">expectation_one_body_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_rdm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">one_body_tensors</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/wick.html#expectation_one_body_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.expectation_one_body_product" title="Link to this definition">¶</a></dt>
<dd><p>Expectation of product of one-body operators w.r.t. a Slater determinant.</p>
<p>A one-body operator <span class="math notranslate nohighlight">\(O\)</span> has the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[O = \sum_{pq} M_{pq} a_p^\dagger a_q.\]</div>
</div>
<p>This function takes a list of the matrices <span class="math notranslate nohighlight">\(M\)</span> as its first argument.
Let <span class="math notranslate nohighlight">\((O_1, O_2, \dots O_k)\)</span> be the list of one-body operators,
and <span class="math notranslate nohighlight">\(\lvert \psi \rangle\)</span> be the Slater determinant.
Then this function returns the quantity</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\langle \psi \rvert O_1 O_2 \dots O_k \lvert \psi \rangle.\]</div>
</div>
<dl class="simple">
<dt>Note: Unlike most functions in ffsim, the inputs to this function are specified</dt><dd><p>in terms of spin-orbitals, not spatial orbitals. In other words, the one-rdm
and the one-body tensors should have the same shape, and all orbitals are
treated on an equal footing. The 1-RDM passed here should not be spin-summed,
and the one-body tensors should be expanded when compared to the usual
one-body tensors elsewhere in ffsim, i.e.,
<cite>scipy.linalg.block_diag(one_body_tensor, one_body_tensor)</cite>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>one_rdm</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The one-body reduced density matrix of the Slater determinant.</p></li>
<li><p><strong>one_body_tensors</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</span>) – The matrices for the one-body operators.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The expectation value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.fermi_hubbard_1d">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">fermi_hubbard_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tunneling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chemical_potential</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nearest_neighbor_interaction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">periodic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermi_hubbard.html#fermi_hubbard_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.fermi_hubbard_1d" title="Link to this definition">¶</a></dt>
<dd><p>One-dimensional Fermi-Hubbard model Hamiltonian.</p>
<p>The Hamiltonian for the one-dimensional Fermi-Hubbard model with <span class="math notranslate nohighlight">\(N\)</span> spatial
orbitals is given by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = -t \sum_{\sigma} \sum_{p=1}^{N-1}
(a^\dagger_{\sigma, p} a_{\sigma, p+1} + \text{h.c.})
+ U \sum_{p=1}^{N} n_{\alpha, p} n_{\beta, p}
- \mu \sum_{p=1}^N (n_{\alpha, p} + n_{\beta, p})
+ V \sum_{\sigma, \sigma'} \sum_{p=1}^{N-1} n_{\sigma, p} n_{\sigma', p+1}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(n_{\sigma, p} = a_{\sigma, p}^\dagger a_{\sigma, p}\)</span> is the number
operator on orbital <span class="math notranslate nohighlight">\(p\)</span> with spin <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1146/annurev-conmatphys-031620-102024">The Hubbard Model</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals <span class="math notranslate nohighlight">\(N\)</span>.</p></li>
<li><p><strong>tunneling</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The tunneling amplitude <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
<li><p><strong>interaction</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The onsite interaction strength <span class="math notranslate nohighlight">\(U\)</span>.</p></li>
<li><p><strong>chemical_potential</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The chemical potential <span class="math notranslate nohighlight">\(\mu\)</span>.</p></li>
<li><p><strong>nearest_neighbor_interaction</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The nearest-neighbor interaction strength
<span class="math notranslate nohighlight">\(V\)</span>.</p></li>
<li><p><strong>periodic</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to use periodic boundary conditions.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionOperator" title="ffsim.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The one-dimensional Fermi-Hubbard model Hamiltonian.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.fermi_hubbard_2d">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">fermi_hubbard_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tunneling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chemical_potential</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nearest_neighbor_interaction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">periodic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermi_hubbard.html#fermi_hubbard_2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.fermi_hubbard_2d" title="Link to this definition">¶</a></dt>
<dd><p>Two-dimensional Fermi-Hubbard model Hamiltonian.</p>
<p>The Hamiltonian for the two-dimensional Fermi-Hubbard model on a square lattice with
<span class="math notranslate nohighlight">\(N = N_x \times N_y\)</span> spatial orbitals is given by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = -t \sum_{\sigma} \sum_{\braket{pq}}
(a^\dagger_{\sigma, p} a_{\sigma, q} + \text{h.c.})
+ U \sum_{p=1}^{N} n_{\alpha, p} n_{\beta, p}
- \mu \sum_{p=1}^{N} (n_{\alpha, p} + n_{\beta, p})
+ V \sum_{\sigma, \sigma'} \sum_{\braket{pq}} n_{\sigma, p} n_{\sigma', q}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\braket{\dots}\)</span> denotes nearest-neighbor pairs and
<span class="math notranslate nohighlight">\(n_{\sigma, p} = a_{\sigma, p}^\dagger a_{\sigma, p}\)</span> is the number operator
on orbital <span class="math notranslate nohighlight">\(p\)</span> with spin <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1146/annurev-conmatphys-031620-102024">The Hubbard Model</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb_x</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals in the x-direction <span class="math notranslate nohighlight">\(N_x\)</span>.</p></li>
<li><p><strong>norb_y</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals in the y-direction <span class="math notranslate nohighlight">\(N_y\)</span>.</p></li>
<li><p><strong>tunneling</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The tunneling amplitude <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
<li><p><strong>interaction</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The onsite interaction strength <span class="math notranslate nohighlight">\(U\)</span>.</p></li>
<li><p><strong>chemical_potential</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The chemical potential <span class="math notranslate nohighlight">\(\mu\)</span>.</p></li>
<li><p><strong>nearest_neighbor_interaction</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The nearest-neighbor interaction strength
<span class="math notranslate nohighlight">\(V\)</span>.</p></li>
<li><p><strong>periodic</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to use periodic boundary conditions.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionOperator" title="ffsim.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The two-dimensional Fermi-Hubbard model Hamiltonian.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.fermion_operator">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">fermion_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/fermion_operator_protocol.html#fermion_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.fermion_operator" title="Link to this definition">¶</a></dt>
<dd><p>Return a FermionOperator representing the object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>obj</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></span>) – The object to convert to a LinearOperator.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionOperator" title="ffsim.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A FermionOperator representing the object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.hartree_fock_state">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">hartree_fock_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/states.html#hartree_fock_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.hartree_fock_state" title="Link to this definition">¶</a></dt>
<dd><p>Return the Hartree-Fock state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The Hartree-Fock state as a statevector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.indices_to_strings">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">indices_to_strings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/states.html#indices_to_strings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.indices_to_strings" title="Link to this definition">¶</a></dt>
<dd><p>Convert statevector indices to bitstrings.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ffsim</span>

<span class="n">norb</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">nelec</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">dim</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">)</span>
<span class="n">ffsim</span><span class="o">.</span><span class="n">indices_to_strings</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">)</span>
<span class="c1"># output:</span>
<span class="c1"># [&#39;001011&#39;,</span>
<span class="c1">#  &#39;010011&#39;,</span>
<span class="c1">#  &#39;100011&#39;,</span>
<span class="c1">#  &#39;001101&#39;,</span>
<span class="c1">#  &#39;010101&#39;,</span>
<span class="c1">#  &#39;100101&#39;,</span>
<span class="c1">#  &#39;001110&#39;,</span>
<span class="c1">#  &#39;010110&#39;,</span>
<span class="c1">#  &#39;100110&#39;]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.init_cache">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">init_cache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/cistring.html#init_cache"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.init_cache" title="Link to this definition">¶</a></dt>
<dd><p>Initialize cached objects.</p>
<p>Call this function to prepare ffsim for performing operations with given values
of <cite>norb</cite> and <cite>nelec</cite>. Typically there is no need to call this function, but it
should be called before benchmarking to avoid counting the cost of initializing
cached lookup tables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linear_operator">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">linear_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/linear_operator_protocol.html#linear_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linear_operator" title="Link to this definition">¶</a></dt>
<dd><p>Return a SciPy LinearOperator representing the object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></span>) – The object to convert to a LinearOperator.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearOperator</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A Scipy LinearOperator representing the object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.multireference_state">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">multireference_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ansatz_operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_occupations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/multireference.html#multireference_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.multireference_state" title="Link to this definition">¶</a></dt>
<dd><p>Compute multireference energy and state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hamiltonian</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearOperator</span></code> | <a class="reference internal" href="#ffsim.SupportsLinearOperator" title="ffsim.protocols.linear_operator_protocol.SupportsLinearOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">SupportsLinearOperator</span></code></a></span>) – The Hamiltonian.</p></li>
<li><p><strong>ansatz_operator</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.SupportsApplyUnitary" title="ffsim.protocols.apply_unitary_protocol.SupportsApplyUnitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">SupportsApplyUnitary</span></code></a></span>) – The ansatz operator.</p></li>
<li><p><strong>reference_occupations</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]]</span>) – The orbital occupations of the reference states.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>root</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the desired eigenvector. Defaults to 0, which yields the
lowest-energy state.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The energy of the multireference state, and the state itself.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.multireference_state_prod">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">multireference_state_prod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ansatz_operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_occupations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/multireference.html#multireference_state_prod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.multireference_state_prod" title="Link to this definition">¶</a></dt>
<dd><p>Compute multireference state for a product ansatz operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hamiltonian</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.MolecularHamiltonian" title="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a> | <a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian" title="ffsim.hamiltonians.single_factorized_hamiltonian.SingleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian</span></code></a></span>) – The Hamiltonian.</p></li>
<li><p><strong>ansatz_operator</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<a class="reference internal" href="#ffsim.SupportsApplyUnitary" title="ffsim.protocols.apply_unitary_protocol.SupportsApplyUnitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">SupportsApplyUnitary</span></code></a>, <a class="reference internal" href="#ffsim.SupportsApplyUnitary" title="ffsim.protocols.apply_unitary_protocol.SupportsApplyUnitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">SupportsApplyUnitary</span></code></a>]</span>) – The alpha and beta parts of the ansatz operator.</p></li>
<li><p><strong>reference_occupations</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]]</span>) – The orbital occupations of the reference states.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>root</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the desired eigenvector. Defaults to 0, which yields the
lowest-energy state.</p></li>
<li><p><strong>tol</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – Numerical tolerance to use for the single factorization of the molecular
Hamiltonian. If the input is already a SingleFactorizedHamiltonian,
this argument is ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <a class="reference internal" href="#ffsim.ProductStateSum" title="ffsim.states.product_state_sum.ProductStateSum"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProductStateSum</span></code></a>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The energy of the multireference state, and the state itself.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.number_operator">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">number_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/common_operators.html#number_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.number_operator" title="Link to this definition">¶</a></dt>
<dd><p>Occupation number operator.</p>
<p>The occupation number operator for orbital <span class="math notranslate nohighlight">\(p\)</span> is defined as</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[n_p = \sum_\sigma a^\dagger_{\sigma, p} a_{\sigma, p}\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The orbital.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – <p>Choice of spin sector(s) to act on.</p>
<ul>
<li><p>To act on only spin alpha, pass <a class="reference internal" href="#ffsim.Spin.ALPHA" title="ffsim.Spin.ALPHA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA</span></code></a>.</p></li>
<li><p>To act on only spin beta, pass <a class="reference internal" href="#ffsim.Spin.BETA" title="ffsim.Spin.BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.BETA</span></code></a>.</p></li>
<li><p>To act on both spin alpha and spin beta, pass
<a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA" title="ffsim.Spin.ALPHA_AND_BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA_AND_BETA</span></code></a> (this is the default value).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionOperator" title="ffsim.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number operator acting on the specified orbital and spin sector(s).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.one_hot">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">one_hot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'complex'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/states.html#one_hot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.one_hot" title="Link to this definition">¶</a></dt>
<dd><p>Return an array of all zeros except for a one at a specified index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">...</span></code>]</span>) – The desired shape of the array.</p></li>
<li><p><strong>index</strong> – The index at which to place a one.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The one-hot vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.rdm">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">rdm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_summed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reordered</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_lower_ranks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/rdm.html#rdm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.rdm" title="Link to this definition">¶</a></dt>
<dd><p>Return the reduced density matrix (RDM) or matrices of a state vector.</p>
<p>The rank 1 RDM is defined as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>rdm1[p, q] = ⟨p+ q⟩
</pre></div>
</div>
<p>The definition of higher-rank RDMs depends on the <code class="docutils literal notranslate"><span class="pre">reordered</span></code> argument, which
defaults to True.</p>
<p><strong>reordered = True</strong></p>
<p>The reordered RDMs are defined as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>rdm2[p, q, r, s] = ⟨p+ r+ s q⟩
rdm3[p, q, r, s, t, u] = ⟨p+ r+ t+ u s q⟩
rdm4[p, q, r, s, t, u, v, w] = ⟨p+ r+ t+ v+ w u s q⟩
</pre></div>
</div>
<p><strong>reordered = False</strong></p>
<p>If reordered is set to False, the RDMs are defined as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>rdm2[p, q, r, s] = ⟨p+ q r+ s⟩
rdm3[p, q, r, s, t, u] = ⟨p+ q r+ s t+ u⟩
rdm4[p, q, r, s, t, u, v, w] = ⟨p+ q r+ s t+ u v+ w⟩
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, only ranks 1 and 2 are supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector whose reduced density matrix is desired.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>rank</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The rank of the reduced density matrix.</p></li>
<li><p><strong>spin_summed</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to sum over the spin index.</p></li>
<li><p><strong>reordered</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to reorder the indices of the reduced density matrix.</p></li>
<li><p><strong>return_lower_ranks</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to return lower rank RDMs in addition to the
specified rank. If True, then this function returns all RDMs up to and
including the specified rank, in increasing order of rank. For example,
if <cite>rank=2</cite> then a tuple <cite>(rdm1, rdm2)</cite> is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">...</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The reduced density matrix or matrices. If <cite>return_lower_ranks</cite> is False,
then a single matrix is returned. If <cite>return_lower_ranks</cite> is True, then
a <cite>rank</cite>-length tuple of matrices is returned, containing the RDMs up to
the specified rank in increasing order of rank.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.simulate_qdrift_double_factorized">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">simulate_qdrift_double_factorized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probabilities</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'norm'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">one_rdm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/trotter/qdrift.html#simulate_qdrift_double_factorized"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.simulate_qdrift_double_factorized" title="Link to this definition">¶</a></dt>
<dd><p>Double-factorized Hamiltonian simulation via qDRIFT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to evolve.</p></li>
<li><p><strong>hamiltonian</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian" title="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a></span>) – The Hamiltonian.</p></li>
<li><p><strong>time</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The evolution time.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>n_steps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of Trotter steps.</p></li>
<li><p><strong>probabilities</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The sampling method to use, or else an explicit array of
probabilities. If specifying a string, the following options are supported:
- “norm”: Sample each term with probability proportional to its
spectral norm.
- “uniform”: Sample each term with uniform probability.
- “optimal”: Sample with probabilities optimized for a given initial state.
The “optimal” method requires the one-body reduced density matrix of the
initial state to be specified. It returns optimal probabilities whenever
the initial state is completely characterized by this reduced density
matrix, i.e., it is a Slater determinant.</p></li>
<li><p><strong>one_rdm</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The one-body reduced density matrix of the initial state.</p></li>
<li><p><strong>n_samples</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of qDRIFT trajectories to sample.</p></li>
<li><p><strong>seed</strong> – A seed to initialize the pseudorandom number generator.
Should be a valid input to <code class="docutils literal notranslate"><span class="pre">np.random.default_rng</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A Numpy array representing the final state of the simulation. The shape of the
array depends on the <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> argument. If <code class="docutils literal notranslate"><span class="pre">n_samples=1</span></code> then it is
just a statevector, a one-dimensional array. Otherwise, it is a two-dimensional
array of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">dim)</span></code> where <code class="docutils literal notranslate"><span class="pre">dim</span></code> is the dimension of the
statevector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.simulate_trotter_double_factorized">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">simulate_trotter_double_factorized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/trotter/trotter.html#simulate_trotter_double_factorized"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.simulate_trotter_double_factorized" title="Link to this definition">¶</a></dt>
<dd><p>Double-factorized Hamiltonian simulation using Trotter-Suzuki formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to evolve.</p></li>
<li><p><strong>hamiltonian</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian" title="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a></span>) – The Hamiltonian.</p></li>
<li><p><strong>time</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The evolution time.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>n_steps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of Trotter steps.</p></li>
<li><p><strong>order</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The order of the Trotter decomposition.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The final state of the simulation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.slater_determinant">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">slater_determinant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occupied_orbitals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/states.html#slater_determinant"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.slater_determinant" title="Link to this definition">¶</a></dt>
<dd><p>Return a Slater determinant.</p>
<p>A Slater determinant is a state of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{U} \lvert x \rangle,\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{U}\)</span> is an
<a class="reference internal" href="../explanations/orbital-rotation.html"><span class="doc">orbital rotation</span></a> and
<span class="math notranslate nohighlight">\(\lvert x \rangle\)</span> is an electronic configuration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>occupied_orbitals</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – The occupied orbitals in the electonic configuration.
This is a pair of lists of integers, where the first list specifies the
spin alpha orbitals and the second list specifies the spin beta
orbitals.</p></li>
<li><p><strong>orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The optional orbital rotation.
You can pass either a single Numpy array specifying the orbital rotation
to apply to both spin sectors, or you can pass a pair of Numpy arrays
specifying independent orbital rotations for spin alpha and spin beta.
If passing a pair, you can use <code class="docutils literal notranslate"><span class="pre">None</span></code> for one of the
values in the pair to indicate that no operation should be applied to
that spin sector.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The Slater determinant as a statevector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.slater_determinant_rdm">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">slater_determinant_rdm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occupied_orbitals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_summed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/states.html#slater_determinant_rdm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.slater_determinant_rdm" title="Link to this definition">¶</a></dt>
<dd><p>Return the reduced density matrix of a <a class="reference external" href="ffsim.html#ffsim.slater_determinant">Slater determinant</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, only rank 1 is supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>occupied_orbitals</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – The occupied orbitals in the electonic configuration.
This is a pair of lists of integers, where the first list specifies the
spin alpha orbitals and the second list specifies the spin beta
orbitals.</p></li>
<li><p><strong>orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The optional orbital rotation.
You can pass either a single Numpy array specifying the orbital rotation
to apply to both spin sectors, or you can pass a pair of Numpy arrays
specifying independent orbital rotations for spin alpha and spin beta.
If passing a pair, you can use <code class="docutils literal notranslate"><span class="pre">None</span></code> for one of the
values in the pair to indicate that no operation should be applied to that
spin sector.</p></li>
<li><p><strong>rank</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The rank of the reduced density matrix. I.e., rank 1 corresponds to the
one-particle RDM, rank 2 corresponds to the 2-particle RDM, etc.</p></li>
<li><p><strong>spin_summed</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to sum over the spin index.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The reduced density matrix of the Slater determinant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.spin_square">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">spin_square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fcivec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/states.html#spin_square"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.spin_square" title="Link to this definition">¶</a></dt>
<dd><p>Expectation value of spin squared operator on a state vector.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.strings_to_indices">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">strings_to_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/states.html#strings_to_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.strings_to_indices" title="Link to this definition">¶</a></dt>
<dd><p>Convert bitstrings to statevector indices.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ffsim</span>

<span class="n">norb</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">nelec</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">dim</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">)</span>
<span class="n">ffsim</span><span class="o">.</span><span class="n">strings_to_indices</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="s2">&quot;001011&quot;</span><span class="p">,</span>
        <span class="s2">&quot;010011&quot;</span><span class="p">,</span>
        <span class="s2">&quot;100011&quot;</span><span class="p">,</span>
        <span class="s2">&quot;001101&quot;</span><span class="p">,</span>
        <span class="s2">&quot;010101&quot;</span><span class="p">,</span>
        <span class="s2">&quot;100101&quot;</span><span class="p">,</span>
        <span class="s2">&quot;001110&quot;</span><span class="p">,</span>
        <span class="s2">&quot;010110&quot;</span><span class="p">,</span>
        <span class="s2">&quot;100110&quot;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="n">norb</span><span class="p">,</span>
    <span class="n">nelec</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># output:</span>
<span class="c1"># array([0, 1, 2, 3, 4, 5, 6, 7, 8], dtype=int32)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.trace">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/trace_protocol.html#trace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.trace" title="Link to this definition">¶</a></dt>
<dd><p>Return the trace of the linear operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span></p>
</dd>
</dl>
</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="ffsim.contract.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">ffsim.contract</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">API Reference</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, IBM
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/qiskit-community/ffsim" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">ffsim</a><ul>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.one_body_tensor"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.one_body_tensor</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.diag_coulomb_mats"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.diag_coulomb_mats</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.orbital_rotations"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.orbital_rotations</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.constant"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.constant</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.z_representation"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.z_representation</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.from_molecular_hamiltonian()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.norb"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.to_number_representation"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.to_number_representation()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.to_z_representation"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.to_z_representation()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.FermionAction"><code class="docutils literal notranslate"><span class="pre">FermionAction</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.FermionAction.action"><code class="docutils literal notranslate"><span class="pre">FermionAction.action</span></code></a></li>
<li><a class="reference internal" href="#ffsim.FermionAction.orb"><code class="docutils literal notranslate"><span class="pre">FermionAction.orb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.FermionAction.spin"><code class="docutils literal notranslate"><span class="pre">FermionAction.spin</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.FermionOperator"><code class="docutils literal notranslate"><span class="pre">FermionOperator</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.FermionOperator.conserves_particle_number"><code class="docutils literal notranslate"><span class="pre">FermionOperator.conserves_particle_number()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.FermionOperator.conserves_spin_z"><code class="docutils literal notranslate"><span class="pre">FermionOperator.conserves_spin_z()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.FermionOperator.many_body_order"><code class="docutils literal notranslate"><span class="pre">FermionOperator.many_body_order()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.FermionOperator.normal_ordered"><code class="docutils literal notranslate"><span class="pre">FermionOperator.normal_ordered()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOperator"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOperator</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOperator.norb"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOperator.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOperator.interaction_pairs"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOperator.interaction_pairs</span></code></a></li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOperator.thetas"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOperator.thetas</span></code></a></li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOperator.from_parameters"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOperator.from_parameters()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOperator.to_parameters"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOperator.to_parameters()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.HopGateAnsatzOperator"><code class="docutils literal notranslate"><span class="pre">HopGateAnsatzOperator</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.HopGateAnsatzOperator.norb"><code class="docutils literal notranslate"><span class="pre">HopGateAnsatzOperator.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.HopGateAnsatzOperator.interaction_pairs"><code class="docutils literal notranslate"><span class="pre">HopGateAnsatzOperator.interaction_pairs</span></code></a></li>
<li><a class="reference internal" href="#ffsim.HopGateAnsatzOperator.thetas"><code class="docutils literal notranslate"><span class="pre">HopGateAnsatzOperator.thetas</span></code></a></li>
<li><a class="reference internal" href="#ffsim.HopGateAnsatzOperator.final_orbital_rotation"><code class="docutils literal notranslate"><span class="pre">HopGateAnsatzOperator.final_orbital_rotation</span></code></a></li>
<li><a class="reference internal" href="#ffsim.HopGateAnsatzOperator.from_parameters"><code class="docutils literal notranslate"><span class="pre">HopGateAnsatzOperator.from_parameters()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.HopGateAnsatzOperator.to_parameters"><code class="docutils literal notranslate"><span class="pre">HopGateAnsatzOperator.to_parameters()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.MolecularData"><code class="docutils literal notranslate"><span class="pre">MolecularData</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.MolecularData.atom"><code class="docutils literal notranslate"><span class="pre">MolecularData.atom</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.basis"><code class="docutils literal notranslate"><span class="pre">MolecularData.basis</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.spin"><code class="docutils literal notranslate"><span class="pre">MolecularData.spin</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.symmetry"><code class="docutils literal notranslate"><span class="pre">MolecularData.symmetry</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.norb"><code class="docutils literal notranslate"><span class="pre">MolecularData.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.nelec"><code class="docutils literal notranslate"><span class="pre">MolecularData.nelec</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.mo_coeff"><code class="docutils literal notranslate"><span class="pre">MolecularData.mo_coeff</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.mo_occ"><code class="docutils literal notranslate"><span class="pre">MolecularData.mo_occ</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.active_space"><code class="docutils literal notranslate"><span class="pre">MolecularData.active_space</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.core_energy"><code class="docutils literal notranslate"><span class="pre">MolecularData.core_energy</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.one_body_tensor"><code class="docutils literal notranslate"><span class="pre">MolecularData.one_body_tensor</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.two_body_integrals"><code class="docutils literal notranslate"><span class="pre">MolecularData.two_body_integrals</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.hf_energy"><code class="docutils literal notranslate"><span class="pre">MolecularData.hf_energy</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.hf_mo_coeff"><code class="docutils literal notranslate"><span class="pre">MolecularData.hf_mo_coeff</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.hf_mo_occ"><code class="docutils literal notranslate"><span class="pre">MolecularData.hf_mo_occ</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.mp2_energy"><code class="docutils literal notranslate"><span class="pre">MolecularData.mp2_energy</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.mp2_t2"><code class="docutils literal notranslate"><span class="pre">MolecularData.mp2_t2</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.ccsd_energy"><code class="docutils literal notranslate"><span class="pre">MolecularData.ccsd_energy</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.ccsd_t1"><code class="docutils literal notranslate"><span class="pre">MolecularData.ccsd_t1</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.ccsd_t2"><code class="docutils literal notranslate"><span class="pre">MolecularData.ccsd_t2</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.fci_energy"><code class="docutils literal notranslate"><span class="pre">MolecularData.fci_energy</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.fci_vec"><code class="docutils literal notranslate"><span class="pre">MolecularData.fci_vec</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.dipole_integrals"><code class="docutils literal notranslate"><span class="pre">MolecularData.dipole_integrals</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.orbital_symmetries"><code class="docutils literal notranslate"><span class="pre">MolecularData.orbital_symmetries</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.from_mole"><code class="docutils literal notranslate"><span class="pre">MolecularData.from_mole()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.from_scf"><code class="docutils literal notranslate"><span class="pre">MolecularData.from_scf()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.hamiltonian"><code class="docutils literal notranslate"><span class="pre">MolecularData.hamiltonian</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.mole"><code class="docutils literal notranslate"><span class="pre">MolecularData.mole</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.run_ccsd"><code class="docutils literal notranslate"><span class="pre">MolecularData.run_ccsd()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.run_fci"><code class="docutils literal notranslate"><span class="pre">MolecularData.run_fci()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.run_mp2"><code class="docutils literal notranslate"><span class="pre">MolecularData.run_mp2()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.MolecularHamiltonian"><code class="docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.MolecularHamiltonian.one_body_tensor"><code class="docutils literal notranslate"><span class="pre">MolecularHamiltonian.one_body_tensor</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularHamiltonian.two_body_tensor"><code class="docutils literal notranslate"><span class="pre">MolecularHamiltonian.two_body_tensor</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularHamiltonian.constant"><code class="docutils literal notranslate"><span class="pre">MolecularHamiltonian.constant</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularHamiltonian.norb"><code class="docutils literal notranslate"><span class="pre">MolecularHamiltonian.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularHamiltonian.rotated"><code class="docutils literal notranslate"><span class="pre">MolecularHamiltonian.rotated()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.ProductStateSum"><code class="docutils literal notranslate"><span class="pre">ProductStateSum</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.ProductStateSum.coeffs"><code class="docutils literal notranslate"><span class="pre">ProductStateSum.coeffs</span></code></a></li>
<li><a class="reference internal" href="#ffsim.ProductStateSum.states"><code class="docutils literal notranslate"><span class="pre">ProductStateSum.states</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.RealUCJOperator"><code class="docutils literal notranslate"><span class="pre">RealUCJOperator</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.RealUCJOperator.diag_coulomb_mats_alpha_alpha"><code class="docutils literal notranslate"><span class="pre">RealUCJOperator.diag_coulomb_mats_alpha_alpha</span></code></a></li>
<li><a class="reference internal" href="#ffsim.RealUCJOperator.diag_coulomb_mats_alpha_beta"><code class="docutils literal notranslate"><span class="pre">RealUCJOperator.diag_coulomb_mats_alpha_beta</span></code></a></li>
<li><a class="reference internal" href="#ffsim.RealUCJOperator.orbital_rotations"><code class="docutils literal notranslate"><span class="pre">RealUCJOperator.orbital_rotations</span></code></a></li>
<li><a class="reference internal" href="#ffsim.RealUCJOperator.final_orbital_rotation"><code class="docutils literal notranslate"><span class="pre">RealUCJOperator.final_orbital_rotation</span></code></a></li>
<li><a class="reference internal" href="#ffsim.RealUCJOperator.from_parameters"><code class="docutils literal notranslate"><span class="pre">RealUCJOperator.from_parameters()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.RealUCJOperator.from_t_amplitudes"><code class="docutils literal notranslate"><span class="pre">RealUCJOperator.from_t_amplitudes()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.RealUCJOperator.n_params"><code class="docutils literal notranslate"><span class="pre">RealUCJOperator.n_params()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.RealUCJOperator.n_reps"><code class="docutils literal notranslate"><span class="pre">RealUCJOperator.n_reps</span></code></a></li>
<li><a class="reference internal" href="#ffsim.RealUCJOperator.norb"><code class="docutils literal notranslate"><span class="pre">RealUCJOperator.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.RealUCJOperator.to_parameters"><code class="docutils literal notranslate"><span class="pre">RealUCJOperator.to_parameters()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.RealUCJOperator.to_t_amplitudes"><code class="docutils literal notranslate"><span class="pre">RealUCJOperator.to_t_amplitudes()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian.one_body_tensor"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian.one_body_tensor</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian.one_body_squares"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian.one_body_squares</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian.constant"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian.constant</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian.expectation_product_state"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian.expectation_product_state()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian.from_molecular_hamiltonian"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian.from_molecular_hamiltonian()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian.norb"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian.reduced_matrix_product_states"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian.reduced_matrix_product_states()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.Spin"><code class="docutils literal notranslate"><span class="pre">Spin</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.Spin.ALPHA"><code class="docutils literal notranslate"><span class="pre">Spin.ALPHA</span></code></a></li>
<li><a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA"><code class="docutils literal notranslate"><span class="pre">Spin.ALPHA_AND_BETA</span></code></a></li>
<li><a class="reference internal" href="#ffsim.Spin.BETA"><code class="docutils literal notranslate"><span class="pre">Spin.BETA</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.SupportsApplyUnitary"><code class="docutils literal notranslate"><span class="pre">SupportsApplyUnitary</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SupportsApproximateEquality"><code class="docutils literal notranslate"><span class="pre">SupportsApproximateEquality</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SupportsDiagonal"><code class="docutils literal notranslate"><span class="pre">SupportsDiagonal</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SupportsFermionOperator"><code class="docutils literal notranslate"><span class="pre">SupportsFermionOperator</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SupportsLinearOperator"><code class="docutils literal notranslate"><span class="pre">SupportsLinearOperator</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SupportsTrace"><code class="docutils literal notranslate"><span class="pre">SupportsTrace</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOperator"><code class="docutils literal notranslate"><span class="pre">UCJOperator</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.UCJOperator.diag_coulomb_mats_alpha_alpha"><code class="docutils literal notranslate"><span class="pre">UCJOperator.diag_coulomb_mats_alpha_alpha</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOperator.diag_coulomb_mats_alpha_beta"><code class="docutils literal notranslate"><span class="pre">UCJOperator.diag_coulomb_mats_alpha_beta</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOperator.orbital_rotations"><code class="docutils literal notranslate"><span class="pre">UCJOperator.orbital_rotations</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOperator.final_orbital_rotation"><code class="docutils literal notranslate"><span class="pre">UCJOperator.final_orbital_rotation</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOperator.from_parameters"><code class="docutils literal notranslate"><span class="pre">UCJOperator.from_parameters()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOperator.from_t_amplitudes"><code class="docutils literal notranslate"><span class="pre">UCJOperator.from_t_amplitudes()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOperator.n_params"><code class="docutils literal notranslate"><span class="pre">UCJOperator.n_params()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOperator.n_reps"><code class="docutils literal notranslate"><span class="pre">UCJOperator.n_reps</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOperator.norb"><code class="docutils literal notranslate"><span class="pre">UCJOperator.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOperator.to_parameters"><code class="docutils literal notranslate"><span class="pre">UCJOperator.to_parameters()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOperator.to_t_amplitudes"><code class="docutils literal notranslate"><span class="pre">UCJOperator.to_t_amplitudes()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.apply_diag_coulomb_evolution"><code class="docutils literal notranslate"><span class="pre">apply_diag_coulomb_evolution()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_fsim_gate"><code class="docutils literal notranslate"><span class="pre">apply_fsim_gate()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_givens_rotation"><code class="docutils literal notranslate"><span class="pre">apply_givens_rotation()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_hop_gate"><code class="docutils literal notranslate"><span class="pre">apply_hop_gate()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_num_interaction"><code class="docutils literal notranslate"><span class="pre">apply_num_interaction()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_num_num_interaction"><code class="docutils literal notranslate"><span class="pre">apply_num_num_interaction()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_num_op_prod_interaction"><code class="docutils literal notranslate"><span class="pre">apply_num_op_prod_interaction()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_num_op_sum_evolution"><code class="docutils literal notranslate"><span class="pre">apply_num_op_sum_evolution()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_on_site_interaction"><code class="docutils literal notranslate"><span class="pre">apply_on_site_interaction()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_orbital_rotation"><code class="docutils literal notranslate"><span class="pre">apply_orbital_rotation()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_tunneling_interaction"><code class="docutils literal notranslate"><span class="pre">apply_tunneling_interaction()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_unitary"><code class="docutils literal notranslate"><span class="pre">apply_unitary()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.approx_eq"><code class="docutils literal notranslate"><span class="pre">approx_eq()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.cre"><code class="docutils literal notranslate"><span class="pre">cre()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.cre_a"><code class="docutils literal notranslate"><span class="pre">cre_a()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.cre_b"><code class="docutils literal notranslate"><span class="pre">cre_b()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.des"><code class="docutils literal notranslate"><span class="pre">des()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.des_a"><code class="docutils literal notranslate"><span class="pre">des_a()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.des_b"><code class="docutils literal notranslate"><span class="pre">des_b()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.diag"><code class="docutils literal notranslate"><span class="pre">diag()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.dim"><code class="docutils literal notranslate"><span class="pre">dim()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.dims"><code class="docutils literal notranslate"><span class="pre">dims()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.expectation_one_body_power"><code class="docutils literal notranslate"><span class="pre">expectation_one_body_power()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.expectation_one_body_product"><code class="docutils literal notranslate"><span class="pre">expectation_one_body_product()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.fermi_hubbard_1d"><code class="docutils literal notranslate"><span class="pre">fermi_hubbard_1d()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.fermi_hubbard_2d"><code class="docutils literal notranslate"><span class="pre">fermi_hubbard_2d()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.fermion_operator"><code class="docutils literal notranslate"><span class="pre">fermion_operator()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.hartree_fock_state"><code class="docutils literal notranslate"><span class="pre">hartree_fock_state()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.indices_to_strings"><code class="docutils literal notranslate"><span class="pre">indices_to_strings()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.init_cache"><code class="docutils literal notranslate"><span class="pre">init_cache()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.linear_operator"><code class="docutils literal notranslate"><span class="pre">linear_operator()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.multireference_state"><code class="docutils literal notranslate"><span class="pre">multireference_state()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.multireference_state_prod"><code class="docutils literal notranslate"><span class="pre">multireference_state_prod()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.number_operator"><code class="docutils literal notranslate"><span class="pre">number_operator()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.one_hot"><code class="docutils literal notranslate"><span class="pre">one_hot()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.rdm"><code class="docutils literal notranslate"><span class="pre">rdm()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.simulate_qdrift_double_factorized"><code class="docutils literal notranslate"><span class="pre">simulate_qdrift_double_factorized()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.simulate_trotter_double_factorized"><code class="docutils literal notranslate"><span class="pre">simulate_trotter_double_factorized()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.slater_determinant"><code class="docutils literal notranslate"><span class="pre">slater_determinant()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.slater_determinant_rdm"><code class="docutils literal notranslate"><span class="pre">slater_determinant_rdm()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.spin_square"><code class="docutils literal notranslate"><span class="pre">spin_square()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.strings_to_indices"><code class="docutils literal notranslate"><span class="pre">strings_to_indices()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.trace"><code class="docutils literal notranslate"><span class="pre">trace()</span></code></a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=69c31af4"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=4e2eecee"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>