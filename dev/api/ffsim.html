<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="ffsim.contract" href="ffsim.contract.html" /><link rel="prev" title="API reference" href="index.html" />

    <!-- Generated with Sphinx 8.1.3 and Furo 2024.08.06 -->
        <title>ffsim - ffsim 0.0.49.dev0</title>
      <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/qiskit-sphinx-theme.css?v=8ff9dcb6" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=IBM+Plex+Sans:ital,wght@0,400;0,600;1,400;1,600&display=swap" rel="stylesheet"></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M14 2H2C1.73478 2 1.48043 2.10536 1.29289 2.29289C1.10536 2.48043 1 2.73478 1 3V13C1 13.2652 1.10536 13.5196 1.29289 13.7071C1.48043 13.8946 1.73478 14 2 14H14C14.2652 14 14.5196 13.8946 14.7071 13.7071C14.8946 13.5196 15 13.2652 15 13V3C15 2.73478 14.8946 2.48043 14.7071 2.29289C14.5196 2.10536 14.2652 2 14 2V2ZM2 3H10V13H2V3ZM14 13H11V3H14V13Z" fill="currentColor"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M14 3H2V4H14V3Z" fill="currentColor"/>
      <path d="M14 12H2V13H14V12Z" fill="currentColor"/>
      <path d="M14 6H2V7H14V6Z" fill="currentColor"/>
      <path d="M14 9H2V10H14V9Z" fill="currentColor"/>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M11 8L6.00005 13L5.30005 12.3L9.60005 8L5.30005 3.7L6.00005 3L11 8Z" fill="currentColor"/>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M15 13H1V14H15V13Z" fill="currentColor"/>
      <path d="M12.7 4.5C13.1 4.1 13.1 3.5 12.7 3.1L10.9 1.3C10.5 0.9 9.9 0.9 9.5 1.3L2 8.8V12H5.2L12.7 4.5ZM10.2 2L12 3.8L10.5 5.3L8.7 3.5L10.2 2ZM3 11V9.2L8 4.2L9.8 6L4.8 11H3Z" fill="currentColor"/>
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M11 13.0002C11.5523 13.0002 12 12.5525 12 12.0002C12 11.4479 11.5523 11.0002 11 11.0002C10.4477 11.0002 10 11.4479 10 12.0002C10 12.5525 10.4477 13.0002 11 13.0002Z" fill="currentColor"/>
      <path d="M14.8884 11.7394C14.5795 10.9524 14.0464 10.2734 13.3552 9.78646C12.664 9.29954 11.8451 9.02615 11 9.00017C10.1549 9.02615 9.33604 9.29954 8.64484 9.78646C7.95365 10.2734 7.42052 10.9524 7.11155 11.7394L7 12.0002L7.11155 12.2609C7.42052 13.0479 7.95365 13.727 8.64484 14.2139C9.33604 14.7008 10.1549 14.9742 11 15.0002C11.8451 14.9742 12.664 14.7008 13.3552 14.2139C14.0464 13.727 14.5795 13.0479 14.8884 12.2609L15 12.0002L14.8884 11.7394ZM11 14.0002C10.6044 14.0002 10.2178 13.8829 9.88886 13.6631C9.55996 13.4433 9.30362 13.131 9.15224 12.7655C9.00087 12.4001 8.96126 11.998 9.03843 11.61C9.1156 11.222 9.30608 10.8657 9.58579 10.586C9.86549 10.3063 10.2219 10.1158 10.6098 10.0386C10.9978 9.96143 11.3999 10.001 11.7654 10.1524C12.1308 10.3038 12.4432 10.5601 12.6629 10.889C12.8827 11.2179 13 11.6046 13 12.0002C12.9994 12.5304 12.7885 13.0388 12.4136 13.4137C12.0386 13.7887 11.5303 13.9996 11 14.0002Z" fill="currentColor"/>
      <path d="M6 14.0002H4V2.00017H8V5.00017C8.00077 5.26515 8.10637 5.51906 8.29374 5.70643C8.48111 5.8938 8.73502 5.99941 9 6.00017H12V8.00017H13V5.00017C13.0018 4.93446 12.9893 4.86913 12.9634 4.80871C12.9375 4.74828 12.8988 4.6942 12.85 4.65017L9.35 1.15017C9.30599 1.10134 9.2519 1.06263 9.19147 1.03674C9.13104 1.01084 9.06572 0.998364 9 1.00017H4C3.73502 1.00094 3.48111 1.10654 3.29374 1.29391C3.10637 1.48128 3.00077 1.73519 3 2.00017V14.0002C3.00077 14.2652 3.10637 14.5191 3.29374 14.7064C3.48111 14.8938 3.73502 14.9994 4 15.0002H6V14.0002ZM9 2.20017L11.8 5.00017H9V2.20017Z" fill="currentColor"/>
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">ffsim 0.0.49.dev0</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">ffsim 0.0.49.dev0</span>
  
</a>

<p class="sidebar-ecosystem-link">
  This project is part of the <a class="reference external" href="https://www.ibm.com/quantum/ecosystem">Qiskit ecosystem</a>
</p><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../tutorials/index.html">Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Tutorials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/double-factorized-trotter.html">Implementing Trotter simulation of the double-factorized Hamiltonian</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../explanations/index.html">Explanations</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Explanations</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../explanations/state-vectors-and-gates.html">State vectors and gates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../explanations/hamiltonians.html">Hamiltonians</a></li>
<li class="toctree-l2"><a class="reference internal" href="../explanations/orbital-rotation.html">Orbital rotations and quadratic Hamiltonians</a></li>
<li class="toctree-l2"><a class="reference internal" href="../explanations/double-factorized.html">Double-factorized representation of the molecular Hamiltonian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../explanations/lucj.html">The local unitary cluster Jastrow (LUCJ) ansatz</a></li>
<li class="toctree-l2"><a class="reference internal" href="../explanations/qiskit-gate-decompositions.html">Qubit gate decompositions of fermionic gates</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../how-to-guides/index.html">How-to guides</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of How-to guides</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../how-to-guides/lucj.html">How to simulate the local unitary cluster Jastrow (LUCJ) ansatz</a></li>
<li class="toctree-l2"><a class="reference internal" href="../how-to-guides/entanglement-forging.html">How to simulate entanglement forging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../how-to-guides/fermion-operator.html">How to use the FermionOperator class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../how-to-guides/qiskit-circuits.html">How to build and transpile Qiskit quantum circuits</a></li>
<li class="toctree-l2"><a class="reference internal" href="../how-to-guides/qiskit-sampler.html">How to use ffsim’s Qiskit Sampler primitive</a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">API reference</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of API reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">ffsim</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffsim.contract.html">ffsim.contract</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffsim.linalg.html">ffsim.linalg</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffsim.optimize.html">ffsim.optimize</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffsim.qiskit.html">ffsim.qiskit</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffsim.random.html">ffsim.random</a></li>
<li class="toctree-l2"><a class="reference internal" href="ffsim.testing.html">ffsim.testing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/qiskit-community/ffsim">GitHub</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/qiskit-community/ffsim/blob/main/CONTRIBUTING.md">Developer guide</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/qiskit-community/ffsim/releases">Release notes</a></li>
<li class="toctree-l1"><a class="reference external" href="https://qiskit-community.github.io/ffsim/dev/">Development branch docs</a></li>
</ul>

</div></div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/qiskit-community/ffsim/blob/main/docs/api/ffsim.rst?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/qiskit-community/ffsim/edit/main/docs/api/ffsim.rst" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="module-ffsim">
<span id="ffsim"></span><h1>ffsim<a class="headerlink" href="#module-ffsim" title="Link to this heading">¶</a></h1>
<p>ffsim is a software library for fast simulation of fermionic quantum circuits.</p>
<dl class="py class">
<dt class="sig sig-object py" id="ffsim.BitstringType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">BitstringType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names=&lt;not</span> <span class="pre">given&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">module=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qualname=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary=None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/bitstring.html#BitstringType"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.BitstringType" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></p>
<p>Enumeration for indicating the data type of bitstrings.</p>
<dl class="simple">
<dt>String:</dt><dd><p>[“0101”, “0110”]</p>
</dd>
<dt>Integer:</dt><dd><p>[5, 6]</p>
</dd>
<dt>Bit array:</dt><dd><dl class="simple">
<dt>[[False, True, False, True],</dt><dd><p>[False, True, True, False]]</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.BitstringType.BIT_ARRAY">
<span class="sig-name descname"><span class="pre">BIT_ARRAY</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#ffsim.BitstringType.BIT_ARRAY" title="Link to this definition">¶</a></dt>
<dd><p>Bit array.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.BitstringType.INT">
<span class="sig-name descname"><span class="pre">INT</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#ffsim.BitstringType.INT" title="Link to this definition">¶</a></dt>
<dd><p>Integer.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.BitstringType.STRING">
<span class="sig-name descname"><span class="pre">STRING</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#ffsim.BitstringType.STRING" title="Link to this definition">¶</a></dt>
<dd><p>String.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.DiagonalCoulombHamiltonian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">DiagonalCoulombHamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag_coulomb_mats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/diagonal_coulomb_hamiltonian.html#DiagonalCoulombHamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.DiagonalCoulombHamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A diagonal Coulomb Hamiltonian.</p>
<p>A Hamiltonian of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = \sum_{\sigma, pq} h_{pq} a^\dagger_{\sigma, p} a_{\sigma, q}
    + \frac12 \sum_{\sigma \tau, pq} V_{(\sigma \tau), pq} n_{\sigma, p}
    n_{\tau, q} + \text{constant}.\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(n_{\sigma, p} = a_{\sigma, p}^\dagger a_{\sigma, p}\)</span> is the number
operator on orbital <span class="math notranslate nohighlight">\(p\)</span> with spin <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
<p>Here <span class="math notranslate nohighlight">\(h_{pq}\)</span> is called the one-body tensor and <span class="math notranslate nohighlight">\(V_{(\sigma \tau), pq}\)</span>
are called the diagonal Coulomb matrices. The brackets indicate that
<span class="math notranslate nohighlight">\(V_{(\sigma \tau)}\)</span> is a circulant matrix, which satisfies
<span class="math notranslate nohighlight">\(V_{\alpha\alpha}=V_{\beta\beta}\)</span> and <span class="math notranslate nohighlight">\(V_{\alpha\beta}=V_{\beta\alpha}\)</span>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.DiagonalCoulombHamiltonian.one_body_tensor">
<span class="sig-name descname"><span class="pre">one_body_tensor</span></span><a class="headerlink" href="#ffsim.DiagonalCoulombHamiltonian.one_body_tensor" title="Link to this definition">¶</a></dt>
<dd><p>The one-body tensor <span class="math notranslate nohighlight">\(h\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.DiagonalCoulombHamiltonian.diag_coulomb_mats">
<span class="sig-name descname"><span class="pre">diag_coulomb_mats</span></span><a class="headerlink" href="#ffsim.DiagonalCoulombHamiltonian.diag_coulomb_mats" title="Link to this definition">¶</a></dt>
<dd><p>The diagonal Coulomb matrices
<span class="math notranslate nohighlight">\(V_{(\sigma \tau)}\)</span>, given as a pair of Numpy arrays specifying
independent coefficients for alpha-alpha and alpha-beta interactions (in
that order).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.DiagonalCoulombHamiltonian.constant">
<span class="sig-name descname"><span class="pre">constant</span></span><a class="headerlink" href="#ffsim.DiagonalCoulombHamiltonian.constant" title="Link to this definition">¶</a></dt>
<dd><p>The constant.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.DiagonalCoulombHamiltonian.from_fermion_operator">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_fermion_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/diagonal_coulomb_hamiltonian.html#DiagonalCoulombHamiltonian.from_fermion_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.DiagonalCoulombHamiltonian.from_fermion_operator" title="Link to this definition">¶</a></dt>
<dd><p>Convert a FermionOperator to a DiagonalCoulombHamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.DiagonalCoulombHamiltonian" title="ffsim.hamiltonians.diagonal_coulomb_hamiltonian.DiagonalCoulombHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiagonalCoulombHamiltonian</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.DiagonalCoulombHamiltonian.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#ffsim.DiagonalCoulombHamiltonian.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">DoubleFactorizedHamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag_coulomb_mats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_representation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/double_factorized_hamiltonian.html#DoubleFactorizedHamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A Hamiltonian in the double-factorized representation.</p>
<p>The double-factorized form of the molecular Hamiltonian is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = \sum_{\sigma, pq} \kappa_{pq} a^\dagger_{\sigma, p} a_{\sigma, q}
+ \frac12 \sum_t \sum_{\sigma\tau, ij}
Z^{(t)}_{ij} n^{(t)}_{\sigma, i} n^{(t)}_{\tau, j}
+ \text{constant}'.\]</div>
</div>
<p>where</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[n^{(t)}_{\sigma, i} = \sum_{pq} U^{(t)}_{pi}
a^\dagger_{\sigma, p} a_{\sigma, q} U^{(t)}_{qi}.\]</div>
</div>
<p>Here each <span class="math notranslate nohighlight">\(U^{(t)}\)</span> is a unitary matrix and each <span class="math notranslate nohighlight">\(Z^{(t)}\)</span>
is a real symmetric matrix.</p>
<p><strong>“Z” representation</strong></p>
<p>The “Z” representation of the double factorization is an alternative
representation that sometimes yields simpler quantum circuits.</p>
<p>Under the Jordan-Wigner transformation, the number operators take the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[n^{(t)}_{\sigma, i} = \frac{(1 - z^{(t)}_{\sigma, i})}{2}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(z^{(t)}_{\sigma, i}\)</span> is the Pauli Z operator in the rotated basis.
The “Z” representation is obtained by rewriting the two-body part in terms
of these Pauli Z operators and updating the one-body term as appropriate:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = \sum_{\sigma, pq} \kappa'_{pq} a^\dagger_{\sigma, p} a_{\sigma, q}
+ \frac18 \sum_t \sum_{\sigma\tau, ij}^*
Z^{(t)}_{ij} z^{(t)}_{\sigma, i} z^{(t)}_{\tau, j}
+ \text{constant}''\]</div>
</div>
<p>where the asterisk denotes summation over indices <span class="math notranslate nohighlight">\(\sigma\tau, ij\)</span>
where <span class="math notranslate nohighlight">\(\sigma \neq \tau\)</span> or <span class="math notranslate nohighlight">\(i \neq j\)</span>.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://arxiv.org/abs/1808.02625">Low rank representations for quantum simulation of electronic structure</a></p></li>
<li><p><a class="reference external" href="https://arxiv.org/abs/2104.08957">Quantum Filter Diagonalization with Double-Factorized Hamiltonians</a></p></li>
</ul>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.one_body_tensor">
<span class="sig-name descname"><span class="pre">one_body_tensor</span></span><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.one_body_tensor" title="Link to this definition">¶</a></dt>
<dd><p>The one-body tensor <span class="math notranslate nohighlight">\(\kappa\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.diag_coulomb_mats">
<span class="sig-name descname"><span class="pre">diag_coulomb_mats</span></span><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.diag_coulomb_mats" title="Link to this definition">¶</a></dt>
<dd><p>The diagonal Coulomb matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.orbital_rotations">
<span class="sig-name descname"><span class="pre">orbital_rotations</span></span><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.orbital_rotations" title="Link to this definition">¶</a></dt>
<dd><p>The orbital rotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.constant">
<span class="sig-name descname"><span class="pre">constant</span></span><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.constant" title="Link to this definition">¶</a></dt>
<dd><p>The constant.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.z_representation">
<span class="sig-name descname"><span class="pre">z_representation</span></span><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.z_representation" title="Link to this definition">¶</a></dt>
<dd><p>Whether the Hamiltonian is in the “Z” representation
rather than the “number” representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_molecular_hamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_representation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_vecs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag_coulomb_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cholesky</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/double_factorized_hamiltonian.html#DoubleFactorizedHamiltonian.from_molecular_hamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Initialize a DoubleFactorizedHamiltonian from a MolecularHamiltonian.</p>
<p>This function takes as input a <a class="reference internal" href="#ffsim.MolecularHamiltonian" title="ffsim.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a>, which stores a
one-body tensor, two-body tensor, and constant. It performs a double-factorized
decomposition of the two-body tensor and computes a new one-body tensor
and constant, and returns a <a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian" title="ffsim.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a> storing the
results.</p>
<p>See <a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian" title="ffsim.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a> for a description of the
<cite>z_representation</cite> argument. See <a class="reference internal" href="ffsim.linalg.html#ffsim.linalg.double_factorized" title="ffsim.linalg.double_factorized"><code class="xref py py-func docutils literal notranslate"><span class="pre">ffsim.linalg.double_factorized()</span></code></a> for a
description of the rest of the arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hamiltonian</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.MolecularHamiltonian" title="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a></span>) – The Hamiltonian whose double-factorized representation to
compute.</p></li>
<li><p><strong>z_representation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to use the “Z” representation of the
decomposition.</p></li>
<li><p><strong>tol</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – Tolerance for error in the decomposition.
The error is defined as the maximum absolute difference between
an element of the original tensor and the corresponding element of
the reconstructed tensor.</p></li>
<li><p><strong>max_vecs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – An optional limit on the number of terms to keep in the
decomposition of the two-body tensor. This argument overrides <code class="docutils literal notranslate"><span class="pre">tol</span></code>.</p></li>
<li><p><strong>optimize</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to optimize the tensors returned by the decomposition.</p></li>
<li><p><strong>method</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></span>) – The optimization method. See the documentation of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a> for possible values.</p></li>
<li><p><strong>callback</strong> – Callback function for the optimization. See the documentation of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a> for usage.</p></li>
<li><p><strong>options</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Options for the optimization. See the documentation of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a> for usage.</p></li>
<li><p><strong>diag_coulomb_indices</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Allowed indices for nonzero values of the diagonal
Coulomb matrices. Matrix entries corresponding to indices not in this
list will be set to zero. This list should contain only upper
trianglular indices, i.e., pairs <span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>.
Passing a list with lower triangular indices will raise an error.
This parameter is only used if <cite>optimize</cite> is set to True.</p></li>
<li><p><strong>cholesky</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to perform the factorization using a modified Cholesky
decomposition. If False, a full eigenvalue decomposition is used
instead, which can be much more expensive. This argument is ignored if
<cite>optimize</cite> is set to True.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian" title="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The double-factorized Hamiltonian.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.to_molecular_hamiltonian">
<span class="sig-name descname"><span class="pre">to_molecular_hamiltonian</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/double_factorized_hamiltonian.html#DoubleFactorizedHamiltonian.to_molecular_hamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.to_molecular_hamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Convert the DoubleFactorizedHamiltonian to a MolecularHamiltonian.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.to_number_representation">
<span class="sig-name descname"><span class="pre">to_number_representation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/double_factorized_hamiltonian.html#DoubleFactorizedHamiltonian.to_number_representation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.to_number_representation" title="Link to this definition">¶</a></dt>
<dd><p>Return the Hamiltonian in the “number” representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian" title="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.DoubleFactorizedHamiltonian.to_z_representation">
<span class="sig-name descname"><span class="pre">to_z_representation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/double_factorized_hamiltonian.html#DoubleFactorizedHamiltonian.to_z_representation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.DoubleFactorizedHamiltonian.to_z_representation" title="Link to this definition">¶</a></dt>
<dd><p>Return the Hamiltonian in the “Z” representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian" title="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.FermionAction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">FermionAction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermion_action.html#FermionAction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.FermionAction" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">NamedTuple</span></code></p>
<p>A fermionic action.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.FermionAction.action">
<span class="sig-name descname"><span class="pre">action</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></em><a class="headerlink" href="#ffsim.FermionAction.action" title="Link to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.FermionAction.orb">
<span class="sig-name descname"><span class="pre">orb</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></em><a class="headerlink" href="#ffsim.FermionAction.orb" title="Link to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.FermionAction.spin">
<span class="sig-name descname"><span class="pre">spin</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></em><a class="headerlink" href="#ffsim.FermionAction.spin" title="Link to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.FermionOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">FermionOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeffs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ffsim.FermionOperator" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A fermionic operator.</p>
<p>A FermionOperator represents a linear combination of products of fermionic creation
and annihilation operators. Initialize a FermionOperator by passing a dictionary mapping
the terms in the linear combination to their associated coefficients. FermionOperators
Can be added, subtracted, and multiplied, and they support multiplication and division
by scalars. When multiplying by a scalar, the scalar should go on the left side of the
multiplication operator, e.g. <code class="docutils literal notranslate"><span class="pre">scalar</span> <span class="pre">*</span> <span class="pre">op</span></code>, not <code class="docutils literal notranslate"><span class="pre">op</span> <span class="pre">*</span> <span class="pre">scalar</span></code>.</p>
<p>See <a class="reference internal" href="../how-to-guides/fermion-operator.html"><span class="doc">How to use the FermionOperator class</span></a> for an explanation of how to use this class.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Note: Since FermionOperator is an unordered mapping, the order of</span>
<span class="c1"># the terms in the print outputs below may vary between runs.</span>

<span class="kn">import</span> <span class="nn">ffsim</span>

<span class="n">op1</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="p">(</span><span class="n">ffsim</span><span class="o">.</span><span class="n">cre_a</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">des_a</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="p">(</span><span class="n">ffsim</span><span class="o">.</span><span class="n">cre_a</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">des_a</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">,</span>
        <span class="p">(</span><span class="n">ffsim</span><span class="o">.</span><span class="n">cre_b</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">des_b</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">cre_a</span><span class="p">(</span><span class="mi">4</span><span class="p">)):</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">op1</span><span class="p">)</span>
<span class="c1"># prints</span>
<span class="c1"># FermionOperator({</span>
<span class="c1">#     (cre_b(1), des_b(5), cre_a(4)): 2+2j,</span>
<span class="c1">#     (cre_a(3), des_a(0)): -0.5,</span>
<span class="c1">#     (cre_a(0), des_a(3)): 1</span>
<span class="c1"># })</span>

<span class="n">op2</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="p">(</span><span class="n">ffsim</span><span class="o">.</span><span class="n">cre_b</span><span class="p">(</span><span class="mi">2</span><span class="p">),):</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span>
        <span class="p">(</span><span class="n">ffsim</span><span class="o">.</span><span class="n">des_a</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">des_b</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span><span class="p">)</span>
<span class="c1"># prints</span>
<span class="c1"># FermionOperator({</span>
<span class="c1">#     (cre_a(3), des_a(0)): -0.25,</span>
<span class="c1">#     (cre_b(2)): 0+1j,</span>
<span class="c1">#     (des_a(3), des_b(3)): -0.25,</span>
<span class="c1">#     (cre_b(1), des_b(5), cre_a(4)): 1+1j,</span>
<span class="c1">#     (cre_a(0), des_a(3)): 0.5</span>
<span class="c1"># })</span>

<span class="nb">print</span><span class="p">(</span><span class="n">op1</span> <span class="o">*</span> <span class="n">op2</span><span class="p">)</span>
<span class="c1"># prints</span>
<span class="c1"># FermionOperator({</span>
<span class="c1">#     (cre_b(1), des_b(5), cre_a(4), cre_b(2)): -1+1j,</span>
<span class="c1">#     (cre_a(0), des_a(3), des_a(3), des_b(3)): -0.125,</span>
<span class="c1">#     (cre_a(3), des_a(0), des_a(3), des_b(3)): 0.0625,</span>
<span class="c1">#     (cre_b(1), des_b(5), cre_a(4), des_a(3), des_b(3)): -0.25-0.25j,</span>
<span class="c1">#     (cre_a(0), des_a(3), cre_b(2)): 0+0.5j,</span>
<span class="c1">#     (cre_a(3), des_a(0), cre_b(2)): 0-0.25j</span>
<span class="c1"># })</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coeffs</strong> (<em>dict</em><em>[</em><em>tuple</em><em>[</em><em>tuple</em><em>[</em><em>bool</em><em>, </em><em>bool</em><em>, </em><em>int</em><em>]</em><em>, </em><em>...</em><em>]</em><em>, </em><em>complex</em><em>]</em>) – The coefficients of the
operator.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="ffsim.FermionOperator.conserves_particle_number">
<span class="sig-name descname"><span class="pre">conserves_particle_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ffsim.FermionOperator.conserves_particle_number" title="Link to this definition">¶</a></dt>
<dd><p>Return whether the operator conserves particle number.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the operator conserves particle number, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.FermionOperator.conserves_spin_z">
<span class="sig-name descname"><span class="pre">conserves_spin_z</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ffsim.FermionOperator.conserves_spin_z" title="Link to this definition">¶</a></dt>
<dd><p>Return whether the operator conserves the Z component of spin.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the operator conserves the Z component of spin, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.FermionOperator.many_body_order">
<span class="sig-name descname"><span class="pre">many_body_order</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ffsim.FermionOperator.many_body_order" title="Link to this definition">¶</a></dt>
<dd><p>Return the many-body order of the operator.</p>
<p>The many-body order is defined as the length of the longest term contained
in the operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The many-body order of the operator.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.FermionOperator.normal_ordered">
<span class="sig-name descname"><span class="pre">normal_ordered</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ffsim.FermionOperator.normal_ordered" title="Link to this definition">¶</a></dt>
<dd><p>Return the normal ordered form of the operator.</p>
<p>The normal ordered form of an operator is an equivalent operator in which
each term has been reordered into a canonical ordering.
In each term of a normal-ordered fermion operator, the operators comprising
the term appear from left to right in descending lexicographic order by
(action, spin, orb). That is, all creation operators appear before all
annihilation operators; within creation/annihilation operators, spin beta
operators appear before spin alpha operators, and larger orbital indices
appear before smaller orbital indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The normal-ordered fermion operator.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#ffsim.FermionOperator" title="ffsim.FermionOperator">FermionOperator</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">GivensAnsatzOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thetas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_angles</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/givens.html#GivensAnsatzOp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.GivensAnsatzOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A Givens rotation ansatz operator.</p>
<p>The Givens rotation ansatz consists of a sequence of <a class="reference external" href="ffsim.html#ffsim.apply_givens_rotation">Givens rotations</a> followed
by a layer of single-orbital phase gates.</p>
<p>Note that this ansatz does not implement any interactions between spin alpha and
spin beta orbitals.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOp.norb">
<span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.GivensAnsatzOp.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOp.interaction_pairs">
<span class="sig-name descname"><span class="pre">interaction_pairs</span></span><a class="headerlink" href="#ffsim.GivensAnsatzOp.interaction_pairs" title="Link to this definition">¶</a></dt>
<dd><p>The orbital pairs to apply the Givens
rotations to.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[tuple[int, int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOp.thetas">
<span class="sig-name descname"><span class="pre">thetas</span></span><a class="headerlink" href="#ffsim.GivensAnsatzOp.thetas" title="Link to this definition">¶</a></dt>
<dd><p>The angles for the Givens rotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOp.phis">
<span class="sig-name descname"><span class="pre">phis</span></span><a class="headerlink" href="#ffsim.GivensAnsatzOp.phis" title="Link to this definition">¶</a></dt>
<dd><p>The optional phase angles for the Givens rotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOp.phase_angles">
<span class="sig-name descname"><span class="pre">phase_angles</span></span><a class="headerlink" href="#ffsim.GivensAnsatzOp.phase_angles" title="Link to this definition">¶</a></dt>
<dd><p>The optional phase angles for the layer of
single-orbital phase gates.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOp.from_orbital_rotation">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_orbital_rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orbital_rotation</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/givens.html#GivensAnsatzOp.from_orbital_rotation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.GivensAnsatzOp.from_orbital_rotation" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the operator from an orbital rotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The orbital rotation.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.GivensAnsatzOp" title="ffsim.variational.givens.GivensAnsatzOp"><code class="xref py py-class docutils literal notranslate"><span class="pre">GivensAnsatzOp</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOp.from_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_phis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_phase_angles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/givens.html#GivensAnsatzOp.from_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.GivensAnsatzOp.from_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the operator from a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The real-valued parameter vector.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – The orbital pairs to apply the Givens rotation gates to.</p></li>
<li><p><strong>with_phis</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include complex phases for the Givens rotations.</p></li>
<li><p><strong>with_phase_angles</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include a layer of single-orbital phase gates.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.GivensAnsatzOp" title="ffsim.variational.givens.GivensAnsatzOp"><code class="xref py py-class docutils literal notranslate"><span class="pre">GivensAnsatzOp</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOp.n_params">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_phis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_phase_angles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/givens.html#GivensAnsatzOp.n_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.GivensAnsatzOp.n_params" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of parameters of an ansatz with given settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – The orbital pairs to apply the Givens rotation gates to.</p></li>
<li><p><strong>with_phis</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include complex phases for the Givens rotations.</p></li>
<li><p><strong>with_phase_angles</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include a layer of single-orbital phase gates.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOp.to_orbital_rotation">
<span class="sig-name descname"><span class="pre">to_orbital_rotation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/givens.html#GivensAnsatzOp.to_orbital_rotation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.GivensAnsatzOp.to_orbital_rotation" title="Link to this definition">¶</a></dt>
<dd><p>Convert the Givens ansatz operator to an orbital rotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.GivensAnsatzOp.to_parameters">
<span class="sig-name descname"><span class="pre">to_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/givens.html#GivensAnsatzOp.to_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.GivensAnsatzOp.to_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Convert the operator to a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.HopGateAnsatzOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">HopGateAnsatzOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thetas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/hopgate.html#HopGateAnsatzOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.HopGateAnsatzOperator" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A hop gate ansatz operator.</p>
<p>The hop gate ansatz consists of a sequence of <a class="reference external" href="ffsim.html#ffsim.apply_hop_gate">hop gates</a>.</p>
<p>Note that this ansatz does not implement any interactions between spin alpha and
spin beta orbitals. It was designed to be used with <a class="reference external" href="https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.3.010309">entanglement forging</a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.HopGateAnsatzOperator.norb">
<span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.HopGateAnsatzOperator.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.HopGateAnsatzOperator.interaction_pairs">
<span class="sig-name descname"><span class="pre">interaction_pairs</span></span><a class="headerlink" href="#ffsim.HopGateAnsatzOperator.interaction_pairs" title="Link to this definition">¶</a></dt>
<dd><p>The orbital pairs to apply the hop
gates to.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[tuple[int, int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.HopGateAnsatzOperator.thetas">
<span class="sig-name descname"><span class="pre">thetas</span></span><a class="headerlink" href="#ffsim.HopGateAnsatzOperator.thetas" title="Link to this definition">¶</a></dt>
<dd><p>The rotation angles for the hop gates.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.HopGateAnsatzOperator.final_orbital_rotation">
<span class="sig-name descname"><span class="pre">final_orbital_rotation</span></span><a class="headerlink" href="#ffsim.HopGateAnsatzOperator.final_orbital_rotation" title="Link to this definition">¶</a></dt>
<dd><p>An optional final orbital rotation to
append to the ansatz, used to optimize the orbital basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.HopGateAnsatzOperator.from_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/hopgate.html#HopGateAnsatzOperator.from_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.HopGateAnsatzOperator.from_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the operator from a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The real-valued parameter vector.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – The orbital pairs to apply the hop gates to.</p></li>
<li><p><strong>with_final_orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include a final orbital rotation
in the ansatz operator.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.HopGateAnsatzOperator" title="ffsim.variational.hopgate.HopGateAnsatzOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">HopGateAnsatzOperator</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.HopGateAnsatzOperator.to_parameters">
<span class="sig-name descname"><span class="pre">to_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/hopgate.html#HopGateAnsatzOperator.to_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.HopGateAnsatzOperator.to_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Convert the operator to a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.MolecularData">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">MolecularData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">core_energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">one_body_integrals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_body_integrals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_space</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hf_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hf_mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hf_mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mp2_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mp2_t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ccsd_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ccsd_t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ccsd_t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cisd_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cisd_vec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sci_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sci_vec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fci_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fci_vec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_integrals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_symmetries</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class for storing molecular data.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.core_energy">
<span class="sig-name descname"><span class="pre">core_energy</span></span><a class="headerlink" href="#ffsim.MolecularData.core_energy" title="Link to this definition">¶</a></dt>
<dd><p>The core energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.one_body_integrals">
<span class="sig-name descname"><span class="pre">one_body_integrals</span></span><a class="headerlink" href="#ffsim.MolecularData.one_body_integrals" title="Link to this definition">¶</a></dt>
<dd><p>The one-body integrals.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.two_body_integrals">
<span class="sig-name descname"><span class="pre">two_body_integrals</span></span><a class="headerlink" href="#ffsim.MolecularData.two_body_integrals" title="Link to this definition">¶</a></dt>
<dd><p>The two-body integrals in compressed format.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.norb">
<span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.MolecularData.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.nelec">
<span class="sig-name descname"><span class="pre">nelec</span></span><a class="headerlink" href="#ffsim.MolecularData.nelec" title="Link to this definition">¶</a></dt>
<dd><p>The number of alpha and beta electrons.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[int, int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.atom">
<span class="sig-name descname"><span class="pre">atom</span></span><a class="headerlink" href="#ffsim.MolecularData.atom" title="Link to this definition">¶</a></dt>
<dd><p>The coordinates of
the atoms in the molecule.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[tuple[str, tuple[float, float, float]]] | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.basis">
<span class="sig-name descname"><span class="pre">basis</span></span><a class="headerlink" href="#ffsim.MolecularData.basis" title="Link to this definition">¶</a></dt>
<dd><p>The basis set, e.g. “sto-6g”.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.spin">
<span class="sig-name descname"><span class="pre">spin</span></span><a class="headerlink" href="#ffsim.MolecularData.spin" title="Link to this definition">¶</a></dt>
<dd><p>The spin of the molecule.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.symmetry">
<span class="sig-name descname"><span class="pre">symmetry</span></span><a class="headerlink" href="#ffsim.MolecularData.symmetry" title="Link to this definition">¶</a></dt>
<dd><p>The symmetry of the molecule.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.mo_coeff">
<span class="sig-name descname"><span class="pre">mo_coeff</span></span><a class="headerlink" href="#ffsim.MolecularData.mo_coeff" title="Link to this definition">¶</a></dt>
<dd><p>Molecular orbital coefficients in the AO basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.mo_occ">
<span class="sig-name descname"><span class="pre">mo_occ</span></span><a class="headerlink" href="#ffsim.MolecularData.mo_occ" title="Link to this definition">¶</a></dt>
<dd><p>Molecular orbital occupancies.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.active_space">
<span class="sig-name descname"><span class="pre">active_space</span></span><a class="headerlink" href="#ffsim.MolecularData.active_space" title="Link to this definition">¶</a></dt>
<dd><p>The molecular orbitals included in the active
space.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[int] | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.hf_energy">
<span class="sig-name descname"><span class="pre">hf_energy</span></span><a class="headerlink" href="#ffsim.MolecularData.hf_energy" title="Link to this definition">¶</a></dt>
<dd><p>The Hartree-Fock energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.hf_mo_coeff">
<span class="sig-name descname"><span class="pre">hf_mo_coeff</span></span><a class="headerlink" href="#ffsim.MolecularData.hf_mo_coeff" title="Link to this definition">¶</a></dt>
<dd><p>Hartree-Fock canonical orbital coefficients in
the AO basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.hf_mo_occ">
<span class="sig-name descname"><span class="pre">hf_mo_occ</span></span><a class="headerlink" href="#ffsim.MolecularData.hf_mo_occ" title="Link to this definition">¶</a></dt>
<dd><p>Hartree-Fock canonical orbital occupancies.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.mp2_energy">
<span class="sig-name descname"><span class="pre">mp2_energy</span></span><a class="headerlink" href="#ffsim.MolecularData.mp2_energy" title="Link to this definition">¶</a></dt>
<dd><p>The MP2 energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.mp2_t2">
<span class="sig-name descname"><span class="pre">mp2_t2</span></span><a class="headerlink" href="#ffsim.MolecularData.mp2_t2" title="Link to this definition">¶</a></dt>
<dd><p>The
MP2 t2 amplitudes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | tuple[np.ndarray, np.ndarray, np.ndarray] | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.ccsd_energy">
<span class="sig-name descname"><span class="pre">ccsd_energy</span></span><a class="headerlink" href="#ffsim.MolecularData.ccsd_energy" title="Link to this definition">¶</a></dt>
<dd><p>The CCSD energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.ccsd_t1">
<span class="sig-name descname"><span class="pre">ccsd_t1</span></span><a class="headerlink" href="#ffsim.MolecularData.ccsd_t1" title="Link to this definition">¶</a></dt>
<dd><p>The CCSD t1
amplitudes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | tuple[np.ndarray, np.ndarray] | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.ccsd_t2">
<span class="sig-name descname"><span class="pre">ccsd_t2</span></span><a class="headerlink" href="#ffsim.MolecularData.ccsd_t2" title="Link to this definition">¶</a></dt>
<dd><p>The
CCSD t2 amplitudes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | tuple[np.ndarray, np.ndarray, np.ndarray] | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.cisd_energy">
<span class="sig-name descname"><span class="pre">cisd_energy</span></span><a class="headerlink" href="#ffsim.MolecularData.cisd_energy" title="Link to this definition">¶</a></dt>
<dd><p>The CISD energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.cisd_vec">
<span class="sig-name descname"><span class="pre">cisd_vec</span></span><a class="headerlink" href="#ffsim.MolecularData.cisd_vec" title="Link to this definition">¶</a></dt>
<dd><p>The CISD state vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.sci_energy">
<span class="sig-name descname"><span class="pre">sci_energy</span></span><a class="headerlink" href="#ffsim.MolecularData.sci_energy" title="Link to this definition">¶</a></dt>
<dd><p>The SCI energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.sci_vec">
<span class="sig-name descname"><span class="pre">sci_vec</span></span><a class="headerlink" href="#ffsim.MolecularData.sci_vec" title="Link to this definition">¶</a></dt>
<dd><p>The SCI state
vector coefficients, spin alpha strings, and spin beta strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[np.ndarray, np.ndarray, np.ndarray] | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.fci_energy">
<span class="sig-name descname"><span class="pre">fci_energy</span></span><a class="headerlink" href="#ffsim.MolecularData.fci_energy" title="Link to this definition">¶</a></dt>
<dd><p>The FCI energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.fci_vec">
<span class="sig-name descname"><span class="pre">fci_vec</span></span><a class="headerlink" href="#ffsim.MolecularData.fci_vec" title="Link to this definition">¶</a></dt>
<dd><p>The FCI state vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.dipole_integrals">
<span class="sig-name descname"><span class="pre">dipole_integrals</span></span><a class="headerlink" href="#ffsim.MolecularData.dipole_integrals" title="Link to this definition">¶</a></dt>
<dd><p>The dipole integrals.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularData.orbital_symmetries">
<span class="sig-name descname"><span class="pre">orbital_symmetries</span></span><a class="headerlink" href="#ffsim.MolecularData.orbital_symmetries" title="Link to this definition">¶</a></dt>
<dd><p>The orbital symmetries.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[str] | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.from_fcidump">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_fcidump</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.from_fcidump"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.from_fcidump" title="Link to this definition">¶</a></dt>
<dd><p>Initialize a MolecularData from an FCIDUMP file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">PathLike</span></code></span>) – The FCIDUMP file path.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.MolecularData" title="ffsim.molecular_data.MolecularData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularData</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.from_json">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_json</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compression</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.from_json"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.from_json" title="Link to this definition">¶</a></dt>
<dd><p>Load a MolecularData from a (possibly compressed) JSON file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">PathLike</span></code></span>) – The file path to read from.</p></li>
<li><p><strong>compression</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The compression algorithm, if any, which was used to compress
the file.
Options: <code class="docutils literal notranslate"><span class="pre">&quot;gzip&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;bz2&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;lzma&quot;</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.MolecularData" title="ffsim.molecular_data.MolecularData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularData</span></code></a></span></p>
</dd>
</dl>
<p>Returns: The MolecularData object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.from_scf">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hartree_fock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_space</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.from_scf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.from_scf" title="Link to this definition">¶</a></dt>
<dd><p>Initialize a MolecularData object from a Hartree-Fock calculation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hartree_fock</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">SCF</span></code></span>) – The Hartree-Fock object.</p></li>
<li><p><strong>active_space</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – An optional list of orbitals to use for the active space.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.MolecularData" title="ffsim.molecular_data.MolecularData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularData</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.MolecularData.hamiltonian">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hamiltonian</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="#ffsim.MolecularHamiltonian" title="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian"><span class="pre">MolecularHamiltonian</span></a></em><a class="headerlink" href="#ffsim.MolecularData.hamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>The Hamiltonian defined by the molecular data.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.MolecularData.mole">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mole</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Mole</span></em><a class="headerlink" href="#ffsim.MolecularData.mole" title="Link to this definition">¶</a></dt>
<dd><p>The PySCF Mole class for this molecular data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.run_ccsd">
<span class="sig-name descname"><span class="pre">run_ccsd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.run_ccsd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.run_ccsd" title="Link to this definition">¶</a></dt>
<dd><p>Run CCSD and store results.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.run_cisd">
<span class="sig-name descname"><span class="pre">run_cisd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_cisd_vec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.run_cisd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.run_cisd" title="Link to this definition">¶</a></dt>
<dd><p>Run CISD and store results.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.run_fci">
<span class="sig-name descname"><span class="pre">run_fci</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_fci_vec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.run_fci"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.run_fci" title="Link to this definition">¶</a></dt>
<dd><p>Run FCI and store results.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.run_mp2">
<span class="sig-name descname"><span class="pre">run_mp2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.run_mp2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.run_mp2" title="Link to this definition">¶</a></dt>
<dd><p>Run MP2 and store results.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.run_sci">
<span class="sig-name descname"><span class="pre">run_sci</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_sci_vec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.run_sci"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.run_sci" title="Link to this definition">¶</a></dt>
<dd><p>Run SCI and store results.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.MolecularData.scf">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">scf</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">SCF</span></em><a class="headerlink" href="#ffsim.MolecularData.scf" title="Link to this definition">¶</a></dt>
<dd><p>A PySCF SCF class for this molecular data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.to_fcidump">
<span class="sig-name descname"><span class="pre">to_fcidump</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.to_fcidump"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.to_fcidump" title="Link to this definition">¶</a></dt>
<dd><p>Save data to disk in FCIDUMP format.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The FCIDUMP format does not retain all information stored in the
MolecularData object. To serialize a MolecularData object losslessly, use
the <a class="reference internal" href="#ffsim.MolecularData.to_json" title="ffsim.MolecularData.to_json"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_json()</span></code></a> method to save to JSON format.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">PathLike</span></code></span>) – The file path to save to.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularData.to_json">
<span class="sig-name descname"><span class="pre">to_json</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compression</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/molecular_data.html#MolecularData.to_json"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularData.to_json" title="Link to this definition">¶</a></dt>
<dd><p>Serialize to JSON format, optionally compressed, and save to disk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">PathLike</span></code></span>) – The file path to save to.</p></li>
<li><p><strong>compression</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The optional compression algorithm to use.
Options: <code class="docutils literal notranslate"><span class="pre">&quot;gzip&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;bz2&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;lzma&quot;</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.MolecularHamiltonian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">MolecularHamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/molecular_hamiltonian.html#MolecularHamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularHamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A molecular Hamiltonian.</p>
<p>A Hamiltonian of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = \sum_{\sigma, pq} h_{pq} a^\dagger_{\sigma, p} a_{\sigma, q}
    + \frac12 \sum_{\sigma \tau, pqrs} h_{pqrs}
    a^\dagger_{\sigma, p} a^\dagger_{\tau, r} a_{\tau, s} a_{\sigma, q}
    + \text{constant}.\]</div>
</div>
<p>Here <span class="math notranslate nohighlight">\(h_{pq}\)</span> is called the one-body tensor and <span class="math notranslate nohighlight">\(h_{pqrs}\)</span> is called
the two-body tensor.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularHamiltonian.one_body_tensor">
<span class="sig-name descname"><span class="pre">one_body_tensor</span></span><a class="headerlink" href="#ffsim.MolecularHamiltonian.one_body_tensor" title="Link to this definition">¶</a></dt>
<dd><p>The one-body tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularHamiltonian.two_body_tensor">
<span class="sig-name descname"><span class="pre">two_body_tensor</span></span><a class="headerlink" href="#ffsim.MolecularHamiltonian.two_body_tensor" title="Link to this definition">¶</a></dt>
<dd><p>The two-body tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.MolecularHamiltonian.constant">
<span class="sig-name descname"><span class="pre">constant</span></span><a class="headerlink" href="#ffsim.MolecularHamiltonian.constant" title="Link to this definition">¶</a></dt>
<dd><p>The constant.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.MolecularHamiltonian.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#ffsim.MolecularHamiltonian.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.MolecularHamiltonian.rotated">
<span class="sig-name descname"><span class="pre">rotated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orbital_rotation</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/molecular_hamiltonian.html#MolecularHamiltonian.rotated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.MolecularHamiltonian.rotated" title="Link to this definition">¶</a></dt>
<dd><p>Return the Hamiltonian in a rotated orbital basis.</p>
<p>Given an orbital rotation <span class="math notranslate nohighlight">\(\mathcal{U}\)</span>, returns the operator</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{U} H \mathcal{U}^\dagger\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(H\)</span> is the original Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The orbital rotation.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.MolecularHamiltonian" title="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The rotated Hamiltonian.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.NumNumAnsatzOpSpinBalanced">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">NumNumAnsatzOpSpinBalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thetas</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/num_num.html#NumNumAnsatzOpSpinBalanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.NumNumAnsatzOpSpinBalanced" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A number-number interaction ansatz operator.</p>
<p>The number-number interaction ansatz consists of a sequence of
<a class="reference external" href="ffsim.html#ffsim.apply_num_num_interaction">number-number interactions</a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.NumNumAnsatzOpSpinBalanced.norb">
<span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.NumNumAnsatzOpSpinBalanced.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.NumNumAnsatzOpSpinBalanced.interaction_pairs">
<span class="sig-name descname"><span class="pre">interaction_pairs</span></span><a class="headerlink" href="#ffsim.NumNumAnsatzOpSpinBalanced.interaction_pairs" title="Link to this definition">¶</a></dt>
<dd><p>The orbital pairs to apply the
number-number interactions to.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[tuple[int, int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.NumNumAnsatzOpSpinBalanced.thetas">
<span class="sig-name descname"><span class="pre">thetas</span></span><a class="headerlink" href="#ffsim.NumNumAnsatzOpSpinBalanced.thetas" title="Link to this definition">¶</a></dt>
<dd><p>The angles for the number-number interactions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.NumNumAnsatzOpSpinBalanced.from_diag_coulomb_mats">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_diag_coulomb_mats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag_coulomb_mats</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/num_num.html#NumNumAnsatzOpSpinBalanced.from_diag_coulomb_mats"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.NumNumAnsatzOpSpinBalanced.from_diag_coulomb_mats" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the operator from a diagonal Coulomb matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>diag_coulomb_mats</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>] | <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The diagonal Coulomb matrices. Should be a pair
of matrices, with the first matrix representing same-spin interactions
and the second matrix representing different-spin interactions.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.NumNumAnsatzOpSpinBalanced" title="ffsim.variational.num_num.NumNumAnsatzOpSpinBalanced"><code class="xref py py-class docutils literal notranslate"><span class="pre">NumNumAnsatzOpSpinBalanced</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.NumNumAnsatzOpSpinBalanced.from_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/num_num.html#NumNumAnsatzOpSpinBalanced.from_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.NumNumAnsatzOpSpinBalanced.from_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the operator from a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The real-valued parameter vector.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]], <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]]</span>) – The orbital pairs to apply the number-number interactions
to.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.NumNumAnsatzOpSpinBalanced" title="ffsim.variational.num_num.NumNumAnsatzOpSpinBalanced"><code class="xref py py-class docutils literal notranslate"><span class="pre">NumNumAnsatzOpSpinBalanced</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.NumNumAnsatzOpSpinBalanced.n_params">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/num_num.html#NumNumAnsatzOpSpinBalanced.n_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.NumNumAnsatzOpSpinBalanced.n_params" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of parameters of an ansatz with given settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]], <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]]</span>) – The orbital pairs to apply the number-number interactions
to.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.NumNumAnsatzOpSpinBalanced.to_diag_coulomb_mats">
<span class="sig-name descname"><span class="pre">to_diag_coulomb_mats</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/num_num.html#NumNumAnsatzOpSpinBalanced.to_diag_coulomb_mats"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.NumNumAnsatzOpSpinBalanced.to_diag_coulomb_mats" title="Link to this definition">¶</a></dt>
<dd><p>Convert the operator to diagonal Coulomb matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Numpy array of shape (2, norb, norb) holding two matrices. The first
matrix holds the same-spin interactions and the second matrix holds the
different-spin interactions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.NumNumAnsatzOpSpinBalanced.to_parameters">
<span class="sig-name descname"><span class="pre">to_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/num_num.html#NumNumAnsatzOpSpinBalanced.to_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.NumNumAnsatzOpSpinBalanced.to_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Convert the operator to a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.ProductStateSum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">ProductStateSum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeffs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">np.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">np.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">np.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/product_state_sum.html#ProductStateSum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.ProductStateSum" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">NamedTuple</span></code></p>
<p>A linear combination of product states.</p>
<p>Given a ProductStateSum <code class="docutils literal notranslate"><span class="pre">prod_state_sum</span></code>, the full state vector can be
reconstructed as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">(</span>
    <span class="n">coeff</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">vec_a</span><span class="p">,</span> <span class="n">vec_b</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">coeff</span><span class="p">,</span> <span class="p">(</span><span class="n">vec_a</span><span class="p">,</span> <span class="n">vec_b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">prod_state_sum</span><span class="o">.</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">prod_state_sum</span><span class="o">.</span><span class="n">states</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.ProductStateSum.coeffs">
<span class="sig-name descname"><span class="pre">coeffs</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></em><a class="headerlink" href="#ffsim.ProductStateSum.coeffs" title="Link to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.ProductStateSum.states">
<span class="sig-name descname"><span class="pre">states</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code><span class="pre">[</span><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code><span class="pre">[</span><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code><span class="pre">,</span> <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code><span class="pre">]]</span></em><a class="headerlink" href="#ffsim.ProductStateSum.states" title="Link to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">SingleFactorizedHamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">one_body_squares</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/single_factorized_hamiltonian.html#SingleFactorizedHamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A Hamiltonian in the single-factorized representation.</p>
<p>The single-factorized form of the molecular Hamiltonian is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = \sum_{\sigma, pq} \kappa_{pq} a^\dagger_{\sigma, p} a_{\sigma, q}
+ \frac12 \sum_{t=1}^L \left(\mathcal{M}^{(t)}\right)^2
+ \text{constant}'.\]</div>
</div>
<p>Here each <span class="math notranslate nohighlight">\(\mathcal{M}^{(t)}\)</span> is a one-body operator:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{M}^{(t)} =
\sum_{\sigma, pq} M^{(t)}_{pq} a^\dagger_{\sigma, p} a_{\sigma, q}\]</div>
</div>
<p>where each <span class="math notranslate nohighlight">\(M^{(t)}\)</span> is a Hermitian matrix.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian.one_body_tensor">
<span class="sig-name descname"><span class="pre">one_body_tensor</span></span><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian.one_body_tensor" title="Link to this definition">¶</a></dt>
<dd><p>The one-body tensor <span class="math notranslate nohighlight">\(\kappa\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian.one_body_squares">
<span class="sig-name descname"><span class="pre">one_body_squares</span></span><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian.one_body_squares" title="Link to this definition">¶</a></dt>
<dd><p>The one-body tensors <span class="math notranslate nohighlight">\(M^{(t)}\)</span> whose
squares are summed in the Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian.constant">
<span class="sig-name descname"><span class="pre">constant</span></span><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian.constant" title="Link to this definition">¶</a></dt>
<dd><p>The constant.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian.expectation_product_state">
<span class="sig-name descname"><span class="pre">expectation_product_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/single_factorized_hamiltonian.html#SingleFactorizedHamiltonian.expectation_product_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian.expectation_product_state" title="Link to this definition">¶</a></dt>
<dd><p>Return expectation value with respect to a product state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</span>) – The product state, as a pair <cite>(vec_a, vec_b)</cite> containing the alpha and
beta components of the state.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian.from_molecular_hamiltonian">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_molecular_hamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_vecs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cholesky</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/single_factorized_hamiltonian.html#SingleFactorizedHamiltonian.from_molecular_hamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian.from_molecular_hamiltonian" title="Link to this definition">¶</a></dt>
<dd><p>Initialize a SingleFactorizedHamiltonian from a MolecularHamiltonian.</p>
<p>The number of terms in the decomposition depends on the allowed
error threshold. A larger error threshold leads to a smaller number of terms.
Furthermore, the <cite>max_vecs</cite> parameter specifies an optional upper bound
on the number of terms.</p>
<p>Note: Currently, only real-valued two-body tensors are supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hamiltonian</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.MolecularHamiltonian" title="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a></span>) – The Hamiltonian whose single-factorized representation to
compute.</p></li>
<li><p><strong>tol</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – Tolerance for error in the decomposition.
The error is defined as the maximum absolute difference between
an element of the original tensor and the corresponding element of
the reconstructed tensor.</p></li>
<li><p><strong>max_vecs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – An optional limit on the number of terms to keep in the
decomposition of the two-body tensor. This argument overrides <code class="docutils literal notranslate"><span class="pre">tol</span></code>.</p></li>
<li><p><strong>cholesky</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to perform the factorization using a modified Cholesky
decomposition. If False, a full eigenvalue decomposition is used
instead, which can be much more expensive.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian" title="ffsim.hamiltonians.single_factorized_hamiltonian.SingleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The single-factorized Hamiltonian.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.SingleFactorizedHamiltonian.reduced_matrix_product_states">
<span class="sig-name descname"><span class="pre">reduced_matrix_product_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vecs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/hamiltonians/single_factorized_hamiltonian.html#SingleFactorizedHamiltonian.reduced_matrix_product_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SingleFactorizedHamiltonian.reduced_matrix_product_states" title="Link to this definition">¶</a></dt>
<dd><p>Return reduced matrix within a subspace spanned by some product states.</p>
<p>Given a list of product states <span class="math notranslate nohighlight">\(\{\lvert \alpha_i, \beta_i \rangle\}\)</span>,
returns the matrix M where
<span class="math notranslate nohighlight">\(M_{ij} = \langle \alpha_i, \beta_i \rvert
H \lvert \alpha_j, \beta_j \rangle\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vecs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]]</span>) – The product states, as a list of pairs <cite>(vec_a, vec_b)</cite> containing
the alpha and beta components of each state.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The reduced matrix.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.Spin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">Spin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names=&lt;not</span> <span class="pre">given&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">module=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qualname=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary=None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/spin.html#Spin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.Spin" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Flag</span></code></p>
<p>Enumeration for indicating alpha, beta, or both spins.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.Spin.ALPHA">
<span class="sig-name descname"><span class="pre">ALPHA</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#ffsim.Spin.ALPHA" title="Link to this definition">¶</a></dt>
<dd><p>Use this to indicate spin alpha.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.Spin.ALPHA_AND_BETA">
<span class="sig-name descname"><span class="pre">ALPHA_AND_BETA</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#ffsim.Spin.ALPHA_AND_BETA" title="Link to this definition">¶</a></dt>
<dd><p>Use this to indicate both spin alpha and spin beta.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.Spin.BETA">
<span class="sig-name descname"><span class="pre">BETA</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#ffsim.Spin.BETA" title="Link to this definition">¶</a></dt>
<dd><p>Use this to indicate spin beta.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.StateVector">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">StateVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/states.html#StateVector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.StateVector" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A state vector in the FCI representation.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.StateVector.vec">
<span class="sig-name descname"><span class="pre">vec</span></span><a class="headerlink" href="#ffsim.StateVector.vec" title="Link to this definition">¶</a></dt>
<dd><p>Array of state vector coefficients.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.StateVector.norb">
<span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.StateVector.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.StateVector.nelec">
<span class="sig-name descname"><span class="pre">nelec</span></span><a class="headerlink" href="#ffsim.StateVector.nelec" title="Link to this definition">¶</a></dt>
<dd><p>Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.SupportsApplyUnitary">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">SupportsApplyUnitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/apply_unitary_protocol.html#SupportsApplyUnitary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SupportsApplyUnitary" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></p>
<p>An object that can apply a unitary transformation to a vector.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.SupportsApproximateEquality">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">SupportsApproximateEquality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/approximate_equality_protocol.html#SupportsApproximateEquality"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SupportsApproximateEquality" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></p>
<p>An object that can be compared approximately.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.SupportsDiagonal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">SupportsDiagonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/diagonal_protocol.html#SupportsDiagonal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SupportsDiagonal" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></p>
<p>A linear operator whose diagonal entries can be returned.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.SupportsFermionOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">SupportsFermionOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/fermion_operator_protocol.html#SupportsFermionOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SupportsFermionOperator" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></p>
<p>An object that can be converted to a FermionOperator.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.SupportsLinearOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">SupportsLinearOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/linear_operator_protocol.html#SupportsLinearOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SupportsLinearOperator" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></p>
<p>An object that can be converted to a SciPy LinearOperator.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.SupportsTrace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">SupportsTrace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/trace_protocol.html#SupportsTrace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.SupportsTrace" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></p>
<p>A linear operator whose trace can be computed.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.UCCSDOpRestrictedReal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">UCCSDOpRestrictedReal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/uccsd.html#UCCSDOpRestrictedReal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCCSDOpRestrictedReal" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Real-valued restricted unitary coupled cluster, singles and doubles operator.</p>
<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCCSDOpRestrictedReal.from_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nocc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/uccsd.html#UCCSDOpRestrictedReal.from_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCCSDOpRestrictedReal.from_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the UCCSD operator from a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The real-valued parameter vector.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nocc</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals that are occupied by electrons.</p></li>
<li><p><strong>with_final_orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include a final orbital rotation
in the operator.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.UCCSDOpRestrictedReal" title="ffsim.variational.uccsd.UCCSDOpRestrictedReal"><code class="xref py py-class docutils literal notranslate"><span class="pre">UCCSDOpRestrictedReal</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The UCCSD operator constructed from the given parameters.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – The number of parameters passed did not match the number
    expected based on the function inputs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCCSDOpRestrictedReal.n_params">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nocc</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/uccsd.html#UCCSDOpRestrictedReal.n_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCCSDOpRestrictedReal.n_params" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of parameters of an ansatz with given settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nocc</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals that are occupied by electrons.</p></li>
<li><p><strong>with_final_orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include a final orbital rotation
in the operator.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of parameters of the ansatz.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.UCCSDOpRestrictedReal.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.UCCSDOpRestrictedReal.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCCSDOpRestrictedReal.to_parameters">
<span class="sig-name descname"><span class="pre">to_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/uccsd.html#UCCSDOpRestrictedReal.to_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCCSDOpRestrictedReal.to_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Convert the UCCSD operator to a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The real-valued parameter vector.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.UCJAnglesOpSpinBalanced">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">UCJAnglesOpSpinBalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_num_ansatz_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">givens_ansatz_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_givens_ansatz_op</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_angles_spin_balanced.html#UCJAnglesOpSpinBalanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJAnglesOpSpinBalanced" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A spin-balanced UCJ operator parameterized by gate rotation angles.</p>
<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJAnglesOpSpinBalanced.from_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_num_interaction_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">givens_interaction_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_givens_ansatz_op</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_angles_spin_balanced.html#UCJAnglesOpSpinBalanced.from_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJAnglesOpSpinBalanced.from_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the UCJ operator from a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.UCJAnglesOpSpinBalanced" title="ffsim.variational.ucj_angles_spin_balanced.UCJAnglesOpSpinBalanced"><code class="xref py py-class docutils literal notranslate"><span class="pre">UCJAnglesOpSpinBalanced</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJAnglesOpSpinBalanced.from_t_amplitudes">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_t_amplitudes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_angles_spin_balanced.html#UCJAnglesOpSpinBalanced.from_t_amplitudes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJAnglesOpSpinBalanced.from_t_amplitudes" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the UCJ operator from t2 (and optionally t1) amplitudes.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.UCJAnglesOpSpinBalanced" title="ffsim.variational.ucj_angles_spin_balanced.UCJAnglesOpSpinBalanced"><code class="xref py py-class docutils literal notranslate"><span class="pre">UCJAnglesOpSpinBalanced</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJAnglesOpSpinBalanced.from_ucj_op">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_ucj_op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ucj_op</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_angles_spin_balanced.html#UCJAnglesOpSpinBalanced.from_ucj_op"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJAnglesOpSpinBalanced.from_ucj_op" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the angles-based UCJ operator from a matrix-based UCJ operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.UCJAnglesOpSpinBalanced" title="ffsim.variational.ucj_angles_spin_balanced.UCJAnglesOpSpinBalanced"><code class="xref py py-class docutils literal notranslate"><span class="pre">UCJAnglesOpSpinBalanced</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJAnglesOpSpinBalanced.n_params">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_num_interaction_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">givens_interaction_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_givens_ansatz_op</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_angles_spin_balanced.html#UCJAnglesOpSpinBalanced.n_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJAnglesOpSpinBalanced.n_params" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of parameters of an ansatz with given settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.UCJAnglesOpSpinBalanced.n_reps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_reps</span></span><a class="headerlink" href="#ffsim.UCJAnglesOpSpinBalanced.n_reps" title="Link to this definition">¶</a></dt>
<dd><p>The number of ansatz repetitions.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJAnglesOpSpinBalanced.to_parameters">
<span class="sig-name descname"><span class="pre">to_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_angles_spin_balanced.html#UCJAnglesOpSpinBalanced.to_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJAnglesOpSpinBalanced.to_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Convert the UCJ operator to a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinBalanced">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">UCJOpSpinBalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag_coulomb_mats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spin_balanced.html#UCJOpSpinBalanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinBalanced" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A spin-balanced unitary cluster Jastrow operator.</p>
<p>A unitary cluster Jastrow (UCJ) operator has the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\prod_{k = 1}^L \mathcal{U}_k e^{i \mathcal{J}_k} \mathcal{U}_k^\dagger\]</div>
</div>
<p>where each <span class="math notranslate nohighlight">\(\mathcal{U_k}\)</span> is an orbital rotation and each <span class="math notranslate nohighlight">\(\mathcal{J}\)</span>
is a diagonal Coulomb operator of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{J} = \frac12\sum_{\sigma \tau, ij}
\mathbf{J}^{(\sigma \tau)}_{ij} n_{\sigma, i} n_{\tau, j}.\]</div>
</div>
<p>For the spin-balanced operator, we require that
<span class="math notranslate nohighlight">\(\mathbf{J}^{(\alpha \alpha)} = \mathbf{J}^{(\beta \beta)}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{J}^{(\alpha \beta)} = \mathbf{J}^{(\beta \alpha)}\)</span>.
Therefore, each diagonal Coulomb operator is described by 2 matrices,
<span class="math notranslate nohighlight">\(\mathbf{J}^{(\alpha \alpha)}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{J}^{(\alpha \beta)}\)</span>, and
both of these matrices are symmetric.
Furthermore, each orbital rotation is described by a single matrix because the
same orbital rotation is applied to both spin alpha and spin beta.
The number of terms <span class="math notranslate nohighlight">\(L\)</span> is referred to as the
number of ansatz repetitions and is accessible via the <cite>n_reps</cite> attribute.</p>
<p>To support variational optimization of the orbital basis, an optional final
orbital rotation can be included in the operator, to be performed at the end.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinBalanced.diag_coulomb_mats">
<span class="sig-name descname"><span class="pre">diag_coulomb_mats</span></span><a class="headerlink" href="#ffsim.UCJOpSpinBalanced.diag_coulomb_mats" title="Link to this definition">¶</a></dt>
<dd><p>The diagonal Coulomb matrices, as a Numpy array
of shape <cite>(n_reps, 2, norb, norb)</cite>
The last two axes index the rows and columns of
the matrices, and the third from last axis, which has 2 dimensions, indexes
the spin interaction type of the matrix: alpha-alpha, and then alpha-beta.
The first axis indexes the ansatz repetitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinBalanced.orbital_rotations">
<span class="sig-name descname"><span class="pre">orbital_rotations</span></span><a class="headerlink" href="#ffsim.UCJOpSpinBalanced.orbital_rotations" title="Link to this definition">¶</a></dt>
<dd><p>The orbital rotations, as a Numpy array
of shape <cite>(n_reps, norb, norb)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinBalanced.final_orbital_rotation">
<span class="sig-name descname"><span class="pre">final_orbital_rotation</span></span><a class="headerlink" href="#ffsim.UCJOpSpinBalanced.final_orbital_rotation" title="Link to this definition">¶</a></dt>
<dd><p>The optional final orbital rotation,
as a Numpy array of shape <cite>(norb, norb)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinBalanced.from_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spin_balanced.html#UCJOpSpinBalanced.from_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinBalanced.from_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the UCJ operator from a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The real-valued parameter vector.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>n_reps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of ansatz repetitions.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Optional restrictions on allowed orbital interactions
for the diagonal Coulomb operators.
If specified, <cite>interaction_pairs</cite> should be a pair of lists,
for alpha-alpha and alpha-beta interactions, in that order.
Either list can be substituted with <code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate no restrictions
on interactions.
Each list should contain pairs of integers representing the orbitals
that are allowed to interact. These pairs can also be interpreted as
indices of diagonal Coulomb matrix entries that are allowed to be
nonzero.
Each integer pair must be upper triangular, that is, of the form
<span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>.</p></li>
<li><p><strong>with_final_orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include a final orbital rotation
in the operator.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.UCJOpSpinBalanced" title="ffsim.variational.ucj_spin_balanced.UCJOpSpinBalanced"><code class="xref py py-class docutils literal notranslate"><span class="pre">UCJOpSpinBalanced</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The UCJ operator constructed from the given parameters.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – The number of parameters passed did not match the number
    expected based on the function inputs.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list contained duplicate interactions.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list contained lower triangular pairs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinBalanced.from_t_amplitudes">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_t_amplitudes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spin_balanced.html#UCJOpSpinBalanced.from_t_amplitudes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinBalanced.from_t_amplitudes" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the UCJ operator from t2 (and optionally t1) amplitudes.</p>
<p>Performs a double-factorization of the t2 amplitudes and constructs the
ansatz repetitions from the terms of the decomposition, up to an optionally
specified number of ansatz repetitions. Terms are included in decreasing order
of the absolute value of the corresponding eigenvalue in the factorization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t2</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The t2 amplitudes.</p></li>
<li><p><strong>t1</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The t1 amplitudes.</p></li>
<li><p><strong>n_reps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The number of ansatz repetitions. If not specified, then it is set
to the number of terms resulting from the double-factorization of the
t2 amplitudes. If the specified number of repetitions is larger than the
number of terms resulting from the double-factorization, then the ansatz
is padded with additional identity operators up to the specified number
of repetitions.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Optional restrictions on allowed orbital interactions
for the diagonal Coulomb operators.
If specified, <cite>interaction_pairs</cite> should be a pair of lists,
for alpha-alpha and alpha-beta interactions, in that order.
Either list can be substituted with <code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate no restrictions
on interactions.
Each list should contain pairs of integers representing the orbitals
that are allowed to interact. These pairs can also be interpreted as
indices of diagonal Coulomb matrix entries that are allowed to be
nonzero.
Each integer pair must be upper triangular, that is, of the form
<span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>.</p></li>
<li><p><strong>tol</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – Tolerance for error in the double-factorized decomposition of the
t2 amplitudes.
The error is defined as the maximum absolute difference between
an element of the original tensor and the corresponding element of
the reconstructed tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.UCJOpSpinBalanced" title="ffsim.variational.ucj_spin_balanced.UCJOpSpinBalanced"><code class="xref py py-class docutils literal notranslate"><span class="pre">UCJOpSpinBalanced</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The UCJ operator with parameters initialized from the t2 amplitudes.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – Interaction pairs list contained duplicate interactions.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list contained lower triangular pairs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinBalanced.n_params">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spin_balanced.html#UCJOpSpinBalanced.n_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinBalanced.n_params" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of parameters of an ansatz with given settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>n_reps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of ansatz repetitions.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Optional restrictions on allowed orbital interactions
for the diagonal Coulomb operators.
If specified, <cite>interaction_pairs</cite> should be a pair of lists,
for alpha-alpha and alpha-beta interactions, in that order.
Either list can be substituted with <code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate no restrictions
on interactions.
Each list should contain pairs of integers representing the orbitals
that are allowed to interact. These pairs can also be interpreted as
indices of diagonal Coulomb matrix entries that are allowed to be
nonzero.
Each integer pair must be upper triangular, that is, of the form
<span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>.</p></li>
<li><p><strong>with_final_orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include a final orbital rotation
in the operator.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of parameters of the ansatz.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – Interaction pairs list contained duplicate interactions.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list contained lower triangular pairs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinBalanced.n_reps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_reps</span></span><a class="headerlink" href="#ffsim.UCJOpSpinBalanced.n_reps" title="Link to this definition">¶</a></dt>
<dd><p>The number of ansatz repetitions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinBalanced.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.UCJOpSpinBalanced.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinBalanced.to_parameters">
<span class="sig-name descname"><span class="pre">to_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spin_balanced.html#UCJOpSpinBalanced.to_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinBalanced.to_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Convert the UCJ operator to a real-valued parameter vector.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <cite>interaction_pairs</cite> is specified, the returned parameter vector will
incorporate only the diagonal Coulomb matrix entries corresponding to the
specified interactions, so the original operator will not be recoverable
from the parameter vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Optional restrictions on allowed orbital interactions
for the diagonal Coulomb operators.
If specified, <cite>interaction_pairs</cite> should be a pair of lists,
for alpha-alpha and alpha-beta interactions, in that order.
Either list can be substituted with <code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate no restrictions
on interactions.
Each list should contain pairs of integers representing the orbitals
that are allowed to interact. These pairs can also be interpreted as
indices of diagonal Coulomb matrix entries that are allowed to be
nonzero.
Each integer pair must be upper triangular, that is, of the form
<span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The real-valued parameter vector.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – Interaction pairs list contained duplicate interactions.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list contained lower triangular pairs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinUnbalanced">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">UCJOpSpinUnbalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag_coulomb_mats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spin_unbalanced.html#UCJOpSpinUnbalanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinUnbalanced" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A spin-unbalanced unitary cluster Jastrow operator.</p>
<p>A unitary cluster Jastrow (UCJ) operator has the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\prod_{k = 1}^L \mathcal{U}_k e^{i \mathcal{J}_k} \mathcal{U}_k^\dagger\]</div>
</div>
<p>where each <span class="math notranslate nohighlight">\(\mathcal{U_k}\)</span> is an orbital rotation and each <span class="math notranslate nohighlight">\(\mathcal{J}\)</span>
is a diagonal Coulomb operator of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{J} = \frac12\sum_{\sigma \tau, ij}
\mathbf{J}^{(\sigma \tau)}_{ij} n_{\sigma, i} n_{\tau, j}.\]</div>
</div>
<p>Since <span class="math notranslate nohighlight">\(\mathbf{J}^{(\sigma \tau)}_{ij} = \mathbf{J}^{(\tau \sigma)}_{ji}\)</span>,
each diagonal Coulomb operator requires 3 matrices for its description:
<span class="math notranslate nohighlight">\(\mathbf{J}^{(\alpha \alpha)}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{J}^{(\alpha \beta)}\)</span>, and
<span class="math notranslate nohighlight">\(\mathbf{J}^{(\beta \beta)}\)</span>. The number of terms <span class="math notranslate nohighlight">\(L\)</span> is referred to as
the number of ansatz repetitions and is accessible via the <cite>n_reps</cite> attribute.</p>
<p>To support variational optimization of the orbital basis, an optional final
orbital rotation can be included in the operator, to be performed at the end.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinUnbalanced.diag_coulomb_mats">
<span class="sig-name descname"><span class="pre">diag_coulomb_mats</span></span><a class="headerlink" href="#ffsim.UCJOpSpinUnbalanced.diag_coulomb_mats" title="Link to this definition">¶</a></dt>
<dd><p>The diagonal Coulomb matrices, as a Numpy array
of shape <cite>(n_reps, 3, norb, norb)</cite>
The last two axes index the rows and columns of
the matrices, and the third from last axis, which has 3 dimensions, indexes
the spin interaction type of the matrix: alpha-alpha, alpha-beta, and
beta-beta (in that order).
The first axis indexes the ansatz repetitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinUnbalanced.orbital_rotations">
<span class="sig-name descname"><span class="pre">orbital_rotations</span></span><a class="headerlink" href="#ffsim.UCJOpSpinUnbalanced.orbital_rotations" title="Link to this definition">¶</a></dt>
<dd><p>The orbital rotations, as a Numpy array of shape
<cite>(n_reps, 2, norb, norb)</cite>. The last two axes index the rows and columns
of the orbital rotations, and the third from last axis, which has 2
dimensions, indexes the spin sector of the orbital rotation: first alpha,
then beta.
The first axis indexes the ansatz repetitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinUnbalanced.final_orbital_rotation">
<span class="sig-name descname"><span class="pre">final_orbital_rotation</span></span><a class="headerlink" href="#ffsim.UCJOpSpinUnbalanced.final_orbital_rotation" title="Link to this definition">¶</a></dt>
<dd><p>The optional final orbital rotation,
as a Numpy array of shape <cite>(2, norb, norb)</cite>. This can be viewed as a list of
two orbital rotations, the first one for spin alpha and the second one for
spin beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinUnbalanced.from_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spin_unbalanced.html#UCJOpSpinUnbalanced.from_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinUnbalanced.from_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the UCJ operator from a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The real-valued parameter vector.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>n_reps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of ansatz repetitions.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Optional restrictions on allowed orbital interactions
for the diagonal Coulomb operators.
If specified, <cite>interaction_pairs</cite> should be a tuple of 3 lists,
for alpha-alpha, alpha-beta, and beta-beta interactions, in that order.
Any list can be substituted with <code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate no restrictions
on interactions.
Each list should contain pairs of integers representing the orbitals
that are allowed to interact. These pairs can also be interpreted as
indices of diagonal Coulomb matrix entries that are allowed to be
nonzero.
For the alpha-alpha and beta-beta interactions, each integer
pair must be upper triangular, that is, of the form <span class="math notranslate nohighlight">\((i, j)\)</span> where
<span class="math notranslate nohighlight">\(i \leq j\)</span>.</p></li>
<li><p><strong>with_final_orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include a final orbital rotation
in the operator.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.UCJOpSpinUnbalanced" title="ffsim.variational.ucj_spin_unbalanced.UCJOpSpinUnbalanced"><code class="xref py py-class docutils literal notranslate"><span class="pre">UCJOpSpinUnbalanced</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The UCJ operator constructed from the given parameters.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – The number of parameters passed did not match the number
    expected based on the function inputs.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list contained duplicate interactions.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list for alpha-alpha or beta-beta interactions
    contained lower triangular pairs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinUnbalanced.from_t_amplitudes">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_t_amplitudes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spin_unbalanced.html#UCJOpSpinUnbalanced.from_t_amplitudes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinUnbalanced.from_t_amplitudes" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the UCJ operator from t2 (and optionally t1) amplitudes.</p>
<p>Performs a double-factorization of the t2 amplitudes and constructs the
ansatz repetitions from the terms of the decomposition, up to an optionally
specified number of repetitions. Terms are included in decreasing order
of the magnitude of the corresponding singular value in the factorization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t2</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</span>) – The t2 amplitudes. This should be a tuple of 3 Numpy arrays,
<cite>(t2aa, t2ab, t2bb)</cite>, containing the alpha-alpha, alpha-beta, and
beta-beta t2 amplitudes.</p></li>
<li><p><strong>t1</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The t1 amplitudes. This should be a pair of Numpy arrays, <cite>(t1a, t1b)</cite>,
containing the alpha and beta t1 amplitudes.</p></li>
<li><p><strong>n_reps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The number of ansatz repetitions.
You can pass a single integer or a pair of integers.
If a single integer, terms from the alpha-beta t2 amplitudes are
used before including any terms from the alpha-alpha and beta-beta
t2 amplitudes. If a pair of integers, then the first integer specifies
the number of terms to use from the alpha-beta t2 amplitudes,
and the second integer specifies the number of terms to use from the
alpha-alpha and beta-beta t2 amplitudes.
If not specified, then it is set
to the number of terms resulting from the double-factorization of the
t2 amplitudes. If the specified number of repetitions is larger than the
number of terms resulting from the double-factorization, then the ansatz
is padded with additional identity operators up to the specified number
of repetitions.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Optional restrictions on allowed orbital interactions
for the diagonal Coulomb operators.
If specified, <cite>interaction_pairs</cite> should be a tuple of 3 lists,
for alpha-alpha, alpha-beta, and beta-beta interactions, in that order.
Any list can be substituted with <code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate no restrictions
on interactions.
Each list should contain pairs of integers representing the orbitals
that are allowed to interact. These pairs can also be interpreted as
indices of diagonal Coulomb matrix entries that are allowed to be
nonzero.
For the alpha-alpha and beta-beta interactions, each integer
pair must be upper triangular, that is, of the form <span class="math notranslate nohighlight">\((i, j)\)</span> where
<span class="math notranslate nohighlight">\(i \leq j\)</span>.</p></li>
<li><p><strong>tol</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – Tolerance for error in the double-factorized decomposition of the
t2 amplitudes.
The error is defined as the maximum absolute difference between
an element of the original tensor and the corresponding element of
the reconstructed tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.UCJOpSpinUnbalanced" title="ffsim.variational.ucj_spin_unbalanced.UCJOpSpinUnbalanced"><code class="xref py py-class docutils literal notranslate"><span class="pre">UCJOpSpinUnbalanced</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The UCJ operator with parameters initialized from the t2 amplitudes.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – Interaction pairs list contained duplicate interactions.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list for alpha-alpha or beta-beta interactions
    contained lower triangular pairs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinUnbalanced.n_params">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spin_unbalanced.html#UCJOpSpinUnbalanced.n_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinUnbalanced.n_params" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of parameters of an ansatz with given settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>n_reps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of ansatz repetitions.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Optional restrictions on allowed orbital interactions
for the diagonal Coulomb operators.
If specified, <cite>interaction_pairs</cite> should be a tuple of 3 lists,
for alpha-alpha, alpha-beta, and beta-beta interactions, in that order.
Any list can be substituted with <code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate no restrictions
on interactions.
Each list should contain pairs of integers representing the orbitals
that are allowed to interact. These pairs can also be interpreted as
indices of diagonal Coulomb matrix entries that are allowed to be
nonzero.
For the alpha-alpha and beta-beta interactions, each integer
pair must be upper triangular, that is, of the form <span class="math notranslate nohighlight">\((i, j)\)</span> where
<span class="math notranslate nohighlight">\(i \leq j\)</span>.</p></li>
<li><p><strong>with_final_orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include a final orbital rotation
in the operator.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of parameters of the ansatz.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – Interaction pairs list contained duplicate interactions.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list for alpha-alpha or beta-beta interactions
    contained lower triangular pairs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinUnbalanced.n_reps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_reps</span></span><a class="headerlink" href="#ffsim.UCJOpSpinUnbalanced.n_reps" title="Link to this definition">¶</a></dt>
<dd><p>The number of ansatz repetitions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinUnbalanced.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.UCJOpSpinUnbalanced.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinUnbalanced.to_parameters">
<span class="sig-name descname"><span class="pre">to_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spin_unbalanced.html#UCJOpSpinUnbalanced.to_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinUnbalanced.to_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Convert the UCJ operator to a real-valued parameter vector.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <cite>interaction_pairs</cite> is specified, the returned parameter vector will
incorporate only the diagonal Coulomb matrix entries corresponding to the
specified interactions, so the original operator will not be recoverable
from the parameter vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Optional restrictions on allowed orbital interactions
for the diagonal Coulomb operators.
If specified, <cite>interaction_pairs</cite> should be a tuple of 3 lists,
for alpha-alpha, alpha-beta, and beta-beta interactions, in that order.
Any list can be substituted with <code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate no restrictions
on interactions.
Each list should contain pairs of integers representing the orbitals
that are allowed to interact. These pairs can also be interpreted as
indices of diagonal Coulomb matrix entries that are allowed to be
nonzero.
For the alpha-alpha and beta-beta interactions, each integer
pair must be upper triangular, that is, of the form <span class="math notranslate nohighlight">\((i, j)\)</span> where
<span class="math notranslate nohighlight">\(i \leq j\)</span>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The real-valued parameter vector.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – Interaction pairs list contained duplicate interactions.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list for alpha-alpha or beta-beta interactions
    contained lower triangular pairs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinless">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">UCJOpSpinless</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag_coulomb_mats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spinless.html#UCJOpSpinless"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinless" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A spinless unitary cluster Jastrow operator.</p>
<p>A spinless unitary cluster Jastrow (UCJ) operator has the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\prod_{k = 1}^L \mathcal{U}_k e^{i \mathcal{J}_k} \mathcal{U}_k^\dagger\]</div>
</div>
<p>where each <span class="math notranslate nohighlight">\(\mathcal{U_k}\)</span> is an orbital rotation and each <span class="math notranslate nohighlight">\(\mathcal{J}\)</span>
is a diagonal Coulomb operator of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{J} = \frac12\sum_{ij}
\mathbf{J}_{ij} n_{i} n_{j}.\]</div>
</div>
<p>where mathbf{J} is a real symmetric matrix.
The number of terms <span class="math notranslate nohighlight">\(L\)</span> is referred to as the
number of ansatz repetitions and is accessible via the <cite>n_reps</cite> attribute.</p>
<p>To support variational optimization of the orbital basis, an optional final
orbital rotation can be included in the operator, to be performed at the end.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinless.diag_coulomb_mats">
<span class="sig-name descname"><span class="pre">diag_coulomb_mats</span></span><a class="headerlink" href="#ffsim.UCJOpSpinless.diag_coulomb_mats" title="Link to this definition">¶</a></dt>
<dd><p>The diagonal Coulomb matrices, as a Numpy array
of shape <cite>(n_reps, norb, norb)</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinless.orbital_rotations">
<span class="sig-name descname"><span class="pre">orbital_rotations</span></span><a class="headerlink" href="#ffsim.UCJOpSpinless.orbital_rotations" title="Link to this definition">¶</a></dt>
<dd><p>The orbital rotations, as a Numpy array
of shape <cite>(n_reps, norb, norb)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinless.final_orbital_rotation">
<span class="sig-name descname"><span class="pre">final_orbital_rotation</span></span><a class="headerlink" href="#ffsim.UCJOpSpinless.final_orbital_rotation" title="Link to this definition">¶</a></dt>
<dd><p>The optional final orbital rotation,
as a Numpy array of shape <cite>(norb, norb)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinless.from_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spinless.html#UCJOpSpinless.from_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinless.from_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the UCJ operator from a real-valued parameter vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The real-valued parameter vector.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>n_reps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of ansatz repetitions.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Optional restrictions on allowed orbital interactions
for the diagonal Coulomb operators.
If specified, <cite>interaction_pairs</cite> should be a list of integer pairs
representing the orbitals that are allowed to interact. These pairs
can also be interpreted as indices of diagonal Coulomb matrix entries
that are allowed to be nonzero.
Each integer pair must be upper triangular, that is, of the form
<span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>.</p></li>
<li><p><strong>with_final_orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include a final orbital rotation
in the operator.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.UCJOpSpinless" title="ffsim.variational.ucj_spinless.UCJOpSpinless"><code class="xref py py-class docutils literal notranslate"><span class="pre">UCJOpSpinless</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The UCJ operator constructed from the given parameters.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – The number of parameters passed did not match the number
    expected based on the function inputs.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list contained duplicate interactions.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list contained lower triangular pairs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinless.from_t_amplitudes">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_t_amplitudes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spinless.html#UCJOpSpinless.from_t_amplitudes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinless.from_t_amplitudes" title="Link to this definition">¶</a></dt>
<dd><p>Initialize the UCJ operator from t2 (and optionally t1) amplitudes.</p>
<p>Performs a double-factorization of the t2 amplitudes and constructs the
ansatz repetitions from the terms of the decomposition, up to an optionally
specified number of ansatz repetitions. Terms are included in decreasing order
of the absolute value of the corresponding eigenvalue in the factorization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t2</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The t2 amplitudes.</p></li>
<li><p><strong>t1</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The t1 amplitudes.</p></li>
<li><p><strong>n_reps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The number of ansatz repetitions. If not specified, then it is set
to the number of terms resulting from the double-factorization of the
t2 amplitudes. If the specified number of repetitions is larger than the
number of terms resulting from the double-factorization, then the ansatz
is padded with additional identity operators up to the specified number
of repetitions.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Optional restrictions on allowed orbital interactions
for the diagonal Coulomb operators.
If specified, <cite>interaction_pairs</cite> should be a list of integer pairs
representing the orbitals that are allowed to interact. These pairs
can also be interpreted as indices of diagonal Coulomb matrix entries
that are allowed to be nonzero.
Each integer pair must be upper triangular, that is, of the form
<span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>.</p></li>
<li><p><strong>tol</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – Tolerance for error in the double-factorized decomposition of the
t2 amplitudes.
The error is defined as the maximum absolute difference between
an element of the original tensor and the corresponding element of
the reconstructed tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.UCJOpSpinless" title="ffsim.variational.ucj_spinless.UCJOpSpinless"><code class="xref py py-class docutils literal notranslate"><span class="pre">UCJOpSpinless</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The UCJ operator with parameters initialized from the t2 amplitudes.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – Interaction pairs list contained duplicate interactions.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list contained lower triangular pairs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinless.n_params">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reps</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_final_orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spinless.html#UCJOpSpinless.n_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinless.n_params" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of parameters of an ansatz with given settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>n_reps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of ansatz repetitions.</p></li>
<li><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Optional restrictions on allowed orbital interactions
for the diagonal Coulomb operators.
If specified, <cite>interaction_pairs</cite> should be a list of integer pairs
representing the orbitals that are allowed to interact. These pairs
can also be interpreted as indices of diagonal Coulomb matrix entries
that are allowed to be nonzero.
Each integer pair must be upper triangular, that is, of the form
<span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>.</p></li>
<li><p><strong>with_final_orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to include a final orbital rotation
in the operator.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of parameters of the ansatz.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – Interaction pairs list contained duplicate interactions.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list contained lower triangular pairs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinless.n_reps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_reps</span></span><a class="headerlink" href="#ffsim.UCJOpSpinless.n_reps" title="Link to this definition">¶</a></dt>
<dd><p>The number of ansatz repetitions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinless.norb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#ffsim.UCJOpSpinless.norb" title="Link to this definition">¶</a></dt>
<dd><p>The number of spatial orbitals.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ffsim.UCJOpSpinless.to_parameters">
<span class="sig-name descname"><span class="pre">to_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction_pairs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/ucj_spinless.html#UCJOpSpinless.to_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.UCJOpSpinless.to_parameters" title="Link to this definition">¶</a></dt>
<dd><p>Convert the UCJ operator to a real-valued parameter vector.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <cite>interaction_pairs</cite> is specified, the returned parameter vector will
incorporate only the diagonal Coulomb matrix entries corresponding to the
specified interactions, so the original operator will not be recoverable
from the parameter vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>interaction_pairs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Optional restrictions on allowed orbital interactions
for the diagonal Coulomb operators.
If specified, <cite>interaction_pairs</cite> should be a list of integer pairs
representing the orbitals that are allowed to interact. These pairs
can also be interpreted as indices of diagonal Coulomb matrix entries
that are allowed to be nonzero.
Each integer pair must be upper triangular, that is, of the form
<span class="math notranslate nohighlight">\((i, j)\)</span> where <span class="math notranslate nohighlight">\(i \leq j\)</span>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The real-valued parameter vector.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – Interaction pairs list contained duplicate interactions.</p></li>
<li><p><strong>ValueError</strong> – Interaction pairs list contained lower triangular pairs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.addresses_to_strings">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">addresses_to_strings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">addresses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concatenate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bitstring_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BitstringType.INT</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/bitstring.html#addresses_to_strings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.addresses_to_strings" title="Link to this definition">¶</a></dt>
<dd><p>Convert state vector addresses to bitstrings.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ffsim</span>

<span class="n">norb</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">nelec</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">dim</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">)</span>

<span class="n">strings</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">addresses_to_strings</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span>  <span class="c1"># prints [11, 19, 35, 13, 21]</span>

<span class="n">strings</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">addresses_to_strings</span><span class="p">(</span>
    <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">,</span> <span class="n">bitstring_type</span><span class="o">=</span><span class="n">ffsim</span><span class="o">.</span><span class="n">BitstringType</span><span class="o">.</span><span class="n">STRING</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span>  <span class="c1"># prints [&#39;001011&#39;, &#39;010011&#39;, &#39;100011&#39;, &#39;001101&#39;, &#39;010101&#39;]</span>

<span class="n">strings</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">addresses_to_strings</span><span class="p">(</span>
    <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">,</span> <span class="n">bitstring_type</span><span class="o">=</span><span class="n">ffsim</span><span class="o">.</span><span class="n">BitstringType</span><span class="o">.</span><span class="n">BIT_ARRAY</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span>
<span class="c1"># prints</span>
<span class="c1"># [[False False  True False  True  True]</span>
<span class="c1">#  [False  True False False  True  True]</span>
<span class="c1">#  [ True False False False  True  True]</span>
<span class="c1">#  [False False  True  True False  True]</span>
<span class="c1">#  [False  True False  True False  True]]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>addresses</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>] | <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector addresses to convert to bitstrings.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
<li><p><strong>bitstring_type</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.BitstringType" title="ffsim.states.bitstring.BitstringType"><code class="xref py py-class docutils literal notranslate"><span class="pre">BitstringType</span></code></a></span>) – The desired type of bitstring output.</p></li>
<li><p><strong>concatenate</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to concatenate the spin-alpha and spin-beta parts of the
bitstrings. If True, then a single list of concatenated bitstrings is
returned. The strings are concatenated in the order <span class="math notranslate nohighlight">\(s_b s_a\)</span>,
that is, the alpha string appears on the right.
If False, then two lists are returned, <code class="docutils literal notranslate"><span class="pre">(strings_a,</span> <span class="pre">strings_b)</span></code>. Note that
the list of alpha strings appears first, that is, on the left.
In the spinless case (when <cite>nelec</cite> is an integer), this argument is ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The bitstrings. The type of the output depends on <cite>bitstring_type</cite> and
<cite>concatenate</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_diag_coulomb_evolution">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_diag_coulomb_evolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_representation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/diag_coulomb.html#apply_diag_coulomb_evolution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_diag_coulomb_evolution" title="Link to this definition">¶</a></dt>
<dd><p>Apply time evolution by a (rotated) diagonal Coulomb operator.</p>
<p>Applies</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{U}
\exp\left(-i t \sum_{\sigma, \tau, i, j}
Z^{(\sigma \tau)}_{ij} n_{\sigma, i} n_{\tau, j} / 2\right)
\mathcal{U}^\dagger\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(n_{\sigma, i}\)</span> denotes the number operator on orbital <span class="math notranslate nohighlight">\(i\)</span>
with spin <span class="math notranslate nohighlight">\(\sigma\)</span>, <span class="math notranslate nohighlight">\(Z^{(\sigma \tau)}\)</span> is a real-valued matrix,
and <span class="math notranslate nohighlight">\(\mathcal{U}\)</span> is an optional orbital rotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>mat</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]</span>) – The diagonal Coulomb matrix <span class="math notranslate nohighlight">\(Z\)</span>.
You can pass either a single Numpy array specifying the coefficients
to use for all spin interactions, or you can pass a tuple of three Numpy
arrays specifying independent coefficients for alpha-alpha, alpha-beta,
and beta-beta interactions (in that order). If passing a tuple, you can
set a tuple element to <code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate the absence of interactions
of that type. The alpha-alpha and beta-beta matrices are assumed to be
symmetric, and only their upper triangular entries are used.</p></li>
<li><p><strong>time</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The evolution time.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
<li><p><strong>orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The optional orbital rotation.
You can pass either a single Numpy array specifying the orbital rotation
to apply to both spin sectors, or you can pass a pair of Numpy arrays
specifying independent orbital rotations for spin alpha and spin beta.
If passing a pair, you can use <code class="docutils literal notranslate"><span class="pre">None</span></code> for one of the
values in the pair to indicate that no operation should be applied to that
spin sector.</p></li>
<li><p><strong>z_representation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether the input matrices are in the “Z” representation.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The evolved state vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_fsim_gate">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_fsim_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orbs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_fsim_gate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_fsim_gate" title="Link to this definition">¶</a></dt>
<dd><p>Apply an fSim gate.</p>
<p>An fSim gate consists of a tunneling interaction followed by a number-number
interaction (note the negative sign convention for the angles):</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    \text{fSim}&amp;(\theta, \phi, (p, q))
    = \text{NN}(-\phi, (p, q)) \text{T}(-\theta, (p, q)) \\
    &amp;= \prod_\sigma
    \exp\left(-i \phi a^\dagger_{\sigma, p} a_{\sigma, p}
    a^\dagger_{\sigma, q} a_{\sigma, q}\right)
    \exp\left(-i \theta (a^\dagger_{\sigma, p} a_{\sigma, q}
    + a^\dagger_{\sigma, q} a_{\sigma, p})\right)
\end{align}\end{split}\]</div>
</div>
<p>Under the Jordan-Wigner transform, this gate has the following matrix when applied
to neighboring qubits:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \cos(\theta) &amp; -i \sin(\theta) &amp; 0\\
    0 &amp; -i \sin(\theta) &amp; \cos(\theta) &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; e^{-i \phi} \\
\end{pmatrix}\end{split}\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle for the tunneling interaction.</p></li>
<li><p><strong>phi</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The phase angle for the number-number interaction.</p></li>
<li><p><strong>target_orbs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The orbitals (p, q) to interact.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – <p>Choice of spin sector(s) to act on.</p>
<ul>
<li><p>To act on only spin alpha, pass <a class="reference internal" href="#ffsim.Spin.ALPHA" title="ffsim.Spin.ALPHA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA</span></code></a>.</p></li>
<li><p>To act on only spin beta, pass <a class="reference internal" href="#ffsim.Spin.BETA" title="ffsim.Spin.BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.BETA</span></code></a>.</p></li>
<li><p>To act on both spin alpha and spin beta, pass
<a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA" title="ffsim.Spin.ALPHA_AND_BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA_AND_BETA</span></code></a> (this is the default value).</p></li>
</ul>
</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_fswap_gate">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_fswap_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orbs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_fswap_gate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_fswap_gate" title="Link to this definition">¶</a></dt>
<dd><p>Apply an FSWAP gate.</p>
<p>The FSWAP gate swaps two orbitals. It is represented by the operator</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{FSWAP}(p, q) =
1 + a^\dagger_p a_q + a^\dagger_q a_p - a_p^\dagger a_p - a_q^\dagger a_q\]</div>
</div>
<p>Under the Jordan-Wigner transform, this gate has the following matrix when applied
to neighboring qubits:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -1 \\
\end{pmatrix}\end{split}\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>target_orbs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The orbitals (p, q) to swap.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – Choice of spin sector(s) to act on.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><dl class="simple">
<dt>If <cite>copy=True</cite> then this function always returns a newly allocated</dt><dd><p>vector and the original vector is left untouched.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>If <cite>copy=False</cite> then this function may still return a newly allocated</dt><dd><p>vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p>
</dd>
</dl>
</li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_givens_rotation">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_givens_rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orbs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi=0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_givens_rotation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_givens_rotation" title="Link to this definition">¶</a></dt>
<dd><p>Apply a Givens rotation gate.</p>
<p>The Givens rotation gate is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{G}(\theta, \varphi, (p, q)) = \prod_{\sigma}
\exp\left(i\varphi a^\dagger_{\sigma, p} a_{\sigma, p}\right)
\exp\left(\theta (a^\dagger_{\sigma, p} a_{\sigma, q}
- a^\dagger_{\sigma, q} a_{\sigma, p})\right)
\exp\left(-i\varphi a^\dagger_{\sigma, p} a_{\sigma, p}\right)\]</div>
</div>
<p>Under the Jordan-Wigner transform, this gate has the following matrix when applied
to neighboring qubits:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \cos(\theta) &amp; -e^{-i\varphi}\sin(\theta) &amp; 0\\
    0 &amp; e^{i\varphi}\sin(\theta) &amp; \cos(\theta) &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1 \\
\end{pmatrix}\end{split}\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle.</p></li>
<li><p><strong>target_orbs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The orbitals (p, q) to rotate.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – <p>Choice of spin sector(s) to act on.</p>
<ul>
<li><p>To act on only spin alpha, pass <a class="reference internal" href="#ffsim.Spin.ALPHA" title="ffsim.Spin.ALPHA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA</span></code></a>.</p></li>
<li><p>To act on only spin beta, pass <a class="reference internal" href="#ffsim.Spin.BETA" title="ffsim.Spin.BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.BETA</span></code></a>.</p></li>
<li><p>To act on both spin alpha and spin beta, pass
<a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA" title="ffsim.Spin.ALPHA_AND_BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA_AND_BETA</span></code></a> (this is the default value).</p></li>
</ul>
</p></li>
<li><p><strong>phi</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The optional phase angle.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_hop_gate">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_hop_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orbs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_hop_gate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_hop_gate" title="Link to this definition">¶</a></dt>
<dd><p>Apply a hop gate.</p>
<p>A “hop gate” is a Givens rotation gate followed by a number-number interaction with
angle pi:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    \text{Hop}&amp;(\theta, (p, q))
    = \text{NN}(\pi, (p, q)) \text{G}(\theta, (p, q)) \\
    &amp;= \prod_{\sigma}
    \exp\left(i \theta a^\dagger_{\sigma, p} a_{\sigma, p}
    a^\dagger_{\sigma, q} a_{\sigma, q}\right)
    \exp\left(\theta (a^\dagger_{\sigma, p} a_{\sigma, q}
    - a^\dagger_{\sigma, q} a_{\sigma, p})\right)
\end{align}\end{split}\]</div>
</div>
<p>Under the Jordan-Wigner transform, this gate has the following matrix when applied
to neighboring qubits:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \cos(\theta) &amp; -\sin(\theta) &amp; 0\\
    0 &amp; \sin(\theta) &amp; \cos(\theta) &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; -1 \\
\end{pmatrix}\end{split}\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle.</p></li>
<li><p><strong>target_orbs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The orbitals (p, q) to interact.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – <p>Choice of spin sector(s) to act on.</p>
<ul>
<li><p>To act on only spin alpha, pass <a class="reference internal" href="#ffsim.Spin.ALPHA" title="ffsim.Spin.ALPHA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA</span></code></a>.</p></li>
<li><p>To act on only spin beta, pass <a class="reference internal" href="#ffsim.Spin.BETA" title="ffsim.Spin.BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.BETA</span></code></a>.</p></li>
<li><p>To act on both spin alpha and spin beta, pass
<a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA" title="ffsim.Spin.ALPHA_AND_BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA_AND_BETA</span></code></a> (this is the default value).</p></li>
</ul>
</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_num_interaction">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_num_interaction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_num_interaction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_num_interaction" title="Link to this definition">¶</a></dt>
<dd><p>Apply a number interaction gate.</p>
<p>The number interaction gate is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{N}(\theta, p) = \prod_{\sigma}
\exp\left(i \theta a^\dagger_{\sigma, p} a_{\sigma, p}\right)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle.</p></li>
<li><p><strong>target_orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The orbital on which to apply the interaction.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – <p>Choice of spin sector(s) to act on.</p>
<ul>
<li><p>To act on only spin alpha, pass <a class="reference internal" href="#ffsim.Spin.ALPHA" title="ffsim.Spin.ALPHA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA</span></code></a>.</p></li>
<li><p>To act on only spin beta, pass <a class="reference internal" href="#ffsim.Spin.BETA" title="ffsim.Spin.BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.BETA</span></code></a>.</p></li>
<li><p>To act on both spin alpha and spin beta, pass
<a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA" title="ffsim.Spin.ALPHA_AND_BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA_AND_BETA</span></code></a> (this is the default value).</p></li>
</ul>
</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_num_num_interaction">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_num_num_interaction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orbs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_num_num_interaction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_num_num_interaction" title="Link to this definition">¶</a></dt>
<dd><p>Apply a number-number interaction gate.</p>
<p>The number-number interaction gate is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{NN}(\theta, (p, q)) = \prod_{\sigma}
\exp\left(i \theta a^\dagger_{\sigma, p} a_{\sigma, p}
a^\dagger_{\sigma, q} a_{\sigma, q}\right)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle.</p></li>
<li><p><strong>target_orbs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The orbitals (p, q) to interact.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – <p>Choice of spin sector(s) to act on.</p>
<ul>
<li><p>To act on only spin alpha, pass <a class="reference internal" href="#ffsim.Spin.ALPHA" title="ffsim.Spin.ALPHA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA</span></code></a>.</p></li>
<li><p>To act on only spin beta, pass <a class="reference internal" href="#ffsim.Spin.BETA" title="ffsim.Spin.BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.BETA</span></code></a>.</p></li>
<li><p>To act on both spin alpha and spin beta, pass
<a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA" title="ffsim.Spin.ALPHA_AND_BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA_AND_BETA</span></code></a> (this is the default value).</p></li>
</ul>
</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_num_op_prod_interaction">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_num_op_prod_interaction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orbs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_num_op_prod_interaction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_num_op_prod_interaction" title="Link to this definition">¶</a></dt>
<dd><p>Apply interaction gate for product of number operators.</p>
<p>The gate is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{NP}(\theta, (S_\alpha, S_\beta)) =
\exp\left(i \theta
\prod_{p \in S_\alpha} a^\dagger_{\alpha, p} a_{\alpha, p}
\prod_{p \in S_\beta} a^\dagger_{\beta, p} a_{\beta, p}
\right)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle.</p></li>
<li><p><strong>target_orbs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – A pair of lists of integers giving the orbitals on which to apply
the interaction. The first list specifies the alpha orbitals and the second
list specifies the beta orbitals.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_num_op_sum_evolution">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_num_op_sum_evolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/num_op_sum.html#apply_num_op_sum_evolution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_num_op_sum_evolution" title="Link to this definition">¶</a></dt>
<dd><p>Apply time evolution by a (rotated) linear combination of number operators.</p>
<p>Applies</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{U}
\exp\left(-i t \sum_{\sigma, i} \lambda^{(\sigma)}_i n_{\sigma, i}\right)
\mathcal{U}^\dagger\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(n_{\sigma, i}\)</span> denotes the number operator on orbital <span class="math notranslate nohighlight">\(i\)</span>
with spin <span class="math notranslate nohighlight">\(\sigma\)</span>, the <span class="math notranslate nohighlight">\(\lambda_i\)</span> are real numbers, and
<span class="math notranslate nohighlight">\(\mathcal{U}\)</span> is an optional orbital rotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>coeffs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]</span>) – The coefficients of the linear combination.
You can pass either a single Numpy array specifying the coefficients
to apply to both spin sectors, or you can pass a pair of Numpy arrays
specifying independent coefficients for spin alpha and spin beta.
If passing a pair, you can use <code class="docutils literal notranslate"><span class="pre">None</span></code> for one of the
values in the pair to indicate that no operation should be applied to that
spin sector.</p></li>
<li><p><strong>time</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The evolution time.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
<li><p><strong>orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The optional orbital rotation.
You can pass either a single Numpy array specifying the orbital rotation
to apply to both spin sectors, or you can pass a pair of Numpy arrays
specifying independent orbital rotations for spin alpha and spin beta.
If passing a pair, you can use <code class="docutils literal notranslate"><span class="pre">None</span></code> for one of the
values in the pair to indicate that no operation should be applied to that
spin sector.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The evolved state vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_on_site_interaction">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_on_site_interaction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_on_site_interaction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_on_site_interaction" title="Link to this definition">¶</a></dt>
<dd><p>Apply an on-site interaction gate.</p>
<p>The on-site interaction gate is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{OS}(\theta, p) =
\exp\left(i \theta a^\dagger_{\alpha, p} a_{\alpha, p}
a^\dagger_{\beta, p} a_{\beta, p}\right)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle.</p></li>
<li><p><strong>target_orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The orbital on which to apply the interaction.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_orbital_rotation">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_orbital_rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/orbital_rotation.html#apply_orbital_rotation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_orbital_rotation" title="Link to this definition">¶</a></dt>
<dd><p>Apply an orbital rotation to a vector.</p>
<p>An orbital rotation maps creation operators as</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[a^\dagger_{\sigma, i} \mapsto \sum_{j} U^{(\sigma)}_{ji} a^\dagger_{\sigma, j}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(U^{(\sigma)}\)</span> is a unitary matrix representing the action of the
orbital rotation on spin sector <span class="math notranslate nohighlight">\(\sigma\)</span>.
This is equivalent to applying the transformation given by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\prod_{\sigma}
\exp\left(\sum_{ij}
\log(U^{(\sigma)})_{ij} a^\dagger_{\sigma, i} a_{\sigma, j}\right)\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>mat</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]</span>) – The unitary matrix <span class="math notranslate nohighlight">\(U\)</span> describing the orbital rotation.
You can pass either a single Numpy array specifying the orbital rotation
to apply to both spin sectors, or you can pass a pair of Numpy arrays
specifying independent orbital rotations for spin alpha and spin beta.
If passing a pair, you can use <code class="docutils literal notranslate"><span class="pre">None</span></code> for one of the
values in the pair to indicate that no operation should be applied to
that spin sector.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The rotated vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_tunneling_interaction">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_tunneling_interaction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orbs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/gates/basic_gates.html#apply_tunneling_interaction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_tunneling_interaction" title="Link to this definition">¶</a></dt>
<dd><p>Apply a tunneling interaction gate.</p>
<p>The tunneling interaction gate is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{T}(\theta, (p, q)) = \prod_\sigma
\exp\left(i \theta (a^\dagger_{\sigma, p} a_{\sigma, q}
+ a^\dagger_{\sigma, q} a_{\sigma, p})\right)\]</div>
</div>
<p>Under the Jordan-Wigner transform, this gate has the following matrix when applied
to neighboring qubits:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \cos(\theta) &amp; i \sin(\theta) &amp; 0\\
    0 &amp; i \sin(\theta) &amp; \cos(\theta) &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1 \\
\end{pmatrix}\end{split}\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to be transformed.</p></li>
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The rotation angle.</p></li>
<li><p><strong>target_orbs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The orbitals (p, q) on which to apply the interaction.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – <p>Choice of spin sector(s) to act on.</p>
<ul>
<li><p>To act on only spin alpha, pass <a class="reference internal" href="#ffsim.Spin.ALPHA" title="ffsim.Spin.ALPHA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA</span></code></a>.</p></li>
<li><p>To act on only spin beta, pass <a class="reference internal" href="#ffsim.Spin.BETA" title="ffsim.Spin.BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.BETA</span></code></a>.</p></li>
<li><p>To act on both spin alpha and spin beta, pass
<a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA" title="ffsim.Spin.ALPHA_AND_BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA_AND_BETA</span></code></a> (this is the default value).</p></li>
</ul>
</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.apply_unitary">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">apply_unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/apply_unitary_protocol.html#apply_unitary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.apply_unitary" title="Link to this definition">¶</a></dt>
<dd><p>Apply a unitary transformation to a vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The vector to apply the unitary transformation to.</p></li>
<li><p><strong>obj</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></span>) – The object with a unitary effect.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The transformed vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.approx_eq">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">approx_eq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/approximate_equality_protocol.html#approx_eq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.approx_eq" title="Link to this definition">¶</a></dt>
<dd><p>Return whether two objects are approximately equal.</p>
<p>See the documentation of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.isclose.html">np.isclose</a> for the interpretation of the tolerance
parameters <code class="docutils literal notranslate"><span class="pre">rtol</span></code> and <code class="docutils literal notranslate"><span class="pre">atol</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></span>) – The first object.</p></li>
<li><p><strong>other</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></span>) – The object to compare to.</p></li>
<li><p><strong>rtol</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – Relative numerical tolerance.</p></li>
<li><p><strong>atol</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – Absolute numerical tolerance.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the objects are approximately equal up to the specified tolerance,
and False otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.cre">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">cre</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermion_action.html#cre"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.cre" title="Link to this definition">¶</a></dt>
<dd><p>Create a fermion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – The spin of the orbital. False = alpha, True = beta.</p></li>
<li><p><strong>orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the orbital to act on.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionAction" title="ffsim.operators.fermion_action.FermionAction"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionAction</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.cre_a">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">cre_a</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermion_action.html#cre_a"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.cre_a" title="Link to this definition">¶</a></dt>
<dd><p>Create a fermion with spin alpha.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the orbital to act on.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionAction" title="ffsim.operators.fermion_action.FermionAction"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionAction</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.cre_b">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">cre_b</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermion_action.html#cre_b"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.cre_b" title="Link to this definition">¶</a></dt>
<dd><p>Create a fermion with spin beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the orbital to act on.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionAction" title="ffsim.operators.fermion_action.FermionAction"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionAction</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.des">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">des</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermion_action.html#des"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.des" title="Link to this definition">¶</a></dt>
<dd><p>Destroy a fermion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – The spin of the orbital. False = alpha, True = beta.</p></li>
<li><p><strong>orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the orbital to act on.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionAction" title="ffsim.operators.fermion_action.FermionAction"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionAction</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.des_a">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">des_a</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermion_action.html#des_a"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.des_a" title="Link to this definition">¶</a></dt>
<dd><p>Destroy a fermion with spin alpha.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the orbital to act on.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionAction" title="ffsim.operators.fermion_action.FermionAction"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionAction</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.des_b">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">des_b</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermion_action.html#des_b"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.des_b" title="Link to this definition">¶</a></dt>
<dd><p>Destroy a fermion with spin beta.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the orbital to act on.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionAction" title="ffsim.operators.fermion_action.FermionAction"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionAction</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.diag">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">diag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/diagonal_protocol.html#diag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.diag" title="Link to this definition">¶</a></dt>
<dd><p>Return the diagonal entries of the linear operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.dim">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">dim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/states.html#dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.dim" title="Link to this definition">¶</a></dt>
<dd><p>Get the dimension of the FCI space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The dimension of the FCI space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.dims">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">dims</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/states.html#dims"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.dims" title="Link to this definition">¶</a></dt>
<dd><p>Get the dimensions of the FCI space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A pair of integers (dim_a, dim_b) representing the dimensions of the
alpha- and beta- FCI space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.expectation_one_body_power">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">expectation_one_body_power</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_rdm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">one_body_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/wick.html#expectation_one_body_power"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.expectation_one_body_power" title="Link to this definition">¶</a></dt>
<dd><p>Expectation of power of one-body operator w.r.t. a Slater determinant.</p>
<p>A one-body operator <span class="math notranslate nohighlight">\(O\)</span> has the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[O = \sum_{pq} M_{pq} a_p^\dagger a_q.\]</div>
</div>
<p>This function takes the matrix <span class="math notranslate nohighlight">\(M\)</span> as its first argument.
Let <span class="math notranslate nohighlight">\(\lvert \psi \rangle\)</span> be the Slater determinant.
Then this function returns the quantity</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\langle \psi \rvert O^k \lvert \psi \rangle.\]</div>
</div>
<dl class="simple">
<dt>Note: Unlike most functions in ffsim, the inputs to this function are specified</dt><dd><p>in terms of spin-orbitals, not spatial orbitals. In other words, the one-rdm
and the one-body tensors should have the same shape, and all orbitals are
treated on an equal footing. The 1-RDM passed here should not be spin-summed,
and the one-body tensors should be expanded when compared to the usual
one-body tensors elsewhere in ffsim, i.e.,
<cite>scipy.linalg.block_diag(one_body_tensor, one_body_tensor)</cite>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>one_rdm</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The one-body reduced density matrix of the Slater determinant.</p></li>
<li><p><strong>one_body_tensor</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The one-body operator.</p></li>
<li><p><strong>power</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The power.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The expectation value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.expectation_one_body_product">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">expectation_one_body_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one_rdm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">one_body_tensors</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/wick.html#expectation_one_body_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.expectation_one_body_product" title="Link to this definition">¶</a></dt>
<dd><p>Expectation of product of one-body operators w.r.t. a Slater determinant.</p>
<p>A one-body operator <span class="math notranslate nohighlight">\(O\)</span> has the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[O = \sum_{pq} M_{pq} a_p^\dagger a_q.\]</div>
</div>
<p>This function takes a list of the matrices <span class="math notranslate nohighlight">\(M\)</span> as its first argument.
Let <span class="math notranslate nohighlight">\((O_1, O_2, \dots O_k)\)</span> be the list of one-body operators,
and <span class="math notranslate nohighlight">\(\lvert \psi \rangle\)</span> be the Slater determinant.
Then this function returns the quantity</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\langle \psi \rvert O_1 O_2 \dots O_k \lvert \psi \rangle.\]</div>
</div>
<dl class="simple">
<dt>Note: Unlike most functions in ffsim, the inputs to this function are specified</dt><dd><p>in terms of spin-orbitals, not spatial orbitals. In other words, the one-rdm
and the one-body tensors should have the same shape, and all orbitals are
treated on an equal footing. The 1-RDM passed here should not be spin-summed,
and the one-body tensors should be expanded when compared to the usual
one-body tensors elsewhere in ffsim, i.e.,
<cite>scipy.linalg.block_diag(one_body_tensor, one_body_tensor)</cite>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>one_rdm</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The one-body reduced density matrix of the Slater determinant.</p></li>
<li><p><strong>one_body_tensors</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</span>) – The matrices for the one-body operators.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The expectation value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.fermi_hubbard_1d">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">fermi_hubbard_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tunneling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chemical_potential</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nearest_neighbor_interaction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">periodic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermi_hubbard.html#fermi_hubbard_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.fermi_hubbard_1d" title="Link to this definition">¶</a></dt>
<dd><p>One-dimensional Fermi-Hubbard model Hamiltonian.</p>
<p>The Hamiltonian for the one-dimensional Fermi-Hubbard model with <span class="math notranslate nohighlight">\(N\)</span> spatial
orbitals is given by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = -t \sum_{\sigma, \braket{pq}}
(a^\dagger_{\sigma, p} a_{\sigma, q} + a^\dagger_{\sigma, q} a_{\sigma, p})
+ U \sum_p n_{\alpha, p} n_{\beta, p}
- \mu \sum_p (n_{\alpha, p} + n_{\beta, p})
+ V \sum_{\sigma \tau, \braket{pq}} n_{\sigma, p} n_{\tau, q}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(n_{\sigma, p} = a_{\sigma, p}^\dagger a_{\sigma, p}\)</span> is the number
operator on orbital <span class="math notranslate nohighlight">\(p\)</span> with spin <span class="math notranslate nohighlight">\(\sigma\)</span> and the index
<span class="math notranslate nohighlight">\(\braket{pq}\)</span> runs over pairs of orbitals <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span> that are
connected on the line. If periodic boundary conditions are chosen, then the first
and last orbitals are connected. More explicitly:</p>
<ul class="simple">
<li><p>For open boundary conditions, <span class="math notranslate nohighlight">\(\braket{pq}\)</span> runs over pairs
<span class="math notranslate nohighlight">\((p, p + 1)\)</span> for <span class="math notranslate nohighlight">\(p = 1, \ldots, N - 1\)</span>.</p></li>
<li><p>For periodic boundary conditions, <span class="math notranslate nohighlight">\(\braket{pq}\)</span> runs over pairs
<span class="math notranslate nohighlight">\((p, p + 1 \bmod N)\)</span> for <span class="math notranslate nohighlight">\(p = 1, \ldots, N\)</span>.</p></li>
</ul>
<p>In the case that <span class="math notranslate nohighlight">\(N = 2\)</span>, using periodic boundary conditions will cause the
connection between the two vertices to be counted twice, forming a
“ring with two edges”.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1146/annurev-conmatphys-031620-102024">The Hubbard Model</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals <span class="math notranslate nohighlight">\(N\)</span>.</p></li>
<li><p><strong>tunneling</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The tunneling amplitude <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
<li><p><strong>interaction</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The onsite interaction strength <span class="math notranslate nohighlight">\(U\)</span>.</p></li>
<li><p><strong>chemical_potential</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The chemical potential <span class="math notranslate nohighlight">\(\mu\)</span>.</p></li>
<li><p><strong>nearest_neighbor_interaction</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The nearest-neighbor interaction strength
<span class="math notranslate nohighlight">\(V\)</span>.</p></li>
<li><p><strong>periodic</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to use periodic boundary conditions.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionOperator" title="ffsim.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The one-dimensional Fermi-Hubbard model Hamiltonian.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.fermi_hubbard_2d">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">fermi_hubbard_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tunneling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interaction</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chemical_potential</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nearest_neighbor_interaction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">periodic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">periodic_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">periodic_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/fermi_hubbard.html#fermi_hubbard_2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.fermi_hubbard_2d" title="Link to this definition">¶</a></dt>
<dd><p>Two-dimensional Fermi-Hubbard model Hamiltonian on a square lattice.</p>
<p>The Hamiltonian for the two-dimensional Fermi-Hubbard model on a square lattice with
<span class="math notranslate nohighlight">\(N_x\)</span> columns and <span class="math notranslate nohighlight">\(N_y\)</span> rows is given by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[H = -t \sum_{\sigma, \braket{pq}}
(a^\dagger_{\sigma, p} a_{\sigma, q} + a^\dagger_{\sigma, q} a_{\sigma, p})
+ U \sum_p n_{\alpha, p} n_{\beta, p}
- \mu \sum_p (n_{\alpha, p} + n_{\beta, p})
+ V \sum_{\sigma \tau, \braket{pq}} n_{\sigma, p} n_{\tau, q}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(n_{\sigma, p} = a_{\sigma, p}^\dagger a_{\sigma, p}\)</span> is the number
operator on orbital <span class="math notranslate nohighlight">\(p\)</span> with spin <span class="math notranslate nohighlight">\(\sigma\)</span> and the index
<span class="math notranslate nohighlight">\(\braket{pq}\)</span> runs over pairs of orbitals <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span> that are
connected on the lattice. If periodic boundary conditions are chosen, then
orbitals in the first and last columns are connected, as are orbitals in the
first and last rows, so that the square lattice forms a torus. In the case that
one of the dimensions has size 2, using periodic boundary conditions will cause
the connection along that dimension to be counted twice.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1146/annurev-conmatphys-031620-102024">The Hubbard Model</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb_x</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals in the x-direction <span class="math notranslate nohighlight">\(N_x\)</span>.</p></li>
<li><p><strong>norb_y</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals in the y-direction <span class="math notranslate nohighlight">\(N_y\)</span>.</p></li>
<li><p><strong>tunneling</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The tunneling amplitude <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
<li><p><strong>interaction</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The onsite interaction strength <span class="math notranslate nohighlight">\(U\)</span>.</p></li>
<li><p><strong>chemical_potential</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The chemical potential <span class="math notranslate nohighlight">\(\mu\)</span>.</p></li>
<li><p><strong>nearest_neighbor_interaction</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The nearest-neighbor interaction strength
<span class="math notranslate nohighlight">\(V\)</span>.</p></li>
<li><p><strong>periodic</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to use periodic boundary conditions in all dimensions.
This argument overrides the <cite>periodic_x</cite> and <cite>periodic_y</cite> arguments.</p></li>
<li><p><strong>periodic_x</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to use periodic boundary conditions in the X dimension.</p></li>
<li><p><strong>periodic_y</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to use periodic boundary conditions in the Y dimension.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionOperator" title="ffsim.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The two-dimensional Fermi-Hubbard model Hamiltonian.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.fermion_operator">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">fermion_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/fermion_operator_protocol.html#fermion_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.fermion_operator" title="Link to this definition">¶</a></dt>
<dd><p>Return a FermionOperator representing the object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>obj</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></span>) – The object to convert to a LinearOperator.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionOperator" title="ffsim.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A FermionOperator representing the object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.hartree_fock_state">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">hartree_fock_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/slater.html#hartree_fock_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.hartree_fock_state" title="Link to this definition">¶</a></dt>
<dd><p>Return the Hartree-Fock state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The Hartree-Fock state as a state vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.init_cache">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">init_cache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/cistring.html#init_cache"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.init_cache" title="Link to this definition">¶</a></dt>
<dd><p>Initialize cached objects.</p>
<p>Call this function to prepare ffsim for performing operations with given values
of <cite>norb</cite> and <cite>nelec</cite>. Typically there is no need to call this function, but it
should be called before benchmarking to avoid counting the cost of initializing
cached lookup tables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.linear_operator">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">linear_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/linear_operator_protocol.html#linear_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.linear_operator" title="Link to this definition">¶</a></dt>
<dd><p>Return a SciPy LinearOperator representing the object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></span>) – The object to convert to a LinearOperator.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearOperator</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A Scipy LinearOperator representing the object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.multireference_state">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">multireference_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ansatz_operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_occupations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/multireference.html#multireference_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.multireference_state" title="Link to this definition">¶</a></dt>
<dd><p>Compute multireference energy and state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hamiltonian</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearOperator</span></code> | <a class="reference internal" href="#ffsim.SupportsLinearOperator" title="ffsim.protocols.linear_operator_protocol.SupportsLinearOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">SupportsLinearOperator</span></code></a></span>) – The Hamiltonian.</p></li>
<li><p><strong>ansatz_operator</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.SupportsApplyUnitary" title="ffsim.protocols.apply_unitary_protocol.SupportsApplyUnitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">SupportsApplyUnitary</span></code></a></span>) – The ansatz operator.</p></li>
<li><p><strong>reference_occupations</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]]</span>) – The orbital occupations of the reference states.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>root</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the desired eigenvector. Defaults to 0, which yields the
lowest-energy state.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The energy of the multireference state, and the state itself.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.multireference_state_prod">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">multireference_state_prod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ansatz_operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_occupations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/variational/multireference.html#multireference_state_prod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.multireference_state_prod" title="Link to this definition">¶</a></dt>
<dd><p>Compute multireference state for a product ansatz operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hamiltonian</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.MolecularHamiltonian" title="ffsim.hamiltonians.molecular_hamiltonian.MolecularHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a> | <a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian" title="ffsim.hamiltonians.single_factorized_hamiltonian.SingleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian</span></code></a></span>) – The Hamiltonian.</p></li>
<li><p><strong>ansatz_operator</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<a class="reference internal" href="#ffsim.SupportsApplyUnitary" title="ffsim.protocols.apply_unitary_protocol.SupportsApplyUnitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">SupportsApplyUnitary</span></code></a>, <a class="reference internal" href="#ffsim.SupportsApplyUnitary" title="ffsim.protocols.apply_unitary_protocol.SupportsApplyUnitary"><code class="xref py py-class docutils literal notranslate"><span class="pre">SupportsApplyUnitary</span></code></a>]</span>) – The alpha and beta parts of the ansatz operator.</p></li>
<li><p><strong>reference_occupations</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]]</span>) – The orbital occupations of the reference states.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>root</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The index of the desired eigenvector. Defaults to 0, which yields the
lowest-energy state.</p></li>
<li><p><strong>tol</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – Numerical tolerance to use for the single factorization of the molecular
Hamiltonian. If the input is already a SingleFactorizedHamiltonian,
this argument is ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <a class="reference internal" href="#ffsim.ProductStateSum" title="ffsim.states.product_state_sum.ProductStateSum"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProductStateSum</span></code></a>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The energy of the multireference state, and the state itself.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.number_operator">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">number_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin=&lt;Spin.ALPHA_AND_BETA:</span> <span class="pre">3&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/operators/common_operators.html#number_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.number_operator" title="Link to this definition">¶</a></dt>
<dd><p>Occupation number operator.</p>
<p>The occupation number operator for orbital <span class="math notranslate nohighlight">\(p\)</span> is defined as</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[n_p = \sum_\sigma a^\dagger_{\sigma, p} a_{\sigma, p}\]</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The orbital.</p></li>
<li><p><strong>spin</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.Spin" title="ffsim.spin.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a></span>) – <p>Choice of spin sector(s) to act on.</p>
<ul>
<li><p>To act on only spin alpha, pass <a class="reference internal" href="#ffsim.Spin.ALPHA" title="ffsim.Spin.ALPHA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA</span></code></a>.</p></li>
<li><p>To act on only spin beta, pass <a class="reference internal" href="#ffsim.Spin.BETA" title="ffsim.Spin.BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.BETA</span></code></a>.</p></li>
<li><p>To act on both spin alpha and spin beta, pass
<a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA" title="ffsim.Spin.ALPHA_AND_BETA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ffsim.Spin.ALPHA_AND_BETA</span></code></a> (this is the default value).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.FermionOperator" title="ffsim.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number operator acting on the specified orbital and spin sector(s).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.rdms">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">rdms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_summed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reorder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/rdm.html#rdms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.rdms" title="Link to this definition">¶</a></dt>
<dd><p>Return the reduced density matrices of a state vector.</p>
<p>The rank 1 RDM is defined as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>rdm1[p, q] = ⟨p+ q⟩
</pre></div>
</div>
<p>The definition of higher-rank RDMs depends on the <code class="docutils literal notranslate"><span class="pre">reorder</span></code> argument, which
defaults to True.</p>
<p><strong>reorder = True</strong></p>
<p>The reordered RDMs are defined as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>rdm2[p, q, r, s] = ⟨p+ r+ s q⟩
rdm3[p, q, r, s, t, u] = ⟨p+ r+ t+ u s q⟩
rdm4[p, q, r, s, t, u, v, w] = ⟨p+ r+ t+ v+ w u s q⟩
</pre></div>
</div>
<p><strong>reorder = False</strong></p>
<p>If reorder is set to False, the RDMs are defined as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>rdm2[p, q, r, s] = ⟨p+ q r+ s⟩
rdm3[p, q, r, s, t, u] = ⟨p+ q r+ s t+ u⟩
rdm4[p, q, r, s, t, u, v, w] = ⟨p+ q r+ s t+ u v+ w⟩
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, only ranks 1 and 2 are supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector whose reduced density matrix is desired.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>rank</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The rank of the reduced density matrix.</p></li>
<li><p><strong>spin_summed</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to return the “spin-summed” RDMs.</p></li>
<li><p><strong>reorder</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to reorder the indices of the reduced density matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">...</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The reduced density matrices.
All RDMs up to and including the specified rank are returned, in increasing
order of rank. For example, if <cite>rank=2</cite> then a tuple <cite>(rdm1, rdm2)</cite> is returned.
The 1-RDMs are: (alpha-alpha, beta-beta).
The spin-summed 1-RDM is alpha-alpha + alpha-beta.
The 2-RDMs are: (alpha-alpha, alpha-beta, beta-beta).
The spin-summed 2-RDM is alpha-alpha + alpha-beta + beta-alpha + beta-beta.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.sample_slater_determinant">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">sample_slater_determinant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rdm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concatenate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bitstring_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BitstringType.STRING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/sample_slater.html#sample_slater_determinant"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.sample_slater_determinant" title="Link to this definition">¶</a></dt>
<dd><p>Collect samples of electronic configurations from a Slater determinant.</p>
<p>The Slater determinant is defined by its one-body reduced density matrix (RDM).
The sampler uses a determinantal point process to auto-regressively produce
uncorrelated samples.</p>
<p>This sampling strategy is known as
<cite>determinantal point processes &lt;https://arxiv.org/abs/1207.6083&gt;</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rdm</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</span>) – The one-body reduced density matrix that defines the Slater determinant
This is either a single Numpy array specifying the 1-RDM of a
spin-polarized system, or a pair of Numpy arrays where each element
of the pair contains the 1-RDM for each spin sector.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
<li><p><strong>shots</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of bitstrings to sample.</p></li>
<li><p><strong>concatenate</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to concatenate the spin-alpha and spin-beta parts of the
bitstrings. If True, then a single list of concatenated bitstrings is
returned. The strings are concatenated in the order <span class="math notranslate nohighlight">\(s_b s_a\)</span>,
that is, the alpha string appears on the right.
If False, then two lists are returned, <code class="docutils literal notranslate"><span class="pre">(strings_a,</span> <span class="pre">strings_b)</span></code>. Note that
the list of alpha strings appears first, that is, on the left.
In the spinless case (when <cite>nelec</cite> is an integer), this argument is ignored.</p></li>
<li><p><strong>bitstring_type</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.BitstringType" title="ffsim.states.bitstring.BitstringType"><code class="xref py py-class docutils literal notranslate"><span class="pre">BitstringType</span></code></a></span>) – The desired type of bitstring output.</p></li>
<li><p><strong>seed</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – A seed to initialize the pseudorandom number generator.
Should be a valid input to <code class="docutils literal notranslate"><span class="pre">np.random.default_rng</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>] | <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>] | <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A 2D Numpy array with samples of electronic configurations.
Each row is a sample.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.sample_state_vector">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">sample_state_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concatenate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bitstring_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BitstringType.STRING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/states.html#sample_state_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.sample_state_vector" title="Link to this definition">¶</a></dt>
<dd><p>Sample bitstrings from a state vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <a class="reference internal" href="#ffsim.StateVector" title="ffsim.states.states.StateVector"><code class="xref py py-class docutils literal notranslate"><span class="pre">StateVector</span></code></a></span>) – The state vector to sample from.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
<li><p><strong>orbs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>] | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The spin-orbitals to sample.
In the spinless case (when <cite>nelec</cite> is an integer), this is a list of
integers ranging from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">norb</span></code>.
In the spinful case, this is a pair of lists of such integers, with the
first list storing the spin-alpha orbitals and the second list storing
the spin-beta orbitals.
If not specified, then all spin-orbitals are sampled.</p></li>
<li><p><strong>shots</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of bitstrings to sample.</p></li>
<li><p><strong>concatenate</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – Whether to concatenate the spin-alpha and spin-beta parts of the
bitstrings. If True, then a single list of concatenated bitstrings is
returned. The strings are concatenated in the order <span class="math notranslate nohighlight">\(s_b s_a\)</span>,
that is, the alpha string appears on the right.
If False, then two lists are returned, <code class="docutils literal notranslate"><span class="pre">(strings_a,</span> <span class="pre">strings_b)</span></code>. Note that
the list of alpha strings appears first, that is, on the left.
In the spinless case (when <cite>nelec</cite> is an integer), this argument is ignored.</p></li>
<li><p><strong>bitstring_type</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.BitstringType" title="ffsim.states.bitstring.BitstringType"><code class="xref py py-class docutils literal notranslate"><span class="pre">BitstringType</span></code></a></span>) – The desired type of bitstring output.</p></li>
<li><p><strong>seed</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – A seed to initialize the pseudorandom number generator.
Should be a valid input to <code class="docutils literal notranslate"><span class="pre">np.random.default_rng</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The sampled bitstrings, as a list of strings of length <cite>shots</cite>.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>TypeError</strong> – When passing vec as a Numpy array, norb and nelec must be specified.</p></li>
<li><p><strong>TypeError</strong> – When passing vec as a StateVector, norb and nelec must both be None.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.simulate_qdrift_double_factorized">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">simulate_qdrift_double_factorized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probabilities</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'norm'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">one_rdm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/trotter/qdrift.html#simulate_qdrift_double_factorized"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.simulate_qdrift_double_factorized" title="Link to this definition">¶</a></dt>
<dd><p>Double-factorized Hamiltonian simulation via qDRIFT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to evolve.</p></li>
<li><p><strong>hamiltonian</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian" title="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a></span>) – The Hamiltonian.</p></li>
<li><p><strong>time</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The evolution time.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>n_steps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of Trotter steps.</p></li>
<li><p><strong>probabilities</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The sampling method to use, or else an explicit array of
probabilities. If specifying a string, the following options are supported:
- “norm”: Sample each term with probability proportional to its
spectral norm.
- “uniform”: Sample each term with uniform probability.
- “optimal”: Sample with probabilities optimized for a given initial state.
The “optimal” method requires the one-body reduced density matrix of the
initial state to be specified. It returns optimal probabilities whenever
the initial state is completely characterized by this reduced density
matrix, i.e., it is a Slater determinant.</p></li>
<li><p><strong>one_rdm</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The one-body reduced density matrix of the initial state.</p></li>
<li><p><strong>n_samples</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of qDRIFT trajectories to sample.</p></li>
<li><p><strong>seed</strong> – A seed to initialize the pseudorandom number generator.
Should be a valid input to <code class="docutils literal notranslate"><span class="pre">np.random.default_rng</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A Numpy array representing the final state of the simulation. The shape of the
array depends on the <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> argument. If <code class="docutils literal notranslate"><span class="pre">n_samples=1</span></code> then it is
just a state vector, a one-dimensional array. Otherwise, it is a two-dimensional
array of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">dim)</span></code> where <code class="docutils literal notranslate"><span class="pre">dim</span></code> is the dimension of the
state vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.simulate_trotter_diag_coulomb_split_op">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">simulate_trotter_diag_coulomb_split_op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/trotter/diagonal_coulomb.html#simulate_trotter_diag_coulomb_split_op"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.simulate_trotter_diag_coulomb_split_op" title="Link to this definition">¶</a></dt>
<dd><p>Diagonal Coulomb Hamiltonian simulation using split-operator method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to evolve.</p></li>
<li><p><strong>hamiltonian</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.DiagonalCoulombHamiltonian" title="ffsim.hamiltonians.diagonal_coulomb_hamiltonian.DiagonalCoulombHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiagonalCoulombHamiltonian</span></code></a></span>) – The Hamiltonian.</p></li>
<li><p><strong>time</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The evolution time.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>n_steps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of Trotter steps.</p></li>
<li><p><strong>order</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The order of the Trotter decomposition.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The final state of the simulation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.simulate_trotter_double_factorized">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">simulate_trotter_double_factorized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/trotter/double_factorized.html#simulate_trotter_double_factorized"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.simulate_trotter_double_factorized" title="Link to this definition">¶</a></dt>
<dd><p>Double-factorized Hamiltonian simulation using Trotter-Suzuki formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The state vector to evolve.</p></li>
<li><p><strong>hamiltonian</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian" title="ffsim.hamiltonians.double_factorized_hamiltonian.DoubleFactorizedHamiltonian"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a></span>) – The Hamiltonian.</p></li>
<li><p><strong>time</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) – The evolution time.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – The number of alpha and beta electrons.</p></li>
<li><p><strong>n_steps</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of Trotter steps.</p></li>
<li><p><strong>order</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The order of the Trotter decomposition.</p></li>
<li><p><strong>copy</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>Whether to copy the vector before operating on it.</p>
<ul>
<li><p>If <cite>copy=True</cite> then this function always returns a newly allocated
vector and the original vector is left untouched.</p></li>
<li><p>If <cite>copy=False</cite> then this function may still return a newly allocated
vector, but the original vector may have its data overwritten.
It is also possible that the original vector is returned,
modified in-place.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The final state of the simulation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.slater_determinant">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">slater_determinant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occupied_orbitals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/slater.html#slater_determinant"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.slater_determinant" title="Link to this definition">¶</a></dt>
<dd><p>Return a Slater determinant.</p>
<p>A Slater determinant is a state of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{U} \lvert x \rangle,\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{U}\)</span> is an
<a class="reference internal" href="../explanations/orbital-rotation.html"><span class="doc">orbital rotation</span></a> and
<span class="math notranslate nohighlight">\(\lvert x \rangle\)</span> is an electronic configuration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>occupied_orbitals</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>] | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – The occupied orbitals in the electronic configuration.
This is either a list of integers specifying spinless orbitals, or a
pair of lists, where the first list specifies the spin alpha orbitals and
the second list specifies the spin beta orbitals.</p></li>
<li><p><strong>orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The optional orbital rotation.
You can pass either a single Numpy array specifying the orbital rotation
to apply to both spin sectors, or you can pass a pair of Numpy arrays
specifying independent orbital rotations for spin alpha and spin beta.
If passing a pair, you can use <code class="docutils literal notranslate"><span class="pre">None</span></code> for one of the
values in the pair to indicate that no operation should be applied to
that spin sector.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The Slater determinant as a state vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.slater_determinant_amplitudes">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">slater_determinant_amplitudes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bitstrings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occupied_orbitals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotation</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/slater.html#slater_determinant_amplitudes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.slater_determinant_amplitudes" title="Link to this definition">¶</a></dt>
<dd><p>Compute state vector amplitudes for a Slater determinant.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bitstrings</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>] | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – The bitstrings to return the amplitudes for, in integer
representation. In the spinless case this is a list of integers. In the
spinful case, this is a pair of lists of equal length specifying the
alpha and beta parts of the bitstrings.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>occupied_orbitals</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>] | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – The occupied orbitals in the electronic configuration.
This is either a list of integers specifying spinless orbitals, or a
pair of lists, where the first list specifies the spin alpha orbitals and
the second list specifies the spin beta orbitals.</p></li>
<li><p><strong>orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]</span>) – The orbital rotation describing the Slater determinant.
You can pass either a single Numpy array specifying the orbital rotation
to apply to both spin sectors, or you can pass a pair of Numpy arrays
specifying independent orbital rotations for spin alpha and spin beta.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The amplitudes of the requested bitstrings.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.slater_determinant_rdms">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">slater_determinant_rdms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occupied_orbitals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/slater.html#slater_determinant_rdms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.slater_determinant_rdms" title="Link to this definition">¶</a></dt>
<dd><p>Return the reduced density matrices of a <a class="reference external" href="ffsim.html#ffsim.slater_determinant">Slater determinant</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, only rank 1 is supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>occupied_orbitals</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>] | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span>) – The occupied orbitals in the electronic configuration.
This is either a list of integers specifying spinless orbitals, or a
pair of lists, where the first list specifies the spin alpha orbitals and
the second list specifies the spin beta orbitals.</p></li>
<li><p><strong>orbital_rotation</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>] | <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span>) – The optional orbital rotation.
You can pass either a single Numpy array specifying the orbital rotation
to apply to both spin sectors, or you can pass a pair of Numpy arrays
specifying independent orbital rotations for spin alpha and spin beta.
If passing a pair, you can use <code class="docutils literal notranslate"><span class="pre">None</span></code> for one of the
values in the pair to indicate that no operation should be applied to
that spin sector.</p></li>
<li><p><strong>rank</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The rank of the reduced density matrix. I.e., rank 1 corresponds to the
one-particle RDM, rank 2 corresponds to the 2-particle RDM, etc.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The reduced density matrices of the Slater determinant.
All RDMs up to and including the specified rank are returned, in increasing
order of rank. For example, if <cite>rank=2</cite> then a tuple <cite>(rdm1, rdm2)</cite> is returned.
The representation of an RDM depends on whether <cite>occupied_orbitals</cite> is a
sequence of integers (spinless case), or a pair of such sequences
(spinful case). In the spinless case, the full RDM is returned.
In the spinful case, each RDM is represented as a stacked Numpy
array of sub-RDMs. For example, the 1-RDMs are: (alpha-alpha, alpha-beta), and
the 2-RDMs are: (alpha-alpha, alpha-beta, beta-beta).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.spin_square">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">spin_square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fcivec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/states.html#spin_square"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.spin_square" title="Link to this definition">¶</a></dt>
<dd><p>Expectation value of spin squared operator on a state vector.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.strings_to_addresses">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">strings_to_addresses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/states/bitstring.html#strings_to_addresses"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.strings_to_addresses" title="Link to this definition">¶</a></dt>
<dd><p>Convert bitstrings to state vector addresses.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">ffsim</span>

<span class="n">norb</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">nelec</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">dim</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">dim</span><span class="p">(</span><span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">)</span>

<span class="n">addresses</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">strings_to_addresses</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="mb">0b001011</span><span class="p">,</span>
        <span class="mb">0b010101</span><span class="p">,</span>
        <span class="mb">0b100101</span><span class="p">,</span>
        <span class="mb">0b010110</span><span class="p">,</span>
        <span class="mb">0b100110</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="n">norb</span><span class="p">,</span>
    <span class="n">nelec</span><span class="p">,</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span>  <span class="c1"># prints [0 4 5 7 8]</span>

<span class="n">addresses</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">strings_to_addresses</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="s2">&quot;001011&quot;</span><span class="p">,</span>
        <span class="s2">&quot;010101&quot;</span><span class="p">,</span>
        <span class="s2">&quot;100101&quot;</span><span class="p">,</span>
        <span class="s2">&quot;010110&quot;</span><span class="p">,</span>
        <span class="s2">&quot;100110&quot;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="n">norb</span><span class="p">,</span>
    <span class="n">nelec</span><span class="p">,</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span>  <span class="c1"># prints [0 4 5 7 8]</span>

<span class="n">addresses</span> <span class="o">=</span> <span class="n">ffsim</span><span class="o">.</span><span class="n">strings_to_addresses</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
            <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
            <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
            <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
            <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">),</span>
    <span class="n">norb</span><span class="p">,</span>
    <span class="n">nelec</span><span class="p">,</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span>  <span class="c1"># prints [0 4 5 7 8]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strings</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>] | <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>] | <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span>) – The bitstrings to convert to state vector addresses.
Can be a list of strings, a list of integers, or a Numpy array of bits.</p></li>
<li><p><strong>norb</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – The number of spatial orbitals.</p></li>
<li><p><strong>nelec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – Either a single integer representing the number of fermions for a
spinless system, or a pair of integers storing the numbers of spin alpha
and spin beta fermions.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The state vector addresses, as a Numpy array of integers.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ffsim.trace">
<span class="sig-prename descclassname"><span class="pre">ffsim.</span></span><span class="sig-name descname"><span class="pre">trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ffsim/protocols/trace_protocol.html#trace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ffsim.trace" title="Link to this definition">¶</a></dt>
<dd><p>Return the trace of the linear operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span></p>
</dd>
</dl>
</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="ffsim.contract.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">ffsim.contract</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">API reference</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, IBM
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">ffsim</a><ul>
<li><a class="reference internal" href="#ffsim.BitstringType"><code class="docutils literal notranslate"><span class="pre">BitstringType</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.BitstringType.BIT_ARRAY"><code class="docutils literal notranslate"><span class="pre">BitstringType.BIT_ARRAY</span></code></a></li>
<li><a class="reference internal" href="#ffsim.BitstringType.INT"><code class="docutils literal notranslate"><span class="pre">BitstringType.INT</span></code></a></li>
<li><a class="reference internal" href="#ffsim.BitstringType.STRING"><code class="docutils literal notranslate"><span class="pre">BitstringType.STRING</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.DiagonalCoulombHamiltonian"><code class="docutils literal notranslate"><span class="pre">DiagonalCoulombHamiltonian</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.DiagonalCoulombHamiltonian.one_body_tensor"><code class="docutils literal notranslate"><span class="pre">DiagonalCoulombHamiltonian.one_body_tensor</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DiagonalCoulombHamiltonian.diag_coulomb_mats"><code class="docutils literal notranslate"><span class="pre">DiagonalCoulombHamiltonian.diag_coulomb_mats</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DiagonalCoulombHamiltonian.constant"><code class="docutils literal notranslate"><span class="pre">DiagonalCoulombHamiltonian.constant</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DiagonalCoulombHamiltonian.from_fermion_operator"><code class="docutils literal notranslate"><span class="pre">DiagonalCoulombHamiltonian.from_fermion_operator()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DiagonalCoulombHamiltonian.norb"><code class="docutils literal notranslate"><span class="pre">DiagonalCoulombHamiltonian.norb</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.one_body_tensor"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.one_body_tensor</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.diag_coulomb_mats"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.diag_coulomb_mats</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.orbital_rotations"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.orbital_rotations</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.constant"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.constant</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.z_representation"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.z_representation</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.from_molecular_hamiltonian"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.from_molecular_hamiltonian()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.norb"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.to_molecular_hamiltonian"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.to_molecular_hamiltonian()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.to_number_representation"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.to_number_representation()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.DoubleFactorizedHamiltonian.to_z_representation"><code class="docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian.to_z_representation()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.FermionAction"><code class="docutils literal notranslate"><span class="pre">FermionAction</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.FermionAction.action"><code class="docutils literal notranslate"><span class="pre">FermionAction.action</span></code></a></li>
<li><a class="reference internal" href="#ffsim.FermionAction.orb"><code class="docutils literal notranslate"><span class="pre">FermionAction.orb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.FermionAction.spin"><code class="docutils literal notranslate"><span class="pre">FermionAction.spin</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.FermionOperator"><code class="docutils literal notranslate"><span class="pre">FermionOperator</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.FermionOperator.conserves_particle_number"><code class="docutils literal notranslate"><span class="pre">FermionOperator.conserves_particle_number()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.FermionOperator.conserves_spin_z"><code class="docutils literal notranslate"><span class="pre">FermionOperator.conserves_spin_z()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.FermionOperator.many_body_order"><code class="docutils literal notranslate"><span class="pre">FermionOperator.many_body_order()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.FermionOperator.normal_ordered"><code class="docutils literal notranslate"><span class="pre">FermionOperator.normal_ordered()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOp"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOp</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOp.norb"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOp.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOp.interaction_pairs"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOp.interaction_pairs</span></code></a></li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOp.thetas"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOp.thetas</span></code></a></li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOp.phis"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOp.phis</span></code></a></li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOp.phase_angles"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOp.phase_angles</span></code></a></li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOp.from_orbital_rotation"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOp.from_orbital_rotation()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOp.from_parameters"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOp.from_parameters()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOp.n_params"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOp.n_params()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOp.to_orbital_rotation"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOp.to_orbital_rotation()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.GivensAnsatzOp.to_parameters"><code class="docutils literal notranslate"><span class="pre">GivensAnsatzOp.to_parameters()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.HopGateAnsatzOperator"><code class="docutils literal notranslate"><span class="pre">HopGateAnsatzOperator</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.HopGateAnsatzOperator.norb"><code class="docutils literal notranslate"><span class="pre">HopGateAnsatzOperator.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.HopGateAnsatzOperator.interaction_pairs"><code class="docutils literal notranslate"><span class="pre">HopGateAnsatzOperator.interaction_pairs</span></code></a></li>
<li><a class="reference internal" href="#ffsim.HopGateAnsatzOperator.thetas"><code class="docutils literal notranslate"><span class="pre">HopGateAnsatzOperator.thetas</span></code></a></li>
<li><a class="reference internal" href="#ffsim.HopGateAnsatzOperator.final_orbital_rotation"><code class="docutils literal notranslate"><span class="pre">HopGateAnsatzOperator.final_orbital_rotation</span></code></a></li>
<li><a class="reference internal" href="#ffsim.HopGateAnsatzOperator.from_parameters"><code class="docutils literal notranslate"><span class="pre">HopGateAnsatzOperator.from_parameters()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.HopGateAnsatzOperator.to_parameters"><code class="docutils literal notranslate"><span class="pre">HopGateAnsatzOperator.to_parameters()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.MolecularData"><code class="docutils literal notranslate"><span class="pre">MolecularData</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.MolecularData.core_energy"><code class="docutils literal notranslate"><span class="pre">MolecularData.core_energy</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.one_body_integrals"><code class="docutils literal notranslate"><span class="pre">MolecularData.one_body_integrals</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.two_body_integrals"><code class="docutils literal notranslate"><span class="pre">MolecularData.two_body_integrals</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.norb"><code class="docutils literal notranslate"><span class="pre">MolecularData.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.nelec"><code class="docutils literal notranslate"><span class="pre">MolecularData.nelec</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.atom"><code class="docutils literal notranslate"><span class="pre">MolecularData.atom</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.basis"><code class="docutils literal notranslate"><span class="pre">MolecularData.basis</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.spin"><code class="docutils literal notranslate"><span class="pre">MolecularData.spin</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.symmetry"><code class="docutils literal notranslate"><span class="pre">MolecularData.symmetry</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.mo_coeff"><code class="docutils literal notranslate"><span class="pre">MolecularData.mo_coeff</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.mo_occ"><code class="docutils literal notranslate"><span class="pre">MolecularData.mo_occ</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.active_space"><code class="docutils literal notranslate"><span class="pre">MolecularData.active_space</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.hf_energy"><code class="docutils literal notranslate"><span class="pre">MolecularData.hf_energy</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.hf_mo_coeff"><code class="docutils literal notranslate"><span class="pre">MolecularData.hf_mo_coeff</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.hf_mo_occ"><code class="docutils literal notranslate"><span class="pre">MolecularData.hf_mo_occ</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.mp2_energy"><code class="docutils literal notranslate"><span class="pre">MolecularData.mp2_energy</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.mp2_t2"><code class="docutils literal notranslate"><span class="pre">MolecularData.mp2_t2</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.ccsd_energy"><code class="docutils literal notranslate"><span class="pre">MolecularData.ccsd_energy</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.ccsd_t1"><code class="docutils literal notranslate"><span class="pre">MolecularData.ccsd_t1</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.ccsd_t2"><code class="docutils literal notranslate"><span class="pre">MolecularData.ccsd_t2</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.cisd_energy"><code class="docutils literal notranslate"><span class="pre">MolecularData.cisd_energy</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.cisd_vec"><code class="docutils literal notranslate"><span class="pre">MolecularData.cisd_vec</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.sci_energy"><code class="docutils literal notranslate"><span class="pre">MolecularData.sci_energy</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.sci_vec"><code class="docutils literal notranslate"><span class="pre">MolecularData.sci_vec</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.fci_energy"><code class="docutils literal notranslate"><span class="pre">MolecularData.fci_energy</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.fci_vec"><code class="docutils literal notranslate"><span class="pre">MolecularData.fci_vec</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.dipole_integrals"><code class="docutils literal notranslate"><span class="pre">MolecularData.dipole_integrals</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.orbital_symmetries"><code class="docutils literal notranslate"><span class="pre">MolecularData.orbital_symmetries</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.from_fcidump"><code class="docutils literal notranslate"><span class="pre">MolecularData.from_fcidump()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.from_json"><code class="docutils literal notranslate"><span class="pre">MolecularData.from_json()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.from_scf"><code class="docutils literal notranslate"><span class="pre">MolecularData.from_scf()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.hamiltonian"><code class="docutils literal notranslate"><span class="pre">MolecularData.hamiltonian</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.mole"><code class="docutils literal notranslate"><span class="pre">MolecularData.mole</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.run_ccsd"><code class="docutils literal notranslate"><span class="pre">MolecularData.run_ccsd()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.run_cisd"><code class="docutils literal notranslate"><span class="pre">MolecularData.run_cisd()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.run_fci"><code class="docutils literal notranslate"><span class="pre">MolecularData.run_fci()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.run_mp2"><code class="docutils literal notranslate"><span class="pre">MolecularData.run_mp2()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.run_sci"><code class="docutils literal notranslate"><span class="pre">MolecularData.run_sci()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.scf"><code class="docutils literal notranslate"><span class="pre">MolecularData.scf</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.to_fcidump"><code class="docutils literal notranslate"><span class="pre">MolecularData.to_fcidump()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularData.to_json"><code class="docutils literal notranslate"><span class="pre">MolecularData.to_json()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.MolecularHamiltonian"><code class="docutils literal notranslate"><span class="pre">MolecularHamiltonian</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.MolecularHamiltonian.one_body_tensor"><code class="docutils literal notranslate"><span class="pre">MolecularHamiltonian.one_body_tensor</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularHamiltonian.two_body_tensor"><code class="docutils literal notranslate"><span class="pre">MolecularHamiltonian.two_body_tensor</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularHamiltonian.constant"><code class="docutils literal notranslate"><span class="pre">MolecularHamiltonian.constant</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularHamiltonian.norb"><code class="docutils literal notranslate"><span class="pre">MolecularHamiltonian.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.MolecularHamiltonian.rotated"><code class="docutils literal notranslate"><span class="pre">MolecularHamiltonian.rotated()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.NumNumAnsatzOpSpinBalanced"><code class="docutils literal notranslate"><span class="pre">NumNumAnsatzOpSpinBalanced</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.NumNumAnsatzOpSpinBalanced.norb"><code class="docutils literal notranslate"><span class="pre">NumNumAnsatzOpSpinBalanced.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.NumNumAnsatzOpSpinBalanced.interaction_pairs"><code class="docutils literal notranslate"><span class="pre">NumNumAnsatzOpSpinBalanced.interaction_pairs</span></code></a></li>
<li><a class="reference internal" href="#ffsim.NumNumAnsatzOpSpinBalanced.thetas"><code class="docutils literal notranslate"><span class="pre">NumNumAnsatzOpSpinBalanced.thetas</span></code></a></li>
<li><a class="reference internal" href="#ffsim.NumNumAnsatzOpSpinBalanced.from_diag_coulomb_mats"><code class="docutils literal notranslate"><span class="pre">NumNumAnsatzOpSpinBalanced.from_diag_coulomb_mats()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.NumNumAnsatzOpSpinBalanced.from_parameters"><code class="docutils literal notranslate"><span class="pre">NumNumAnsatzOpSpinBalanced.from_parameters()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.NumNumAnsatzOpSpinBalanced.n_params"><code class="docutils literal notranslate"><span class="pre">NumNumAnsatzOpSpinBalanced.n_params()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.NumNumAnsatzOpSpinBalanced.to_diag_coulomb_mats"><code class="docutils literal notranslate"><span class="pre">NumNumAnsatzOpSpinBalanced.to_diag_coulomb_mats()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.NumNumAnsatzOpSpinBalanced.to_parameters"><code class="docutils literal notranslate"><span class="pre">NumNumAnsatzOpSpinBalanced.to_parameters()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.ProductStateSum"><code class="docutils literal notranslate"><span class="pre">ProductStateSum</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.ProductStateSum.coeffs"><code class="docutils literal notranslate"><span class="pre">ProductStateSum.coeffs</span></code></a></li>
<li><a class="reference internal" href="#ffsim.ProductStateSum.states"><code class="docutils literal notranslate"><span class="pre">ProductStateSum.states</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian.one_body_tensor"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian.one_body_tensor</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian.one_body_squares"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian.one_body_squares</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian.constant"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian.constant</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian.expectation_product_state"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian.expectation_product_state()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian.from_molecular_hamiltonian"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian.from_molecular_hamiltonian()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian.norb"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SingleFactorizedHamiltonian.reduced_matrix_product_states"><code class="docutils literal notranslate"><span class="pre">SingleFactorizedHamiltonian.reduced_matrix_product_states()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.Spin"><code class="docutils literal notranslate"><span class="pre">Spin</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.Spin.ALPHA"><code class="docutils literal notranslate"><span class="pre">Spin.ALPHA</span></code></a></li>
<li><a class="reference internal" href="#ffsim.Spin.ALPHA_AND_BETA"><code class="docutils literal notranslate"><span class="pre">Spin.ALPHA_AND_BETA</span></code></a></li>
<li><a class="reference internal" href="#ffsim.Spin.BETA"><code class="docutils literal notranslate"><span class="pre">Spin.BETA</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.StateVector"><code class="docutils literal notranslate"><span class="pre">StateVector</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.StateVector.vec"><code class="docutils literal notranslate"><span class="pre">StateVector.vec</span></code></a></li>
<li><a class="reference internal" href="#ffsim.StateVector.norb"><code class="docutils literal notranslate"><span class="pre">StateVector.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.StateVector.nelec"><code class="docutils literal notranslate"><span class="pre">StateVector.nelec</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.SupportsApplyUnitary"><code class="docutils literal notranslate"><span class="pre">SupportsApplyUnitary</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SupportsApproximateEquality"><code class="docutils literal notranslate"><span class="pre">SupportsApproximateEquality</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SupportsDiagonal"><code class="docutils literal notranslate"><span class="pre">SupportsDiagonal</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SupportsFermionOperator"><code class="docutils literal notranslate"><span class="pre">SupportsFermionOperator</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SupportsLinearOperator"><code class="docutils literal notranslate"><span class="pre">SupportsLinearOperator</span></code></a></li>
<li><a class="reference internal" href="#ffsim.SupportsTrace"><code class="docutils literal notranslate"><span class="pre">SupportsTrace</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCCSDOpRestrictedReal"><code class="docutils literal notranslate"><span class="pre">UCCSDOpRestrictedReal</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.UCCSDOpRestrictedReal.from_parameters"><code class="docutils literal notranslate"><span class="pre">UCCSDOpRestrictedReal.from_parameters()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCCSDOpRestrictedReal.n_params"><code class="docutils literal notranslate"><span class="pre">UCCSDOpRestrictedReal.n_params()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCCSDOpRestrictedReal.norb"><code class="docutils literal notranslate"><span class="pre">UCCSDOpRestrictedReal.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCCSDOpRestrictedReal.to_parameters"><code class="docutils literal notranslate"><span class="pre">UCCSDOpRestrictedReal.to_parameters()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.UCJAnglesOpSpinBalanced"><code class="docutils literal notranslate"><span class="pre">UCJAnglesOpSpinBalanced</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.UCJAnglesOpSpinBalanced.from_parameters"><code class="docutils literal notranslate"><span class="pre">UCJAnglesOpSpinBalanced.from_parameters()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJAnglesOpSpinBalanced.from_t_amplitudes"><code class="docutils literal notranslate"><span class="pre">UCJAnglesOpSpinBalanced.from_t_amplitudes()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJAnglesOpSpinBalanced.from_ucj_op"><code class="docutils literal notranslate"><span class="pre">UCJAnglesOpSpinBalanced.from_ucj_op()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJAnglesOpSpinBalanced.n_params"><code class="docutils literal notranslate"><span class="pre">UCJAnglesOpSpinBalanced.n_params()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJAnglesOpSpinBalanced.n_reps"><code class="docutils literal notranslate"><span class="pre">UCJAnglesOpSpinBalanced.n_reps</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJAnglesOpSpinBalanced.to_parameters"><code class="docutils literal notranslate"><span class="pre">UCJAnglesOpSpinBalanced.to_parameters()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinBalanced"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinBalanced</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.UCJOpSpinBalanced.diag_coulomb_mats"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinBalanced.diag_coulomb_mats</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinBalanced.orbital_rotations"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinBalanced.orbital_rotations</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinBalanced.final_orbital_rotation"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinBalanced.final_orbital_rotation</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinBalanced.from_parameters"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinBalanced.from_parameters()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinBalanced.from_t_amplitudes"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinBalanced.from_t_amplitudes()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinBalanced.n_params"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinBalanced.n_params()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinBalanced.n_reps"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinBalanced.n_reps</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinBalanced.norb"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinBalanced.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinBalanced.to_parameters"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinBalanced.to_parameters()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinUnbalanced"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinUnbalanced</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.UCJOpSpinUnbalanced.diag_coulomb_mats"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinUnbalanced.diag_coulomb_mats</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinUnbalanced.orbital_rotations"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinUnbalanced.orbital_rotations</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinUnbalanced.final_orbital_rotation"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinUnbalanced.final_orbital_rotation</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinUnbalanced.from_parameters"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinUnbalanced.from_parameters()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinUnbalanced.from_t_amplitudes"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinUnbalanced.from_t_amplitudes()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinUnbalanced.n_params"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinUnbalanced.n_params()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinUnbalanced.n_reps"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinUnbalanced.n_reps</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinUnbalanced.norb"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinUnbalanced.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinUnbalanced.to_parameters"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinUnbalanced.to_parameters()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinless"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinless</span></code></a><ul>
<li><a class="reference internal" href="#ffsim.UCJOpSpinless.diag_coulomb_mats"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinless.diag_coulomb_mats</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinless.orbital_rotations"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinless.orbital_rotations</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinless.final_orbital_rotation"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinless.final_orbital_rotation</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinless.from_parameters"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinless.from_parameters()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinless.from_t_amplitudes"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinless.from_t_amplitudes()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinless.n_params"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinless.n_params()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinless.n_reps"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinless.n_reps</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinless.norb"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinless.norb</span></code></a></li>
<li><a class="reference internal" href="#ffsim.UCJOpSpinless.to_parameters"><code class="docutils literal notranslate"><span class="pre">UCJOpSpinless.to_parameters()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ffsim.addresses_to_strings"><code class="docutils literal notranslate"><span class="pre">addresses_to_strings()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_diag_coulomb_evolution"><code class="docutils literal notranslate"><span class="pre">apply_diag_coulomb_evolution()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_fsim_gate"><code class="docutils literal notranslate"><span class="pre">apply_fsim_gate()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_fswap_gate"><code class="docutils literal notranslate"><span class="pre">apply_fswap_gate()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_givens_rotation"><code class="docutils literal notranslate"><span class="pre">apply_givens_rotation()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_hop_gate"><code class="docutils literal notranslate"><span class="pre">apply_hop_gate()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_num_interaction"><code class="docutils literal notranslate"><span class="pre">apply_num_interaction()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_num_num_interaction"><code class="docutils literal notranslate"><span class="pre">apply_num_num_interaction()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_num_op_prod_interaction"><code class="docutils literal notranslate"><span class="pre">apply_num_op_prod_interaction()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_num_op_sum_evolution"><code class="docutils literal notranslate"><span class="pre">apply_num_op_sum_evolution()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_on_site_interaction"><code class="docutils literal notranslate"><span class="pre">apply_on_site_interaction()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_orbital_rotation"><code class="docutils literal notranslate"><span class="pre">apply_orbital_rotation()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_tunneling_interaction"><code class="docutils literal notranslate"><span class="pre">apply_tunneling_interaction()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.apply_unitary"><code class="docutils literal notranslate"><span class="pre">apply_unitary()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.approx_eq"><code class="docutils literal notranslate"><span class="pre">approx_eq()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.cre"><code class="docutils literal notranslate"><span class="pre">cre()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.cre_a"><code class="docutils literal notranslate"><span class="pre">cre_a()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.cre_b"><code class="docutils literal notranslate"><span class="pre">cre_b()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.des"><code class="docutils literal notranslate"><span class="pre">des()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.des_a"><code class="docutils literal notranslate"><span class="pre">des_a()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.des_b"><code class="docutils literal notranslate"><span class="pre">des_b()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.diag"><code class="docutils literal notranslate"><span class="pre">diag()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.dim"><code class="docutils literal notranslate"><span class="pre">dim()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.dims"><code class="docutils literal notranslate"><span class="pre">dims()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.expectation_one_body_power"><code class="docutils literal notranslate"><span class="pre">expectation_one_body_power()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.expectation_one_body_product"><code class="docutils literal notranslate"><span class="pre">expectation_one_body_product()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.fermi_hubbard_1d"><code class="docutils literal notranslate"><span class="pre">fermi_hubbard_1d()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.fermi_hubbard_2d"><code class="docutils literal notranslate"><span class="pre">fermi_hubbard_2d()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.fermion_operator"><code class="docutils literal notranslate"><span class="pre">fermion_operator()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.hartree_fock_state"><code class="docutils literal notranslate"><span class="pre">hartree_fock_state()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.init_cache"><code class="docutils literal notranslate"><span class="pre">init_cache()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.linear_operator"><code class="docutils literal notranslate"><span class="pre">linear_operator()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.multireference_state"><code class="docutils literal notranslate"><span class="pre">multireference_state()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.multireference_state_prod"><code class="docutils literal notranslate"><span class="pre">multireference_state_prod()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.number_operator"><code class="docutils literal notranslate"><span class="pre">number_operator()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.rdms"><code class="docutils literal notranslate"><span class="pre">rdms()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.sample_slater_determinant"><code class="docutils literal notranslate"><span class="pre">sample_slater_determinant()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.sample_state_vector"><code class="docutils literal notranslate"><span class="pre">sample_state_vector()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.simulate_qdrift_double_factorized"><code class="docutils literal notranslate"><span class="pre">simulate_qdrift_double_factorized()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.simulate_trotter_diag_coulomb_split_op"><code class="docutils literal notranslate"><span class="pre">simulate_trotter_diag_coulomb_split_op()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.simulate_trotter_double_factorized"><code class="docutils literal notranslate"><span class="pre">simulate_trotter_double_factorized()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.slater_determinant"><code class="docutils literal notranslate"><span class="pre">slater_determinant()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.slater_determinant_amplitudes"><code class="docutils literal notranslate"><span class="pre">slater_determinant_amplitudes()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.slater_determinant_rdms"><code class="docutils literal notranslate"><span class="pre">slater_determinant_rdms()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.spin_square"><code class="docutils literal notranslate"><span class="pre">spin_square()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.strings_to_addresses"><code class="docutils literal notranslate"><span class="pre">strings_to_addresses()</span></code></a></li>
<li><a class="reference internal" href="#ffsim.trace"><code class="docutils literal notranslate"><span class="pre">trace()</span></code></a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=29b35963"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=5fa4622c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>